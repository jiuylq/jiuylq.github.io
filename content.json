{"meta":{"title":"jiuylq","subtitle":null,"description":null,"author":"jiuy","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-03-07T16:16:53.000Z","updated":"2019-03-13T14:59:49.328Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-07T16:14:32.000Z","updated":"2019-03-13T14:59:37.348Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-03-07T15:24:53.000Z","updated":"2019-03-07T16:18:26.767Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2019-03-07T13:09:51.143Z","updated":"2019-03-07T16:09:17.526Z","comments":true,"path":"2019/03/07/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"js-date","slug":"js-date","date":"2018-01-07T07:51:28.000Z","updated":"2018-10-19T12:57:32.776Z","comments":true,"path":"2018/01/07/js-date/","link":"","permalink":"http://yoursite.com/2018/01/07/js-date/","excerpt":"唉，最近越来越懒了，博客拖更了。今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。","text":"唉，最近越来越懒了，博客拖更了。今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。 一、日期对象 在javascript中并没有日期型的数据类型，但是提供了一个日期对象可以操作日期和时间。日期对象的创建：new Date(); 二、将日期对象转换为字符串 将日期对象转换为字符串可以使用以下4种方法：date.toString();//将日期对象转换为字符串时，采用的是本地时间date.toLocalString();//将日期对象转换为字符串，采用的是本地时间，显示的是地方日期的格式date.toUTCString();//将日期对象转换为字符串时，采用的是世界时间。date.toGMTString();//将日期对象转换为字符串时，采用的是GMT时间，但是已被禁止使用，一般用toUTCString()方法来替换。 三、将日期对象中的日期和时间转换为字符串 date.toDateString();//将日期部分转换为字符串，本地时间date.toLocalDateString();//将日期部分转换为字符串，采用的是本地时间，显示的是地方日期的格式date.toTimeString();//将时间部分转换为字符串，本地时间date.toLocalTimeString();将时间部分转换为字符串，采用的是本地时间，显示的是地方日期的格式 四、日期对象中的日期 date.getYear();//获取年份，但不建议使用。date.getFullYear();//获取年份，，以四位数显式，建议使用date.getMonth();//获取月份，值为0-11，一月份为0，二月份为1…date.getDate();//获取天数，即一个月中的某一天date.getDay();//获取一周中的第几天，值为0-6，周日为0… 五、日期对象中的时间 date.getHours();//返回小时部分date.getMinutes();//返回分钟部分date.getSeconds();//返回秒钟部分date.getMilliseconds();//返回毫秒部分date.getTime();//返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.getTimezoneoffset();//返回日期对象中的时间与UTC之间的时差数，单位为秒。 六、设置日期对象中的日期e date.setYear(year);//不建议使用date.setFullYear(year,month,day);//year四位数;month：0-11，该参数可省略;day：1-31， 该参数可省略date.setMonth(month,day);//month：0-11;day：1-31， 该参数可省略date.getDate(day);//day：1-31 七、设置日期对象中的时间 date.getHours(hours,minutes,seconds,milliseconds);//hours:0-23,minutes:0-59,可省略，seconds:0-59,可省略milliseconds:0-999，可省略date.getMinutes(minutes,seconds,milliseconds);//minutes:0-59,seconds:0-59,可省略milliseconds:0-999，可省略date.getSeconds(seconds,milliseconds);// seconds:0-59,milliseconds:0-999，可省略date.getMilliseconds(milliseconds);//,milliseconds:0-999 八、与毫秒相关的方法 date.setTime(millisecinds);milliseconds代表设置的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.valueOf();返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.parse(str);返回str参数所代表的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.UTC(year,month,day,hours,minutes,seconds,milliseconds);将参数所代表的日期转换成与1970年1月1日0时0分0秒所间隔的毫秒数 实例1、获取时间截12345678//一var timestamp = new Date().getTime(); //new Date(\"2012/7/25 20:11:11\").getTime()//二var timestamp = (new Date()).valueOf()// 三var timestamp = +new Date() //相当于ToNumber(new Date())// 四var timestamp = Date.now() 2、格式化时间123456789101112131415161718//使用方法：var val=new Date(\"2012/7/25 20:11:11\").getTime() var crtTime = new Date(val); dateFtt(\"yyyy-MM-dd q hh:mm:ss\",crtTime);function dateFtt(fmt,date) &#123;var o = &#123; \"M+\" : date.getMonth()+1, //月份 \"d+\" : date.getDate(), //日 \"h+\" : date.getHours(), //小时 \"m+\" : date.getMinutes(), //分 \"s+\" : date.getSeconds(), //秒 \"q+\" : Math.floor((date.getMonth()+3)/3), //季度 \"S\" : date.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) fmt=fmt.replace(RegExp.$1, (date.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o) if(new RegExp(\"(\"+ k +\")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); return fmt; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /* * 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * eg: * (new Date()).pattern(\"yyyy-MM-dd hh:mm:ss.S\")==&gt; 2006-07-02 08:09:04.423 * (new Date()).pattern(\"yyyy-MM-dd E HH:mm:ss\") ==&gt; 2009-03-10 二 20:09:04 * (new Date()).pattern(\"yyyy-MM-dd EE hh:mm:ss\") ==&gt; 2009-03-10 周二 08:09:04 * (new Date()).pattern(\"yyyy-MM-dd EEE hh:mm:ss\") ==&gt; 2009-03-10 星期二 08:09:04 * (new Date()).pattern(\"yyyy-M-d h:m:s.S\") ==&gt; 2006-7-2 8:9:4.18 */ Date.prototype.pattern=function(fmt) &#123; var o = &#123; \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 \"H+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 &#125;; var week = &#123; \"0\" : \"\\u65e5\", \"1\" : \"\\u4e00\", \"2\" : \"\\u4e8c\", \"3\" : \"\\u4e09\", \"4\" : \"\\u56db\", \"5\" : \"\\u4e94\", \"6\" : \"\\u516d\" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? \"\\u661f\\u671f\" : \"\\u5468\") : \"\")+week[this.getDay()+\"\"]); &#125; for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); &#125; &#125; return fmt; &#125; var date = new Date(); window.alert(date.pattern(\"yyyy-MM-dd hh:mm:ss\"));","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js-date","slug":"js-date","permalink":"http://yoursite.com/tags/js-date/"}]},{"title":"Promise","slug":"promise","date":"2018-01-03T14:35:37.000Z","updated":"2018-02-03T14:04:12.635Z","comments":true,"path":"2018/01/03/promise/","link":"","permalink":"http://yoursite.com/2018/01/03/promise/","excerpt":"ES6 Promise对象讲解及其用法！","text":"ES6 Promise对象讲解及其用法！ Promise 对象Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 123456789101112const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"rejected: \", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(\"resolved: \", comments), err =&gt; console.log(\"rejected: \", err)); Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); 下面是一个例子。 1234567const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果 Promise 状态已经变成resolved，再抛出错误是无效的。 12345678const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 1234567891011121314const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('everything is great');&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);// Uncaught (in promise) ReferenceError: x is not defined// 123 上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。 123process.on('unhandledRejection', function (err, p) &#123; throw err;&#125;); 上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。 注意，Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。 再看下面的例子。 1234567const promise = new Promise(function (resolve, reject) &#123; resolve('ok'); setTimeout(function () &#123; throw new Error('test') &#125;, 0)&#125;);promise.then(function (value) &#123; console.log(value) &#125;);// ok// Uncaught Error: test 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 12345678910111213141516const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 12345678Promise.resolve().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// carry on 上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。 1234567891011121314151617const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为 y 没有声明 y + 2;&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined] 上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 1234567891011someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为y没有声明 y + 2;&#125;).catch(function(error) &#123; console.log('carry on', error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined] 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 12345server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 finally本质上是then方法的特例。 1234567891011121314151617promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现也很简单。 1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值。 1234567891011// resolve 的值是 undefinedPromise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// resolve 的值是 2Promise.resolve(2).finally(() =&gt; &#123;&#125;)// reject 的值是 undefinedPromise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// reject 的值是 3Promise.reject(3).finally(() =&gt; &#123;&#125;) Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子。 12345678910111213const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 Promise.race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error)); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve等价于下面的写法。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况。 （1）参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。 12345const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码的变量p就是一个 Promise 对象。 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Generator 函数与 Promise 的结合使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 1Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 12345const f = () =&gt; console.log('now');Promise.resolve().then(f);console.log('next');// next// now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 12345const f = () =&gt; console.log('now');(async () =&gt; f())();console.log('next');// now// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 12(async () =&gt; f())().then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 123(async () =&gt; f())().then(...).catch(...) 第二种写法是使用new Promise()。 123456789const f = () =&gt; console.log('now');( () =&gt; new Promise( resolve =&gt; resolve(f()) ))();console.log('next');// now// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 12345const f = () =&gt; console.log('now');Promise.try(f);console.log('next');// now// next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 123456function getUsername(userId) &#123; return database.users.get(&#123;id: userId&#125;) .then(function(user) &#123; return user.name; &#125;);&#125; 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 123database.users.get(&#123;id: userId&#125;).then(...).catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 1234567try &#123; database.users.get(&#123;id: userId&#125;) .then(...) .catch(...)&#125; catch (e) &#123; // ...&#125; 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 123Promise.try(database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"markdown-guide","slug":"markdown-guide","date":"2017-11-05T14:41:34.000Z","updated":"2017-11-05T16:38:01.118Z","comments":true,"path":"2017/11/05/markdown-guide/","link":"","permalink":"http://yoursite.com/2017/11/05/markdown-guide/","excerpt":"Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。","text":"Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。 Markdown简介Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。这个教程可以让使用 Markdown 的新手快速熟悉语法和快捷键。本文基于 Ghost 的 Markdown 指南，兼容标准版 Markdown 编辑器和 Github Flavored Markdown。 NOTE: 虽然 Markdown 标记语言不能够实现 HTML 语法上的全部功能，但你可以混合使用 HTML 和 Markdown 语法。此页提供 Markdown 的简单入门指南，而 语法说明 页提供了详细的文档。 常用语法标题1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题或这是一个一级标题============================这是一个二级标题-------------------------------------------------- 注：# 和「标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 列表 无序列表 无序列表是使用*,+,-中任意一种来表示1234567891011* 文本1* 文本2* 文本3或+ 文本1+ 文本2+ 文本3或- 文本1- 文本2- 文本3 有序列表 1231. 文本12. 文本23. 文本3 注：-、1.和文本之间要保留一个字符的空格。 链接和图片 链接 行内式在 Markdown 中，插入链接不需要其他按钮，你只需要使用 显示文本 这样的语法即可，例如： 12[title](url &quot;描述&quot;)[hexo](https://hexo.io) hexo 参考式1234[title][id] 标记: [id]: https://www.baidu.com/ &quot;度娘&quot; 或者: [id]: https://www.baidu.com/ &apos;度娘&apos; (简书不支持) 或者 [id]: https://www.baidu.com/ (度娘) [title][121][121]: https://www.baidu.com/ “度娘” 隐式链接标记功能12[Baidu][] 标记可以这样写: [Baidu]: http://baidu.com Baidu 参考式链接范例: 12345678910I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 自动链接12示例如下: &lt;http:\\\\www.baidu.com&gt; 图片 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 这样的语法即可，例如： 123456![图片Alt](图片地址 “图片Title”)![title](https://hexo.io/img/a.jpg)![title](https://hexo.io/img/a.jpg &quot;描述&quot;)或![title][1][1]: https://hexo.io/img/a.jpg &quot;描述&quot; 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。 强调 Markdown使用性星号()和底线(_)作为标记强调字词的符号两端被一个或包围的单词会被转换成斜体两端被两个*或`包围的单词会被转换成粗体*`或_的两端不能有空白用什么符号就以什么符号结尾 1234567示例*斜体*_斜体_**粗体**__粗体__***加粗斜体***~~删除线~~ 斜体 _斜体_ 粗体 粗体 加粗斜体 删除线 引用 在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如： 1234567891011121314&gt; 简单引用1 &gt; 简单引用2 &gt; &gt; 多行引用 &gt;&gt; 嵌套引用 &gt; ## 引用中使用Markdown语法。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 简单引用1简单引用2 多行引用 嵌套引用 引用中使用Markdown语法。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 代码引用 需要引用代码时，如果引用的语句只有一段，不分行，可以用`将语句包起来。如果引用的语句为多行，可以将```置于这段代码的首行和末行。 分隔线 一行中用三个以上的星号、减号、底线来建立一个分隔线,行内不能有其他东西,也可以在星号或是减号中间插入空格 1--- 1- - - 1*** 1* * * 1—————————————— —————————————— 段落和换行 段落 段落是由一个或多个连续的文本行组成,它的前后要一个以上的空行(显示上看起来像是空的) 换行 Mardown允许段落内的强迫换行(插入换行符)要依赖Markdown来插入&lt;br/&gt;标签的话,在&lt;br/&gt;插入处要先按入两个以上的空格然后回车 表格 居中 1234567891011 Tables | Are | Cool :------------: |:-------------:|:-----: col 3 is | right-aligned | $1600 col 2 is | centered | $12 zebra stripes | are neat | $1 或| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 不居中 12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz dog bird cat foo foo foo bar bar bar baz baz baz 123456789101112131415161718192021221、简单方式写表格：学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|922、原生方式写表格：|学号|姓名|分数||-|-|-||小明|男|75||小红|女|79||小陆|男|92|3、为表格第二列指定方向：产品|价格-|-:Leanote 高级账号|60元/年Leanote 超级账号|120元/年 1、简单方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 2、原生方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 3、为表格第二列指定方向： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 转义 使用反斜杠来插入一些在语法中有其它意义的符号,如*需要转义的字符: 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。注意： Markdown Extra 只支持在标题后插入锚点，其它地方无效。 Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。 12## 0. 目录&#123;#index&#125;跳转到[目录](#index) 注脚 在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 1234使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2] ,你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML^2 ,你可以使用 Leanote^Le 编辑器进行书写。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}]},{"title":"plugins-hexo","slug":"plugins-hexo","date":"2017-11-05T13:40:59.000Z","updated":"2017-11-05T14:57:31.044Z","comments":true,"path":"2017/11/05/plugins-hexo/","link":"","permalink":"http://yoursite.com/2017/11/05/plugins-hexo/","excerpt":"Hexo博客常用插件及用法","text":"Hexo博客常用插件及用法 hexoDoc：https://hexo.io/zh-cn/Api：https://hexo.io/zh-cn/api/Plugins：https://hexo.io/plugins/Themes：https://hexo.io/themes/ hexo-generator-json-contentGithub：https://github.com/alexbruno/hexo-generator-json-content简介：用于生成静态站点数据，提供搜索功能的数据源。安装：1npm install hexo-generator-json-content --save 配置：在博客配置文件_config.yml中添加1234567jsonContent: ignore: - path/to/a/page - url/to/one/post - an-entire-category - specific.file - .ext # a file extension hexo-neatGithub：https://github.com/rozbo/hexo-neat简介：自动压缩html、css、js代码安装：1npm install hexo-neat --save 配置：在博客配置文件_config.yml中添加1neat_enable: true 压缩html代码123neat_html: enable: true exclude: 压缩CSS1234neat_css: enable: true exclude: - &apos;*.min.css&apos; 压缩JS1234567neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos; hexo-wordcountGithub：https://github.com/willin/hexo-wordcountA Word Count Plugin for Hexo https://npmjs.org/package/hexo-wordcount简介：为文章添加文章字数统计、文章预计阅读时间安装：1npm install hexo-wordcount --save 使用：通过以上安装后，你可以在你的模板文件加入以下相关的标签实现本插件的功能字数统计:WordCount阅读时长预计:Min2Read总字数统计: TotalCount Ejs Post Count:1&lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;&lt;/span&gt; Post Minutes to Read:1&lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;&lt;/span&gt; Total Count:1&lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; hexo-generator-json-content","categories":[{"name":"plugins","slug":"plugins","permalink":"http://yoursite.com/categories/plugins/"}],"tags":[{"name":"plugins","slug":"plugins","permalink":"http://yoursite.com/tags/plugins/"}]},{"title":"js-plugins","slug":"plugins","date":"2017-10-30T14:35:37.000Z","updated":"2017-11-05T14:35:27.250Z","comments":true,"path":"2017/10/30/plugins/","link":"","permalink":"http://yoursite.com/2017/10/30/plugins/","excerpt":"日常中常用到的js plugins。","text":"日常中常用到的js plugins。 plugins https://github.com/jawil/blog/issues/10pdf.js PDF.js is a Portable Document Format (PDF) viewer that is built with HTML5 github highlight.jsHighlight.js is a syntax highlighter written in JavaScript. It works in the browser as well as on the server. It works with pretty much any markup, doesn’t depend on any framework and has automatic language detection.github clipboard.jsA modern approach to copy text to clipboardgithub 官网 cropperjsJavaScript image croppergithub Lazy Loading Echo简单易用的图片延迟加载插件github 官方 Lazyr.js延迟加载图片（Lazy Loading）github 官方 better-scroll.js小巧，灵活的 JavaScript 模拟滚动条的插件github 官方 better-picker一款轻量级IOS风格的JavaScript选择器github 官方","categories":[{"name":"plugins","slug":"plugins","permalink":"http://yoursite.com/categories/plugins/"}],"tags":[{"name":"plugins","slug":"plugins","permalink":"http://yoursite.com/tags/plugins/"}]}]}